<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hb的博客站</title>
  
  
  <link href="https://useritem.github.io/atom.xml" rel="self"/>
  
  <link href="https://useritem.github.io/"/>
  <updated>2021-06-04T14:13:26.285Z</updated>
  <id>https://useritem.github.io/</id>
  
  <author>
    <name>〃不枉俗尘づ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>axios使用问题</title>
    <link href="https://useritem.github.io/2021/06/04/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/axios%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://useritem.github.io/2021/06/04/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/axios%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-04T14:05:46.000Z</published>
    <updated>2021-06-04T14:13:26.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、axios使用"><a href="#一、axios使用" class="headerlink" title="一、axios使用"></a>一、axios使用</h1><h2 id="1、axios介绍"><a href="#1、axios介绍" class="headerlink" title="1、axios介绍"></a>1、axios介绍</h2><p>axios是前端最流行的 ajax 请求库,</p><p>且react/vue 官方都推荐使用 axios 发 ajax 请求，axios直接调用：</p><pre><code>  &lt;script src="https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js"&gt;&lt;/script&gt;</code></pre><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol><li>基于 xhr + promise 的异步 ajax 请求库</li><li>浏览器端/node 端都可以使用</li><li>支持请求／响应拦截器，即中间进行修改</li><li>支持请求取消</li><li>请求/响应数据转换</li><li>也可以批量发送多个请求</li></ol><h2 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h2><h3 id="（1）使用axios方法直接调用"><a href="#（1）使用axios方法直接调用" class="headerlink" title="（1）使用axios方法直接调用"></a>（1）使用axios方法直接调用</h3><pre><code> axios({            //请求类型            method: 'POST',            //URL            url: 'http://localhost:3000/posts',            //设置请求体            data: {                title: "今天天气不错, 还挺风和日丽的",                author: "张三"            }        }).then(response =&gt; {            console.log(response);        });</code></pre><p>注意axios.request(config): <strong>等同于</strong> axios(config)，</p><p>且config就是里面的对象{}</p><h3 id="（2）以请求类型进行调用（以post为例）"><a href="#（2）以请求类型进行调用（以post为例）" class="headerlink" title="（2）以请求类型进行调用（以post为例）"></a>（2）以请求类型进行调用（以post为例）</h3><pre><code>        axios.post(            'http://localhost:3000/comments',             {                "body": "喜大普奔",                "postId": 2            }).then(response =&gt; {                console.log(response);            })</code></pre><h2 id="3、默认配置设置"><a href="#3、默认配置设置" class="headerlink" title="3、默认配置设置"></a>3、默认配置设置</h2><p>即在axios的defaults属性上进行添加</p><pre><code>    axios.defaults.method = 'GET';//设置默认的请求类型为 GET    axios.defaults.baseURL = 'http://localhost:3000';//设置基础 URL    axios.defaults.params = {id:100};    axios.defaults.timeout = 3000;//    btns[0].onclick = function(){        axios({            url: '/posts'        }).then(response =&gt; {            console.log(response);        })    }</code></pre><p>axios其他默认属性详见：</p><p><a href="https://github.com/axios/axios#features">https://github.com/axios/axios#features</a></p><h2 id="4、axios实例对象的创建及使用"><a href="#4、axios实例对象的创建及使用" class="headerlink" title="4、axios实例对象的创建及使用"></a>4、axios实例对象的创建及使用</h2><p>axios通过create(config)进行实例对象的创建，并且用实例对象写请求</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>当接口服务，<strong>不仅仅一个服务器</strong>(即有部分接口需要的配置与另一部分接口需要的配置不太一<br>样)时，</p><p><strong>默认配置defaults</strong>仅会对一个好用，其他的不行，协议域名都需要加上</p><p>所以当创建创建 2 个新 axios, 每个都有自己特有的配置，可以借助多个对象发送，有效减少了代码量</p><p>例：</p><pre><code> //创建实例对象      const duanzi = axios.create({        baseURL: 'https://api.apiopen.top',        timeout: 2000    });    const onather = axios.create({        baseURL: 'https://b.com',        timeout: 2000    });    //使用：    duanzi.get('/getJoke').then(response =&gt; {        console.log(response.data)    })</code></pre><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><ol><li><p>根据指定配置创建一个新的 axios, 也就就每个新 axios 都有自己的配置</p></li><li><p>新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的</p></li></ol><h2 id="5、拦截器"><a href="#5、拦截器" class="headerlink" title="5、拦截器"></a>5、拦截器</h2><p>梗概：</p><p>请求拦截器nterceptors.request在发送请求之前，用函数对请求的参数进行处理与检测</p><p>响应拦截器interceptors.response，也是同样对结果进行检查，没问题才会给用户</p><p>特别的：</p><p>请求拦截器后进先执行，响应拦截器先进先执行，见下面例子</p><p>说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程</p><pre><code>    axios.interceptors.request.use(function (config) {        console.log('请求拦截器 成功 - 1号');        //修改 config 中的参数        config.params = {a:100};        return config;    }, function (error) {        console.log('请求拦截器 失败 - 1号');        return Promise.reject(error);    });    axios.interceptors.request.use(function (config) {        console.log('请求拦截器 成功 - 2号');        config.timeout = 2000;        return config;    }, function (error) {        console.log('请求拦截器 失败 - 2号');        return Promise.reject(error);    });    // 设置响应拦截器    axios.interceptors.response.use(function (response) {        console.log('响应拦截器 成功 1号');        return response.data;        // return response;    }, function (error) {        console.log('响应拦截器 失败 1号')        return Promise.reject(error);    });</code></pre><p>结果:</p><p>请求拦截器2 =&gt; 请求拦截器1 =&gt; 发ajax请求 =&gt; 响应拦截器1 =&gt; 响<br>应拦截器 2 =&gt; 请求的回调</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应<br>拦截器传递的是 response</p><h2 id="6、取消请求"><a href="#6、取消请求" class="headerlink" title="6、取消请求"></a>6、取消请求</h2><h3 id="（1）基本流程"><a href="#（1）基本流程" class="headerlink" title="（1）基本流程"></a>（1）基本流程</h3><p>1、配置 cancelToken 对象</p><p>2、缓存用于取消请求的 cancel 函数</p><p>3、在后面特定时机调用 cancel 函数取消请求</p><p>4、在错误回调中判断如果 error 是 cancel, 做相应处理</p><p>例子：二次点击时先取消之前的请求</p><pre><code>//2.声明全局变量    let cancel = null;    //发送请求    btns[0].onclick = function(){        //检测上一次的请求是否已经完成        if(cancel !== null){            //取消上一次的请求            cancel();        }        axios({            method: 'GET',            url: 'http://localhost:3000/posts',            //1. 添加配置对象的属性            cancelToken: new axios.CancelToken(function(c){                //3. 将 c 的值赋值给 cancel                cancel = c;            })        }).then(response =&gt; {            console.log(response);            //将 cancel 的值初始化            cancel = null;        })    }</code></pre><p>当然了自己测试时，如果使用的时json-server的话可以让其延缓执行，码：</p><pre><code>json-server --watch db.json -d 3000   </code></pre><p>延迟3s出结果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、axios使用&quot;&gt;&lt;a href=&quot;#一、axios使用&quot; class=&quot;headerlink&quot; title=&quot;一、axios使用&quot;&gt;&lt;/a&gt;一、axios使用&lt;/h1&gt;&lt;h2 id=&quot;1、axios介绍&quot;&gt;&lt;a href=&quot;#1、axios介绍&quot; class</summary>
      
    
    
    
    <category term="js经典问题" scheme="https://useritem.github.io/categories/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>jq4 -- 事件与属性</title>
    <link href="https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq4-%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%B1%9E%E6%80%A7/"/>
    <id>https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq4-%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%B1%9E%E6%80%A7/</id>
    <published>2021-05-25T12:49:10.000Z</published>
    <updated>2021-05-25T12:52:05.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、属性控制"><a href="#一、属性控制" class="headerlink" title="一、属性控制"></a>一、属性控制</h1><h2 id="1、属性的设置与获取"><a href="#1、属性的设置与获取" class="headerlink" title="1、属性的设置与获取"></a>1、属性的设置与获取</h2><h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><p>进行单个元素属性：</p><pre><code>    $('img').attr('src','./src/图片2.gif')   //以前有src属性，所以对其进行修改    $('img').attr('aaa','hahaha')  //也可以对已有的自定义属性，进行修改     $('img').attr('bbb','hahaha')   --- 对没有的属性，会进行添加</code></pre><p>进行多个元素属性设置 — 对象</p><pre><code>    $('img').attr({        'src':'./src/图片2.gif',        'aaa':'hahaha',         bb:'hahaha'    })</code></pre><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><p>获取属性attr，没有第二个参数</p><pre><code>$('.btn2').click(function(){    alert($('img').attr('src'))    // 如果没有这个属性，那么就返回undefined，当然了自己设置的属性也可以获得})</code></pre><h2 id="2、属性移除-removeAttr"><a href="#2、属性移除-removeAttr" class="headerlink" title="2、属性移除 removeAttr()"></a>2、属性移除 removeAttr()</h2><pre><code>$('.btn3').click(function(){    // console.log($('img').removeAttr('src'))    // 注意这个返回值是$('img')本身    // var a = $('img').removeAttr('src')    // a.attr('bbb','hahaha')         //移除多个属性     $('img').removeAttr('src','aaa')    // $('img').removeAttr()    // 但是不加参数就没用了，不是全部删除})</code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>属性设置时，在jq1.6之后,对于checked,selected,disabled这类”boolean” 类型的值来说,不能使用attr方法,<strong>–只能使用prop方法–</strong>-</p><p>例：多选框</p><pre><code> &lt;input type="checkbox" id="box1"&gt;</code></pre><p>首先说明，多选框属性：checked在元素上面，就表示选中，没有写在元素上，则代表未选中<br>    // 这类属性，用原生js时：设置true，false也得到true或者false<br>    // $(‘#box2’).click(function(){<br>    //     document.getElementById(‘box1’).checked = true<br>    //     // 直接对属性进行控制<br>    // })</p><p>对于jq来说不能使用attr来控制boolean类型的属性</p><pre><code>$('#box2').click(function(){    console.log($('#box1').prop('checked'))  //得到undefined    // 当然了,如果选中就是true,未中就是flase    //  $('input').prop('checked',true)    // 注意赋值时,也需要使用prop })</code></pre><h1 id="二、元素位置控制与获取"><a href="#二、元素位置控制与获取" class="headerlink" title="二、元素位置控制与获取"></a>二、元素位置控制与获取</h1><h2 id="1、原始css方法"><a href="#1、原始css方法" class="headerlink" title="1、原始css方法"></a>1、原始css方法</h2><p>以div属性如下：</p><pre><code>    .div{        background-color: aqua;        width: 200px;        height: 200px;        padding: 20px;        border: 10px solid;        margin: 20px;    }</code></pre><p>当通过css属性进行获取时：</p><p>获取div宽高：之前可以用css方法 </p><pre><code>$('div').css('height')  --得到‘200px’// 需要直接得到数值时：height,width  --- 直接获取宽高，不包括内外边距，边框</code></pre><p>所以需要其他的方式</p><h2 id="2、属性获取宽高"><a href="#2、属性获取宽高" class="headerlink" title="2、属性获取宽高"></a>2、属性获取宽高</h2><h3 id="（1）只获取宽高height-width"><a href="#（1）只获取宽高height-width" class="headerlink" title="（1）只获取宽高height,width"></a>（1）只获取宽高height,width</h3><pre><code>    console.log($('div').width())   //200</code></pre><p>注意加了参数可以进行设置 — 加上数值参数,可以写300 “200”，’200px’，例如：</p><pre><code>$('button').click(function(){    $('div').width('300px')})</code></pre><h3 id="（2）包括内边距时-–-innerWidth-innerHeight"><a href="#（2）包括内边距时-–-innerWidth-innerHeight" class="headerlink" title="（2）包括内边距时 – innerWidth()/innerHeight()"></a>（2）包括内边距时 – innerWidth()/innerHeight()</h3><pre><code> console.log($('div').innerWidth())  //240 = 200+20+20</code></pre><h3 id="（3）内外边距与边框时-–-outerWidth-outerHeight"><a href="#（3）内外边距与边框时-–-outerWidth-outerHeight" class="headerlink" title="（3）内外边距与边框时  – outerWidth,outerHeight"></a>（3）内外边距与边框时  – outerWidth,outerHeight</h3><h4 id="当没有参数时或者参数为false-—-内边距与边框"><a href="#当没有参数时或者参数为false-—-内边距与边框" class="headerlink" title="当没有参数时或者参数为false — 内边距与边框"></a>当没有参数时或者参数为false — 内边距与边框</h4><pre><code>  console.log($('div').outerWidth()) // 260 = 240 +10+10</code></pre><h4 id="当有参数为true—-外内边距与边框"><a href="#当有参数为true—-外内边距与边框" class="headerlink" title="当有参数为true— 外内边距与边框"></a>当有参数为true— 外内边距与边框</h4><pre><code>console.log($('div').outerWidth(true))// 300 = 260 +20+20</code></pre><h3 id="（4）获取网页的可视区域宽高"><a href="#（4）获取网页的可视区域宽高" class="headerlink" title="（4）获取网页的可视区域宽高"></a>（4）获取网页的可视区域宽高</h3><pre><code> console.log($(window).width())    console.log($(window).height())</code></pre><h2 id="3、属性获取位置"><a href="#3、属性获取位置" class="headerlink" title="3、属性获取位置"></a>3、属性获取位置</h2><h3 id="（1）获取元素距离document的位置offset"><a href="#（1）获取元素距离document的位置offset" class="headerlink" title="（1）获取元素距离document的位置offset()"></a>（1）获取元素距离document的位置offset()</h3><pre><code>$('.1btn').click(function(){    // 1、offset()  --- 获得一个对象，包含了letf与top的值，代表了元素距离document的位置    console.log($('.son').offset())})</code></pre><h3 id="（2）获取元素距离有定位的父级元的位置position"><a href="#（2）获取元素距离有定位的父级元的位置position" class="headerlink" title="（2）获取元素距离有定位的父级元的位置position()"></a>（2）获取元素距离有定位的父级元的位置position()</h3><pre><code>$('.2btn').click(function(){    console.log($('.son').position())})</code></pre><h3 id="（3）获取滚动条的位置-scrollLeft-scrollTop"><a href="#（3）获取滚动条的位置-scrollLeft-scrollTop" class="headerlink" title="（3）获取滚动条的位置 scrollLeft(),scrollTop()"></a>（3）获取滚动条的位置 scrollLeft(),scrollTop()</h3><p>获取：</p><pre><code>// 两者分别表示为元素内容被卷曲出去的宽度与高度！！即 = 元素总高度 - 展示的高度$('.btn').click(function(){    console.log($('.img1').scrollLeft()+'高度'+$('.img1').scrollTop())})</code></pre><p>设置</p><pre><code>// 参数加上值，代表元素被卷出去的距离,此时“100px”不行了$('.img1').scrollLeft('100')// 设置页面被卷曲的宽高,获取：// 当然了还要求window宽高大于可视区才会生效$(window).scrollLeft('100')$(window).scrollTop('410')</code></pre><h1 id="三、事件问题"><a href="#三、事件问题" class="headerlink" title="三、事件问题"></a>三、事件问题</h1><h2 id="1、on的事件委托注册"><a href="#1、on的事件委托注册" class="headerlink" title="1、on的事件委托注册"></a>1、on的事件委托注册</h2><p>jq 1.7之后，jq使用了on统一了所有事件的注册方式</p><p>但是on是简单注册事件，不支持动态注册，指的是新建一个div之后，不会有这个事件</p><pre><code> $('.div1').on('click',function(){     console.log('绑定了事件') })</code></pre><p>on进行事件委托注册  — 通过父元素进行0n函数，目标元素在div内</p><pre><code>// 支持动态注册，即添加的div也有有这个事件// 并且支持多个委托：//  $('body').on('click','div,span',function(){})$('body').on('click','div',function(){    console.log('绑定了事件')})</code></pre><p><a href="https://www.cnblogs.com/yueyuecoding/articles/13431551.html">on的详解</a></p><h2 id="2、off事件解绑"><a href="#2、off事件解绑" class="headerlink" title="2、off事件解绑"></a>2、off事件解绑</h2><pre><code>没有参数时，表示解绑所有的事件：$('.div1').off()解绑匹配元素的所有的click事件：$('.div1').off('click')</code></pre><h3 id="事件手动触发trigger-‘事件’"><a href="#事件手动触发trigger-‘事件’" class="headerlink" title="事件手动触发trigger(‘事件’)"></a>事件手动触发trigger(‘事件’)</h3><p>作用：</p><ul><li>用代码的方式触发事件：</li><li>并且触发自定义事件</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><pre><code>$('.btn1').click(function(){    $(".div2").trigger('click')    $(".div2").trigger('mouseenter')})</code></pre><p>自定义事件：</p><pre><code> // 这种触发器可以让一些没法触发的事件运行，比如$('.div1').on('linge',function(){    alert('我居然被触发了11')})$('.div1').on('aaa',function(){    alert('我是自己定义的事件')})// 当然了，如果元素本身不具有这个事件也是无法触发的// 其他的就算是自己定义的事件，也可以通过trigger进行触发$('.btn2').click(function(){    $(".div2").trigger('linge')    $(".div2").trigger('aaa')})</code></pre><h2 id="3、事件对象"><a href="#3、事件对象" class="headerlink" title="3、事件对象"></a>3、事件对象</h2><h3 id="（1）事件对象意义"><a href="#（1）事件对象意义" class="headerlink" title="（1）事件对象意义"></a>（1）事件对象意义</h3><p>注册一个事件，系统帮我们生成一个对象，记录这个事件触发时的一些信息，</p><p>比如触发事件的坐标信息，或者比如有没有按住什么键</p><p>jq中通过函数中的参数e（写别的也可以）获取</p><p>jq的事件对象，是对原生js事件对象的一个封装，帮你处理好了–兼容性</p><pre><code>$('.div1').click(function(e){    console.log(e)})</code></pre><h3 id="2-事件对象中的常用的坐标"><a href="#2-事件对象中的常用的坐标" class="headerlink" title="(2)事件对象中的常用的坐标"></a>(2)事件对象中的常用的坐标</h3><pre><code>$('.div1').click(function(e){    console.log(e)    console.log('screnX :'+ e.screenX+ '  clientX  '+e.clientX)})</code></pre><p>和你的点击位置也是有关的</p><p>screenX和screenY    触发事件那个点！！！对应屏幕最左上角的值    —这个是全部页面（屏幕），连上面导航都算</p><p>clientX和clientY    触发事件那个点！！！离页面左上角的位置（忽视滚动条）</p><p>pageX和pageY    距离页面最顶部的左上角的位置（会计算滚动条的距离）</p><h3 id="3-阻止行为"><a href="#3-阻止行为" class="headerlink" title="(3)阻止行为"></a>(3)阻止行为</h3><pre><code>event.stopPropagation()    阻止事件冒泡行为</code></pre><p>进行阻止冒泡：</p><pre><code>$('.btn1').click(function(e){    alert('s')e.stopPropagation()  //阻止之后，button的父元素div就不会因此被触发了})</code></pre><p>阻止默认行为</p><pre><code>event.preventDefault()    阻止浏览器默认行为,b比如阻止a的点击跳转</code></pre><p>   $(‘a’).click(function(e){<br>        alert(“能到百度吗”)<br>      //  return false:既能阻止事件冒泡，又能阻止浏览器默认行为。<br>     // return false  //相当于上面的两部<br>    })</p><h3 id="（4）return-false既能阻止事件冒泡，又能阻止浏览器默认行为。"><a href="#（4）return-false既能阻止事件冒泡，又能阻止浏览器默认行为。" class="headerlink" title="（4）return false既能阻止事件冒泡，又能阻止浏览器默认行为。"></a>（4）return false既能阻止事件冒泡，又能阻止浏览器默认行为。</h3><ul><li><p>event.keyCode    按下的键盘代码</p></li><li><p>event.data    存储绑定事件时传递的附加数据</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>  $(document).on(‘keydown’,function(e){</p><pre><code>  // e.keyCode获取按3的是那个键  alert(e.keyCode)</code></pre><p>  })</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、属性控制&quot;&gt;&lt;a href=&quot;#一、属性控制&quot; class=&quot;headerlink&quot; title=&quot;一、属性控制&quot;&gt;&lt;/a&gt;一、属性控制&lt;/h1&gt;&lt;h2 id=&quot;1、属性的设置与获取&quot;&gt;&lt;a href=&quot;#1、属性的设置与获取&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="jQuery" scheme="https://useritem.github.io/categories/jQuery/"/>
    
    
  </entry>
  
  <entry>
    <title>jq3 -- 选择器，css类与动画</title>
    <link href="https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq3-%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%8Ccss%E7%B1%BB%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
    <id>https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq3-%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%8Ccss%E7%B1%BB%E4%B8%8E%E5%8A%A8%E7%94%BB/</id>
    <published>2021-05-25T12:48:43.000Z</published>
    <updated>2021-05-25T12:52:05.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、节点的操作"><a href="#一、节点的操作" class="headerlink" title="一、节点的操作"></a>一、节点的操作</h1><h2 id="1、节点的创建"><a href="#1、节点的创建" class="headerlink" title="1、节点的创建"></a>1、节点的创建</h2><h3 id="原生js的方法："><a href="#原生js的方法：" class="headerlink" title="原生js的方法："></a>原生js的方法：</h3><ul><li>document.write(‘’); 可以解析标签，但是可能覆盖掉页面</li><li>innerHTML =””   也会进行覆盖</li><li>document.createElement(); — 只存在于内存的标签，需要追加元素：appendChild</li></ul><h3 id="（1）html"><a href="#（1）html" class="headerlink" title="（1）html()"></a>（1）html()</h3><p>可以用于设置或者获取内容的</p><h4 id="1-1、当html不给参数表示获取类"><a href="#1-1、当html不给参数表示获取类" class="headerlink" title="1.1、当html不给参数表示获取类"></a>1.1、当html不给参数表示获取类</h4><pre><code> console.log($('div').html())</code></pre><h4 id="1-2、当html给参数，会进行标签解析和之前的“覆盖”"><a href="#1-2、当html给参数，会进行标签解析和之前的“覆盖”" class="headerlink" title="1.2、当html给参数，会进行标签解析和之前的“覆盖”"></a>1.2、当html给参数，会进行标签解析和之前的“覆盖”</h4><pre><code>$('div').html('我会&lt;h1&gt;覆盖&lt;/h1&gt;')</code></pre><h3 id="2"><a href="#2" class="headerlink" title="(2)$()"></a>(2)$()</h3><p>需要注意的是：</p><p>$()方法，只是<strong>在内容中设置</strong>，不会自动解析到页面上</p><p>如果后面需要进行添加的话，需要手动放置，比如append等（见后）</p><pre><code>let link = $('&lt;div&gt;&lt;12345/div&gt;')</code></pre><h2 id="2、节点操作："><a href="#2、节点操作：" class="headerlink" title="2、节点操作："></a>2、节点操作：</h2><h3 id="（1）节点的添加-A-某-B"><a href="#（1）节点的添加-A-某-B" class="headerlink" title="（1）节点的添加 A.某.B"></a>（1）节点的添加 A.某.B</h3><p>规律：</p><ul><li><p>1、对于新建元素 —  直接进行添加</p></li><li><p>2、把A本身已有的标签添加到ul中，代表<strong>剪切</strong>，之后进行添加</p></li><li><p>3、把其他地方的元素进行添加，那么相当于<strong>从其他地方剪切到该位置</strong></p></li></ul><h4 id="1、append方法（A-B建立完后为父子关系）"><a href="#1、append方法（A-B建立完后为父子关系）" class="headerlink" title="1、append方法（A,B建立完后为父子关系）"></a>1、append方法（A,B建立完后为父子关系）</h4><p>作为最后一个子元素进行添加，以上面三种规律为例：</p><p>1：新建元素—  作为最后一个子元素进行添加</p><pre><code>$('.btn1').click(function(){    var news = $('&lt;li&gt;xinjian&lt;/li&gt;')    $('.ul1').append(news)}</code></pre><p>2 把b本身已有的标签添加到ul中，代表剪切作为最后一个元素添加</p><pre><code>    var li3 = $('#li3')    $('.ul1').append(li3)</code></pre><p>3.吧ul2中的元素添加到ul1中去 — 直接将ul2中进行剪切后对齐添加</p><pre><code>    var li2 = $('#li2')    $('.ul1').append(li2)})</code></pre><h4 id="2、prepend方法（A-B建立完后为父子关系）"><a href="#2、prepend方法（A-B建立完后为父子关系）" class="headerlink" title="2、prepend方法（A,B建立完后为父子关系）"></a>2、prepend方法（A,B建立完后为父子关系）</h4><p>作为第一个元素添加,其他道理是一样的：</p><pre><code>$('.btn2').click(function(){    var news = $('&lt;li&gt;xinjian&lt;/li&gt;')    $('.ul1').prepend(news)})</code></pre><h4 id="3、before-（A-B-兄弟关系）"><a href="#3、before-（A-B-兄弟关系）" class="headerlink" title="3、before()（A B 兄弟关系）"></a>3、before()（A B 兄弟关系）</h4><p>before()  添加的方法—  添加到前面；</p><p>如果是 A.before（元素B）; //将元素B添加到元素A的前面，作为兄弟（之前作为的是子元素）</p><p>其他的道理一样，比如剪切什么的</p><pre><code>$('.btn3').click(function(){    var news = $('&lt;li&gt;xinjian&lt;/li&gt;')    $('.ul1').before(news)}）</code></pre><h4 id="4、after-（A-B-兄弟关系）"><a href="#4、after-（A-B-兄弟关系）" class="headerlink" title="4、after()（A B 兄弟关系）"></a>4、after()（A B 兄弟关系）</h4><p>after()  添加的方法—  添加到后面；</p><pre><code>    $('.btn4').click(function(){    var news = $('&lt;li&gt;xinjian&lt;/li&gt;')    $('.ul1').after(news)})</code></pre><h4 id="5、子元素-appendTo-父元素"><a href="#5、子元素-appendTo-父元素" class="headerlink" title="5、子元素.appendTo(父元素)"></a>5、子元素.appendTo(父元素)</h4><p>这是通过子元素点出来的！</p><p>把子元素作为父元素最后一个元素添加，—–和append效果一样，但是就是看谁给的方法</p><pre><code>$('.btn5').click(function(){    var news = $('&lt;li&gt;xinjian&lt;/li&gt;')    news.appendTo($('.ul1'))})</code></pre><div style="border-top: 5px solid #008c8c; margin:20px 0  "></div>  <h2 id="3、元素删除"><a href="#3、元素删除" class="headerlink" title="3、元素删除"></a>3、元素删除</h2><h3 id="1、元素完全清空-—-empty"><a href="#1、元素完全清空-—-empty" class="headerlink" title="1、元素完全清空 — empty()"></a>1、元素完全清空 — empty()</h3><p>实际上：htm(“”)方法也可以进行完全删除</p><pre><code>$('.ul1').html('') </code></pre><p>但是： 会清空里面了展示内容，但是实际还在，比如事件啥的，所以不安全，会造成内存泄漏</p><p>而对于empty()方法来说</p><p>他的实质是对每个元素实现了remove操作，并且对函数也进行了清除！，clearfix，但是此时内容中还有ul</p><p>所以完全清除推荐使用empty()</p><h3 id="2、移除一个元素-remove"><a href="#2、移除一个元素-remove" class="headerlink" title="2、移除一个元素 remove()"></a>2、移除一个元素 remove()</h3><pre><code>$('.btnn2').click(function(){    $('#li3').remove();  //自杀    // 但是注意remove之后，内容直接就不在了    $('#li2').parent().remove() //移除父元素})</code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>删除操作时：A.删除()，代表删除其本身全部，所以可以理解为<strong>自杀</strong></p><h2 id="4、节点克隆clone"><a href="#4、节点克隆clone" class="headerlink" title="4、节点克隆clone()"></a>4、节点克隆clone()</h2><p> jq中的克隆节点，仅仅存在于内存中，如果需要在页面中显示，需要追加到页面上！！</p><p>其次克隆方法的参数，无论是true还是false，都会clone到后代节点,（就是后面的子节点也会被clone上）</p><p>参数控制：方法是否克隆：</p><ul><li><p>true: 被克隆的事件也会被克隆上去</p></li><li><p>false：事件不会被克隆上去</p></li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4><pre><code>$('.clone').click(function(){    var clone  = $('.div1').clone(true)    // 把克隆节点进行追加    $('.div1').parent().append(clone)})</code></pre><h2 id="2、获取表单的方法val-："><a href="#2、获取表单的方法val-：" class="headerlink" title="2、获取表单的方法val()："></a>2、获取表单的方法val()：</h2><p>原生的js通过value值，来实现对input值的获取</p><p>jq通过  —-  val() 来获取表单元素的值</p><pre><code>&lt;input type="button" id="input1" value="naniu"&gt;&lt;input type="text" id="input2"&gt;    $('#input1').click(function(){    // 1、获取  val()方法不给参数，就是代表获取    alert($('#input2').val())    // 2、设置  对val给了参数，就表示了设置表单元素的值    $('#input2').val('hahaha')})</code></pre><p>原生js的value实现：</p><pre><code>    let inputs = document.getElementsByTagName('input')[2]    alert(inputs.value)    inputs.value = 'hehe' 也可以进行赋值    </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、节点的操作&quot;&gt;&lt;a href=&quot;#一、节点的操作&quot; class=&quot;headerlink&quot; title=&quot;一、节点的操作&quot;&gt;&lt;/a&gt;一、节点的操作&lt;/h1&gt;&lt;h2 id=&quot;1、节点的创建&quot;&gt;&lt;a href=&quot;#1、节点的创建&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="jQuery" scheme="https://useritem.github.io/categories/jQuery/"/>
    
    
  </entry>
  
  <entry>
    <title>jq2 -- class绑定与动画</title>
    <link href="https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq2-class%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
    <id>https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq2-class%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8A%A8%E7%94%BB/</id>
    <published>2021-05-25T12:48:06.000Z</published>
    <updated>2021-05-25T12:52:05.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、选择器"><a href="#一、选择器" class="headerlink" title="一、选择器"></a>一、选择器</h1><p>注意jq的基本选择器与层级选择器吗，与css的选择器类似，所以有些将不在赘述。</p><h2 id="1、基本选择器："><a href="#1、基本选择器：" class="headerlink" title="1、基本选择器："></a>1、基本选择器：</h2><h3 id="（1）并集选择器-—-逗号"><a href="#（1）并集选择器-—-逗号" class="headerlink" title="（1）并集选择器 —- 逗号"></a>（1）并集选择器 —- 逗号</h3><pre><code>$('#btn1','#btn2')</code></pre><h3 id="（2）交集选择器-—-空格"><a href="#（2）交集选择器-—-空格" class="headerlink" title="（2）交集选择器 —- 空格"></a>（2）交集选择器 —- 空格</h3><pre><code>$('.div span')</code></pre><h2 id="2、层级选择器："><a href="#2、层级选择器：" class="headerlink" title="2、层级选择器："></a>2、层级选择器：</h2><h3 id="（1）子代选择器-—-gt"><a href="#（1）子代选择器-—-gt" class="headerlink" title="（1）子代选择器 — >"></a>（1）子代选择器 — &gt;</h3><pre><code>  $('.div1&gt;span')</code></pre><h3 id="（1）后代选择器-—-gt-空格"><a href="#（1）后代选择器-—-gt-空格" class="headerlink" title="（1）后代选择器 — > 空格"></a>（1）后代选择器 — &gt; 空格</h3><pre><code>$('div1 span')</code></pre><p>底下的全部span元素，而不是全部的子元素</p><h2 id="3、过滤选择器"><a href="#3、过滤选择器" class="headerlink" title="3、过滤选择器"></a>3、过滤选择器</h2><p>首先注意，这类的选择器后面都带有”:”<strong>冒号</strong></p><pre><code>:eq(index)   ---找到类数组中索引为index的元素    $('ul:eq(3)'):odd         ---选择类数组中的》奇数元素         $('ul:odd')   ul元素中的奇数元素:even        ----             偶数元素         $('ul:even')</code></pre><h2 id="4、筛选选择器"><a href="#4、筛选选择器" class="headerlink" title="4、筛选选择器"></a>4、筛选选择器</h2><p>筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是<strong>方法</strong>。</p><p>主要选择器后面会加上<strong>选择</strong></p><p><a href="https://imgtu.com/i/g0XRhD"><img src="https://z3.ax1x.com/2021/05/13/g0XRhD.png" alt="g0XRhD.png"></a></p><h1 id="二、对css类的操作"><a href="#二、对css类的操作" class="headerlink" title="二、对css类的操作"></a>二、对css类的操作</h1><h2 id="1、添加一个类：addClass-方法"><a href="#1、添加一个类：addClass-方法" class="headerlink" title="1、添加一个类：addClass()方法"></a>1、添加一个类：addClass()方法</h2><pre><code> $('#div1').addClass('div2')</code></pre><p>当然了也可以直接添加多个class类：</p><pre><code>addClass('div2 div3')</code></pre><p>注意这里直接是添加css，所以不用加**”.”**</p><h2 id="2、类的移除removeClass-类名"><a href="#2、类的移除removeClass-类名" class="headerlink" title="2、类的移除removeClass(类名)"></a>2、类的移除removeClass(类名)</h2><pre><code>$('#div1').removeClass('div2')</code></pre><p>注意当没有这个div2的类时，系统也不会报错</p><p>当然了当没有参数时，则<strong>会删除全部的class类</strong></p><pre><code>$('#div1').removeClass()</code></pre><h2 id="3、判断是否存在这个类-hasClass-类名"><a href="#3、判断是否存在这个类-hasClass-类名" class="headerlink" title="3、判断是否存在这个类 hasClass(类名)"></a>3、判断是否存在这个类 hasClass(类名)</h2><pre><code>$('#div1').hasClass('div2')</code></pre><p>后面会返回一个boolean值</p><h2 id="4、对某个类的切换：toggle-‘类名’"><a href="#4、对某个类的切换：toggle-‘类名’" class="headerlink" title="4、对某个类的切换：toggle(‘类名’)"></a>4、对某个类的切换：toggle(‘类名’)</h2><pre><code>$('#div1').toggleClass('div2')</code></pre><p>如果元素有某个类，就进行移除，如果没有就进行添加</p><h1 id="三、动画"><a href="#三、动画" class="headerlink" title="三、动画"></a>三、动画</h1><h2 id="1、jq的基本动画"><a href="#1、jq的基本动画" class="headerlink" title="1、jq的基本动画"></a>1、jq的基本动画</h2><p>注意基本动画一般都有两个参数：</p><ul><li><p>一个参数表示执行时间，数字的话表示毫秒数，字符串可以是代表时长的字符串 fast(200ms) normal(400ms) slow(600ms)<br>当字符串写错了，就相当于写了一个normal</p></li><li><p>另一个表示事件执行完毕之后的函数</p><h3 id="（1）显示与隐藏动画"><a href="#（1）显示与隐藏动画" class="headerlink" title="（1）显示与隐藏动画"></a>（1）显示与隐藏动画</h3></li></ul><h4 id="1、显示动画show"><a href="#1、显示动画show" class="headerlink" title="1、显示动画show()"></a>1、显示动画show()</h4><pre><code>$('#div1').show(2000,function(){        // 当然了这两个参数也可以不写        console.log('ok')    })</code></pre><h4 id="2、隐藏动画hide"><a href="#2、隐藏动画hide" class="headerlink" title="2、隐藏动画hide"></a>2、隐藏动画hide</h4><pre><code>$('#div1').hide(3000)</code></pre><h4 id="3、切换动画toggle-–隐藏变显示，显示变隐藏"><a href="#3、切换动画toggle-–隐藏变显示，显示变隐藏" class="headerlink" title="3、切换动画toggle –隐藏变显示，显示变隐藏"></a>3、切换动画toggle –隐藏变显示，显示变隐藏</h4><pre><code> $('#div1').toggle(1000)</code></pre><div style="border-top: 5px solid #008c8c; margin:20px 0  "></div><h3 id="（2）滑动动画"><a href="#（2）滑动动画" class="headerlink" title="（2）滑动动画"></a>（2）滑动动画</h3><h4 id="1、划入动画slideDown"><a href="#1、划入动画slideDown" class="headerlink" title="1、划入动画slideDown"></a>1、划入动画slideDown</h4><p>– 不加参数也有动画效果,—默认参数normal（400ms）</p><pre><code> $('.btn4').click(function(){    $('#div2').slideDown(2000)  })</code></pre><h4 id="2、划出动画slideUp"><a href="#2、划出动画slideUp" class="headerlink" title="2、划出动画slideUp"></a>2、划出动画slideUp</h4><pre><code>$('#div2').slideUp(2000)  </code></pre><h4 id="3、slideToggle"><a href="#3、slideToggle" class="headerlink" title="3、slideToggle"></a>3、slideToggle</h4><pre><code>$('#div2').slideToggle(6000)</code></pre><div style="border-top: 5px solid #008c8c; margin:20px 0  "></div>  <h3 id="（3）淡入淡出动画"><a href="#（3）淡入淡出动画" class="headerlink" title="（3）淡入淡出动画"></a>（3）淡入淡出动画</h3><h4 id="1、淡入动画fadeIn-—-不给参数相当于给了默认时长normal、"><a href="#1、淡入动画fadeIn-—-不给参数相当于给了默认时长normal、" class="headerlink" title="1、淡入动画fadeIn  — 不给参数相当于给了默认时长normal、"></a>1、淡入动画fadeIn  — 不给参数相当于给了默认时长normal、</h4><pre><code>$('.btn1').click(function(){    $('.div1').fadeIn(2000)})</code></pre><h4 id="2、淡出fadeOut"><a href="#2、淡出fadeOut" class="headerlink" title="2、淡出fadeOut"></a>2、淡出fadeOut</h4><pre><code>$('.div1').fadeOut(2000)</code></pre><h4 id="3、切换fadeToggle"><a href="#3、切换fadeToggle" class="headerlink" title="3、切换fadeToggle"></a>3、切换fadeToggle</h4><pre><code>$('.div1').fadeToggle(2000)</code></pre><h2 id="2、jq的自定义动画animate"><a href="#2、jq的自定义动画animate" class="headerlink" title="2、jq的自定义动画animate()"></a>2、jq的自定义动画animate()</h2><h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul><li>参数1  必选的对象，表示需要做动画的属性</li><li>参数2，可选的，表示时长</li><li>参数3，可选的，easing代表缓动的还是匀速的 linear(匀速) swing（加速） ，默认不写为swing</li><li>参数4，动画执行完毕后的回调函数</li></ul><p>动画设置：</p><pre><code> $('.btn4').click(function(){    console.log('asd')    $('.div2').animate({        // 注意动left需要设置position为absolute        left:800,        width:'200px',        height:200,        opacity:0.5,        backgroundColor:'red' //这是无效的    },3000,'swing',function(){        // 由于这里是一个函数，可以让div干任何事情，所以可以在这里再次执行动画，所以可以实现连续的动画        $('.div2').animate({            left:400,            width:300,            height:300,            top:300,            'background-color':'red'        },3000,'swing',function(){            $('.div2').css("background-color", "red")        })    })})</code></pre><p>注意回调函数的特殊用法,可以通过回调函数,实现连续动画的实现</p><h2 id="3、动画停止stop（）"><a href="#3、动画停止stop（）" class="headerlink" title="3、动画停止stop（）"></a>3、动画停止stop（）</h2><h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul><li>第一个表示是否 清除队列</li><li>第二个表示是否 跳转到最终结果(false表示停止到当前状态)</li></ul><p>实例：</p><pre><code>//动画开启：$('.btn1').click(function(){    $('div').slideDown(3000).slideUp(3000)})//动画停止$('.btn2').click(function(){    $('div').stop(false,false)    // 第一个为false表示停止这一部分，即理解为停止slidedown部分})</code></pre><p>当没有参数时，则表示全为false：</p><pre><code>$('div').stop(false,false)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、选择器&quot;&gt;&lt;a href=&quot;#一、选择器&quot; class=&quot;headerlink&quot; title=&quot;一、选择器&quot;&gt;&lt;/a&gt;一、选择器&lt;/h1&gt;&lt;p&gt;注意jq的基本选择器与层级选择器吗，与css的选择器类似，所以有些将不在赘述。&lt;/p&gt;
&lt;h2 id=&quot;1、基本选择</summary>
      
    
    
    
    <category term="jQuery" scheme="https://useritem.github.io/categories/jQuery/"/>
    
    
  </entry>
  
  <entry>
    <title>jq1 -- 走进jquery</title>
    <link href="https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq1-%E8%B5%B0%E8%BF%9Bjquery/"/>
    <id>https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq1-%E8%B5%B0%E8%BF%9Bjquery/</id>
    <published>2021-05-25T12:47:22.000Z</published>
    <updated>2021-05-25T12:52:05.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言对比"><a href="#一、前言对比" class="headerlink" title="一、前言对比"></a>一、前言对比</h1><h2 id="1、例子：实现点击为元素添加文本与边框"><a href="#1、例子：实现点击为元素添加文本与边框" class="headerlink" title="1、例子：实现点击为元素添加文本与边框"></a>1、例子：实现点击为元素添加文本与边框</h2><p>html：</p><pre><code>&lt;button class="btn1"&gt;添加边框&lt;/button&gt;&lt;button class="btn2"&gt;添加文本&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;</code></pre><p>js实现：</p><pre><code>let btn = document.getElementsByClassName('btn1')[0]let btn2 = document.getElementsByClassName('btn2')[0]let div = document.getElementsByTagName('div')btn.onclick = function(){    for(let i = 0;i&lt;div.length;i++){        div[i].style.border = '3px solid red'    }}btn2.onclick = function(){    for(let i = 0;i&lt;div.length;i++){        div[i].innerHTML = '我是添加的元素'+i    }}</code></pre><p>jq实现:</p><pre><code>&lt;script src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt;let btn = $('.btn1')// 只能全部,上面的$('.btn1:eq(0)').click(function (){    $('div').css('border','3px solid red')})$('#btn2').click(function(){    $('div').text('我是设置的文本')})</code></pre><h2 id="2、差异："><a href="#2、差异：" class="headerlink" title="2、差异："></a>2、差异：</h2><h3 id="js缺点："><a href="#js缺点：" class="headerlink" title="js缺点："></a>js缺点：</h3><ul><li>   1、js的api太难记</li><li>   2、出现代码冗余</li><li>3、有些属性或者方法会有兼容问题</li><li>4、注意入口文件：window.onload只能写一个，（相当于为其添加属性）</li><li>5、原生js代码容错率较低，前面错误后面报废</li></ul><h3 id="jq优点："><a href="#jq优点：" class="headerlink" title="jq优点："></a>jq优点：</h3><ul><li>1、jq可以设置多个入口函数</li><li>2、jq会解决浏览器的兼容问题</li><li>3、jq前面的代码出现问题，不会影响后面的代码</li></ul><h1 id="二、jq简述"><a href="#二、jq简述" class="headerlink" title="二、jq简述"></a>二、jq简述</h1><h2 id="1、jq的链式编程"><a href="#1、jq的链式编程" class="headerlink" title="1、jq的链式编程"></a>1、jq的链式编程</h2><p>例子：</p><pre><code>$(document).ready(function(){   $('div').width(100).height(100).css('backgroundColor','red').text('haha')})</code></pre><h2 id="2、jq的版本问题："><a href="#2、jq的版本问题：" class="headerlink" title="2、jq的版本问题："></a>2、jq的版本问题：</h2><p>下载地址：  <a href="https://code.jquery.com/jquery/#jquery-all-1.x">https://code.jquery.com/jquery/#jquery-all-1.x</a></p><p>各个版本的特点</p><ul><li>1.x  –支持老浏览器比如ie678， 停止更新</li><li>2.x  –不支持老浏览器          停止更新</li><li>3.x  —不支持                还在更新</li></ul><p>当然了，也可以直接src引入：</p><pre><code>&lt;script src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt;</code></pre><h2 id="3、jq的入口函数"><a href="#3、jq的入口函数" class="headerlink" title="3、jq的入口函数"></a>3、jq的入口函数</h2><pre><code>$(function(){    alert('jq') })</code></pre><p>或者</p><pre><code>$(document).ready(function(){});</code></pre><h2 id="4、-的用法"><a href="#4、-的用法" class="headerlink" title="4、$的用法"></a>4、$的用法</h2><h3 id="（1）-的由来："><a href="#（1）-的由来：" class="headerlink" title="（1）$的由来："></a>（1）$的由来：</h3><pre><code>(function(){window.jQuery = window.$ = jQuery //将两者赋值为一个jQuery函数})</code></pre><p>所以说$的实际是一个函数，</p><pre><code> console.log(Object.prototype.toString.call('$'))// [object Function]这代表了jquery与$是等价的:window.jQuery = window.$   //true</code></pre><h3 id="（2）参数"><a href="#（2）参数" class="headerlink" title="（2）参数"></a>（2）参数</h3><h4 id="a-当参数为字符串—-代表为选择器，或者再创建一个标签"><a href="#a-当参数为字符串—-代表为选择器，或者再创建一个标签" class="headerlink" title="a.当参数为字符串—-代表为选择器，或者再创建一个标签"></a>a.当参数为字符串—-代表为选择器，或者再创建一个标签</h4><pre><code>$('one')$('&lt;div&gt;lalala&lt;/div&gt;')</code></pre><h4 id="b-当参数为匿名函数-—入口函数"><a href="#b-当参数为匿名函数-—入口函数" class="headerlink" title="b.当参数为匿名函数  —入口函数"></a>b.当参数为匿名函数  —入口函数</h4><pre><code>$(function(){})</code></pre><h4 id="c-当参数为一个dom对象-那么会转化为一个jQuery对象"><a href="#c-当参数为一个dom对象-那么会转化为一个jQuery对象" class="headerlink" title="c.当参数为一个dom对象,那么会转化为一个jQuery对象"></a>c.当参数为一个dom对象,那么会转化为一个jQuery对象</h4><pre><code>let div = document.getElementById('text')$(div)</code></pre><h2 id="5、dom对象与jq对象的转换"><a href="#5、dom对象与jq对象的转换" class="headerlink" title="5、dom对象与jq对象的转换"></a>5、dom对象与jq对象的转换</h2><p>例：</p><pre><code>let div = document.getElementById('text')</code></pre><p> 这个div表示dom对象，他只能使用dom方法，不能使用jq方法：</p><pre><code> 无效：div.css('backgroundColor','green')</code></pre><p>当然了jq对象也只能使用jq的方法以及属性</p><pre><code>var $div = $('.gus')$div.style.backgroundColor = 'red'</code></pre><h3 id="（1）dom对象与jq对象的转换：加"><a href="#（1）dom对象与jq对象的转换：加" class="headerlink" title="（1）dom对象与jq对象的转换：加$"></a>（1）dom对象与jq对象的转换：加$</h3><pre><code>$(div).width('100px').height('100px').css('backgroundColor','red')// 成功</code></pre><h3 id="2-jq—-gt-dom转换"><a href="#2-jq—-gt-dom转换" class="headerlink" title="(2) jq—>dom转换"></a>(2) jq—&gt;dom转换</h3><h4 id="1、通过下标取出来"><a href="#1、通过下标取出来" class="headerlink" title="1、通过下标取出来"></a>1、通过下标取出来</h4><pre><code>var div1  = $div[0]div1.style.backgroundColor = 'blue' //成功</code></pre><h4 id="2、使用get方法"><a href="#2、使用get方法" class="headerlink" title="2、使用get方法"></a>2、使用get方法</h4><pre><code>var div2 = $div.get(1)div2.style.backgroundColor = 'green' //成功</code></pre><h2 id="6、text（）方法："><a href="#6、text（）方法：" class="headerlink" title="6、text（）方法："></a>6、text（）方法：</h2><p> 获取文本元素：text（）方法：</p><pre><code> 如果方法里面没有参数，表示对元素文本的获取 如果有内容会对 之前内容进行覆盖，且注意里面的内容，不会进行解析</code></pre><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p><strong>jq对象是一个伪数组，jq对象实际是一个dom对象的包装集</strong></p><p>要求：取div中的第二个元素进行操作时，使用: <span style="color: red;font-size: 28px;">eq(n)</span></p><p>选择器后面介绍</p><pre><code>$('div:eq(1)').text('asdas')</code></pre><p>其中的 $(“.demo:eq(n)”)就是获得同样class的第N个元素。</p><p>当然了对于其他的选择器也可以这样取一个元素出来，但是<strong>不能以数组的中括号形式</strong>(因为是伪数组)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言对比&quot;&gt;&lt;a href=&quot;#一、前言对比&quot; class=&quot;headerlink&quot; title=&quot;一、前言对比&quot;&gt;&lt;/a&gt;一、前言对比&lt;/h1&gt;&lt;h2 id=&quot;1、例子：实现点击为元素添加文本与边框&quot;&gt;&lt;a href=&quot;#1、例子：实现点击为元素添加文本与边</summary>
      
    
    
    
    <category term="jQuery" scheme="https://useritem.github.io/categories/jQuery/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack下载问题</title>
    <link href="https://useritem.github.io/2021/05/10/%E9%9B%B6%E6%95%A3%E9%97%AE%E9%A2%98/webpack%E4%B8%8B%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    <id>https://useritem.github.io/2021/05/10/%E9%9B%B6%E6%95%A3%E9%97%AE%E9%A2%98/webpack%E4%B8%8B%E8%BD%BD%E9%97%AE%E9%A2%98/</id>
    <published>2021-05-10T14:37:32.000Z</published>
    <updated>2021-05-10T14:37:55.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack下载问题"><a href="#webpack下载问题" class="headerlink" title="webpack下载问题"></a>webpack下载问题</h1><p>在webpack下载时，会出现本来下载成功，结果出现</p><p><a href="https://imgtu.com/i/cRK4q1"><img src="https://z3.ax1x.com/2021/04/15/cRK4q1.md.png" alt="cRK4q1.md.png"></a></p><p>或者干脆直接找不到webpack，此时</p><p>应该直接用管理员权限进行下载！！！</p><p><a href="https://imgtu.com/i/cRKqRe"><img src="https://z3.ax1x.com/2021/04/15/cRKqRe.png" alt="cRKqRe.png"></a></p><p>之后如果先本地下载的话，可以进行cd调转</p><h2 id="此时我的电脑vscode又出来问题：权限不足"><a href="#此时我的电脑vscode又出来问题：权限不足" class="headerlink" title="此时我的电脑vscode又出来问题：权限不足"></a>此时我的电脑vscode又出来问题：权限不足</h2><p>直接进行如下操作：右键进行属性修改：</p><h3 id="一：以管理员运行"><a href="#一：以管理员运行" class="headerlink" title="一：以管理员运行"></a>一：以管理员运行</h3><p><a href="https://imgtu.com/i/cRMlz4"><img src="https://z3.ax1x.com/2021/04/15/cRMlz4.png" alt="cRMlz4.png"></a></p><h3 id="二、更改所有用户设置"><a href="#二、更改所有用户设置" class="headerlink" title="二、更改所有用户设置"></a>二、更改所有用户设置</h3><p><a href="https://imgtu.com/i/cRM6eI"><img src="https://z3.ax1x.com/2021/04/15/cRM6eI.png" alt="cRM6eI.png"></a></p><p>之后才算真正解决了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;webpack下载问题&quot;&gt;&lt;a href=&quot;#webpack下载问题&quot; class=&quot;headerlink&quot; title=&quot;webpack下载问题&quot;&gt;&lt;/a&gt;webpack下载问题&lt;/h1&gt;&lt;p&gt;在webpack下载时，会出现本来下载成功，结果出现&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="其他问题" scheme="https://useritem.github.io/categories/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>flex与grid布局</title>
    <link href="https://useritem.github.io/2021/05/10/%E9%9B%B6%E6%95%A3%E9%97%AE%E9%A2%98/flex%E4%B8%8Egrid%E5%B8%83%E5%B1%80/"/>
    <id>https://useritem.github.io/2021/05/10/%E9%9B%B6%E6%95%A3%E9%97%AE%E9%A2%98/flex%E4%B8%8Egrid%E5%B8%83%E5%B1%80/</id>
    <published>2021-05-10T14:36:20.000Z</published>
    <updated>2021-05-10T14:37:55.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、flex布局"><a href="#一、flex布局" class="headerlink" title="一、flex布局"></a>一、flex布局</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Flex（Flexible Box）布局为弹性布局，且<strong>任何容器都可以</strong>使用其布局</p><p><strong>注意针对的是轴线的位置，可以理解为一维布局</strong></p>  <div style="color: red; font-size: 20px;">而且注意这是对盒子的要求，需要放在外面！！</div><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</p><h2 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h2><h3 id="写法："><a href="#写法：" class="headerlink" title="写法："></a>写法：</h3><pre><code>.box{  display: -webkit-flex; /* Safari */Webkit内核的浏览器，必须加上-webkit前缀。  display: flex;}</code></pre><h3 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h3><p><a href="https://imgtu.com/i/gNdocD"><img src="https://z3.ax1x.com/2021/05/10/gNdocD.png" alt="gNdocD.png"></a></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h2 id="3、属性"><a href="#3、属性" class="headerlink" title="3、属性"></a>3、属性</h2><h3 id="（1）对于父元素容器的属性限定："><a href="#（1）对于父元素容器的属性限定：" class="headerlink" title="（1）对于父元素容器的属性限定："></a>（1）对于父元素容器的属性限定：</h3><p>1、flex-direction（主轴排列方向，及里面子元素的排序，默认为row横向）</p><p>2、flex-wrap    （横向排列时的换行情况，，默认nowrap不换行）</p><p>3、flex-flow （为前两项的简写总：）</p><pre><code>  flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;</code></pre><p>4、justify-content（主轴的对齐方式，默认：flex-start左侧对齐）</p> <div style="background-color: silver;"><h3>特别注意的是：</h3><div style="margin-top: 15px;">一旦前面设为纵向排列： flex-direction:column; **主轴方向变化为纵向**</div><div style="margin-top: 15px;">那么由于当盒子的大小没有具体数字的时候，这是高度和子元素有关，</div><div style="margin-top: 15px;">所以此时的justify-content设置之后外观不变！！！</div><div style="margin-top: 15px;">当然了如果设置了具体的px高度值，那么会生效的</div></div><p>5、align-items（与交叉轴（cross axis）对齐的方式：）</p><p><strong>这个对齐可以理解为与上面的justify-content相反的对齐，justify-content对齐是与主轴的方向相同，而align-item确实相反</strong></p><p>6、align-content（定义了多根轴线的对齐方式，通俗来说就是</p><p>如果flex-direction为row时，有多行，那么就有几个轴线）</p><p><strong>只有一根轴线不起作用</strong></p><div style="border-top: solid #ACC0D8 3px;margin:30px"></div><h3 id="（2）对于子元素的属性限定"><a href="#（2）对于子元素的属性限定" class="headerlink" title="（2）对于子元素的属性限定"></a>（2）对于子元素的属性限定</h3><p>1、order：定义项目元素的排列顺序。<strong>数值越小越靠前</strong>，可以理解为z-index的反义。</p><p>2、flex-grow （定义项目的放大比例，默认为0）</p><p>注意这个是填满，有剩余空间下的，如果只有一个元素有flex-grow值，那么就对一个限制，如果有多个，就</p><p><strong>通过flex-grow的值进行平分</strong></p><p>3、flex-shrink：项目缩小比例，<strong>如果空间不足</strong>会进行缩小</p><p>4、flex-basis：项目占据的主轴空间</p><p>5、flex：是flex-grow, flex-shrink 和 flex-basis的简写</p><p>6、align-self：允许单个项目有与其他项目不一样的对齐方式，可<strong>覆盖align-items</strong>属性</p><h3 id="具体解释详见："><a href="#具体解释详见：" class="headerlink" title="具体解释详见："></a>具体解释详见：</h3><p><a href="https://www.runoob.com/w3cnote/flex-grammar.html">Flex语法布局</a></p><h1 id="二、Grid-网格布局"><a href="#二、Grid-网格布局" class="headerlink" title="二、Grid 网格布局"></a>二、Grid 网格布局</h1><h2 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>主要是将容器进行划分为行与列，通过<strong>单元格</strong>进行划分，可以理解为二维</p><h2 id="2、书写："><a href="#2、书写：" class="headerlink" title="2、书写："></a>2、书写：</h2><pre><code>div {  display: grid;/*默认为块级，当然了也可以写为行内元素：*//* display: inline-grid;*/}</code></pre><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</p><h2 id="3、父容器属性"><a href="#3、父容器属性" class="headerlink" title="3、父容器属性"></a>3、父容器属性</h2><h3 id="（1）grid-template-columns-属性，grid-template-rows-属性"><a href="#（1）grid-template-columns-属性，grid-template-rows-属性" class="headerlink" title="（1）grid-template-columns 属性，grid-template-rows 属性"></a>（1）grid-template-columns 属性，grid-template-rows 属性</h3><p>分别定义了宽高：</p><pre><code>.container {  display: grid;  grid-template-columns: 100px 100px 100px;（横）  grid-template-rows: 100px 100px 100px;（也可以写为百分比）}</code></pre><p>上面代码指定了一个三行三列的网格，列宽和行高都是100px。</p><p><a href="https://imgtu.com/i/gNgpvt"><img src="https://z3.ax1x.com/2021/05/10/gNgpvt.png" alt="gNgpvt.png"></a></p><p>grid-template-columns对于两栏布局十分简单：</p><pre><code>.wrapper {  display: grid;  grid-template-columns: 70% 30%;左边栏设为70%，右边栏设为30%。}</code></pre><p>当然了三栏也可以</p><p><strong>注意当百分比之和超过100%，会有溢出</strong></p><h3 id="（2）repeat—简化重复值"><a href="#（2）repeat—简化重复值" class="headerlink" title="（2）repeat—简化重复值"></a>（2）repeat—简化重复值</h3><p>上面的例子：</p><pre><code>.container {  display: grid;  grid-template-columns: repeat(3, 33.33%);（第一个表示重复次数，第二个表示重复的值）  grid-template-rows: repeat(3, 33.33%);}</code></pre><h3 id="（3）auto-fill—-表示自动填充"><a href="#（3）auto-fill—-表示自动填充" class="headerlink" title="（3）auto-fill—-表示自动填充"></a>（3）auto-fill—-表示自动填充</h3><pre><code>grid-template-columns: repeat(auto-fill, 100px);</code></pre><p>横向自动填充</p><h3 id="（4）fr-关键字-—-表示比例关系"><a href="#（4）fr-关键字-—-表示比例关系" class="headerlink" title="（4）fr 关键字 — 表示比例关系"></a>（4）fr 关键字 — 表示比例关系</h3><pre><code>grid-template-columns: 1fr 2fr; //表示后面是前一个两倍</code></pre><p>当然了，也可以与绝对长度进行<strong>综合使用：</strong></p><pre><code>grid-template-columns: 150px 1fr 2fr;第一列的宽度为150像素，第二列的宽度是第三列的一半。</code></pre><h3 id="（5）间距"><a href="#（5）间距" class="headerlink" title="（5）间距"></a>（5）间距</h3><p>grid-row-gap 属性 — 行与行的间隔（行间距）</p><p>grid-column-gap 属性 —— 属性设置列与列的间隔（列间距）</p><p>grid-gap 属性 — 上面的合并简洁形式：</p><pre><code>grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;grid-gap: 20px 20px;</code></pre><p>注意这个前面的grid也可以省略</p><h3 id="（6）grid-template-areas区域划分："><a href="#（6）grid-template-areas区域划分：" class="headerlink" title="（6）grid-template-areas区域划分："></a>（6）grid-template-areas区域划分：</h3><pre><code>grid-template-areas: 'a . c'                     'd . f'                     'g . i';</code></pre><p>这个“.”表示区域不用利用</p><h3 id="（7）grid-auto-flow-—放置顺序"><a href="#（7）grid-auto-flow-—放置顺序" class="headerlink" title="（7）grid-auto-flow —放置顺序"></a>（7）grid-auto-flow —放置顺序</h3><pre><code>grid-auto-flow: column; </code></pre><p>这个表示<strong>先列后行</strong>，默认值为row，表示先行后列</p><p>column的结果：</p><p><a href="https://imgtu.com/i/gNhyv9"><img src="https://z3.ax1x.com/2021/05/10/gNhyv9.png" alt="gNhyv9.png"></a></p><p>后面也可以加上dense表示<strong>尽量紧密填满</strong></p><pre><code>grid-auto-flow: row dense;</code></pre><h3 id="（8）单元格位置确定"><a href="#（8）单元格位置确定" class="headerlink" title="（8）单元格位置确定"></a>（8）单元格位置确定</h3><p>justify-items 属性—设置单元格内容的水平位置（左中右）</p><p>align-items 属性 —- 单元格内容的垂直位置（上中下）</p><p>place-items 属性 —合并简写形式</p><pre><code>place-items: start end;</code></pre><h3 id="（9）整个内容位置确定"><a href="#（9）整个内容位置确定" class="headerlink" title="（9）整个内容位置确定"></a>（9）整个内容位置确定</h3><p>justify-content 属性   </p><p>align-content 属性，</p><p>place-content 属性</p><p>其位置同于items单元格位置，注意stretch值</p><ul><li>项目大小没有指定时，拉伸占据整个网格容器。</li></ul><h3 id="（10）当元素数超过开始设定的个数："><a href="#（10）当元素数超过开始设定的个数：" class="headerlink" title="（10）当元素数超过开始设定的个数："></a>（10）当元素数超过开始设定的个数：</h3><ul><li><p>grid-auto-columns 属性，</p></li><li><p>grid-auto-rows 属性</p></li></ul><p>按照这两个属性动生成区域，以便放置项目。</p><h2 id="4、子项目属性"><a href="#4、子项目属性" class="headerlink" title="4、子项目属性"></a>4、子项目属性</h2><h3 id="（1）项目位置确定-—根据网格线"><a href="#（1）项目位置确定-—根据网格线" class="headerlink" title="（1）项目位置确定 —根据网格线"></a>（1）项目位置确定 —根据网格线</h3><ul><li><p>grid-column-start属性：左边框所在的垂直网格线</p></li><li><p>grid-column-end属性：右边框所在的垂直网格线</p></li><li><p>grid-row-start属性：上边框所在的水平网格线</p></li><li><p>grid-row-end属性：下边框所在的水平网格线</p><p>  .item-1 {</p><pre><code>grid-column-start: 2;grid-column-end: 4;</code></pre><p>  }</p></li></ul><p><a href="https://imgtu.com/i/gN5KfS"><img src="https://z3.ax1x.com/2021/05/10/gN5KfS.png" alt="gN5KfS.png"></a></p><p>从第二根线到第四根线，</p><h4 id="注意：线的确定"><a href="#注意：线的确定" class="headerlink" title="注意：线的确定"></a>注意：线的确定</h4><p>这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p><pre><code>.item-1 {  grid-column-start: span 2;}</code></pre><p>表示从左到右跨过了多少网格</p><p>grid-column 属性 — grid-column-start和grid-column-end的合并简写形式</p><p>grid-row 属性 — grid-row-start属性和grid-row-end的合并简写形式。</p><pre><code>.item-1 {  background: #b03532;  grid-column: 1 / 3;  grid-row: 1 / 3;}/* 等同于 */.item-1 {  background: #b03532;  grid-column: 1 / span 2;  grid-row: 1 / span 2;}</code></pre><p><a href="https://imgtu.com/i/gNIJjH"><img src="https://z3.ax1x.com/2021/05/10/gNIJjH.png" alt="gNIJjH.png"></a></p><h3 id="（2）指定项目的区域"><a href="#（2）指定项目的区域" class="headerlink" title="（2）指定项目的区域"></a>（2）指定项目的区域</h3><p>grid-area属性指定项目放在哪一个区域。</p><pre><code>.item-1 {  grid-area: e;}</code></pre><p>与上面的grid-template-areas区域划分相对应</p><h3 id="（3）项目的单独位置"><a href="#（3）项目的单独位置" class="headerlink" title="（3）项目的单独位置"></a>（3）项目的单独位置</h3><p>和flex布局一样，一旦写了项目的单独布局，之前的就不会生效</p><p>justify-self —- 设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。</p><p>align-self 属性</p><p>place-self 属性</p><pre><code>place-self: center center;</code></pre><p>详细请见：</p><p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">grid语法布局</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、flex布局&quot;&gt;&lt;a href=&quot;#一、flex布局&quot; class=&quot;headerlink&quot; title=&quot;一、flex布局&quot;&gt;&lt;/a&gt;一、flex布局&lt;/h1&gt;&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="其他问题" scheme="https://useritem.github.io/categories/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack详细配置</title>
    <link href="https://useritem.github.io/2021/04/26/webpack%E5%AD%A6%E4%B9%A0/webpack%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/"/>
    <id>https://useritem.github.io/2021/04/26/webpack%E5%AD%A6%E4%B9%A0/webpack%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/</id>
    <published>2021-04-26T09:00:06.000Z</published>
    <updated>2021-04-26T09:01:34.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、entry"><a href="#1、entry" class="headerlink" title="1、entry"></a>1、entry</h1><p>可以有单入口（string），array（多入口），object</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="string（单入口）-–-gt-最长使用的方式，以一个值作为入口"><a href="#string（单入口）-–-gt-最长使用的方式，以一个值作为入口" class="headerlink" title="string（单入口）   –> 最长使用的方式，以一个值作为入口"></a>string（单入口）   –&gt; 最长使用的方式，以一个值作为入口</h3><p>比如：’./src/index.js‘</p><p>特点：打包形成一个chunk，输出一个bundle文件</p><p>此时：chunk默认为main</p><h3 id="2、array-（多入口）"><a href="#2、array-（多入口）" class="headerlink" title="2、array:（多入口）"></a>2、array:（多入口）</h3><p>传入一个数组，所有一个入口文件只有一个chunk，输出仅有一个bundle</p><p>数组中元素，都会被打包到第一个元素中去，且名字还见output</p><p>作用：一般来说只是在HMR功能中使热更新生效</p><h3 id="3、object"><a href="#3、object" class="headerlink" title="3、object"></a>3、object</h3><p>多入口，以键值对的方式，</p><p>有几个入口文件，就说几个chunk，输出就说几个bundle</p><p>chunk的名称就是前面的key值，</p><p>也可以进行混合：</p><pre><code>entry:{    // 所有入口形成一个chunk，输出仅有一个bundle    // 这样可以让多个库打包成一个chunk    index:['./src/index.js','./src/count.js'],    add:'./src/add.js'},</code></pre><h1 id="2、output："><a href="#2、output：" class="headerlink" title="2、output："></a>2、output：</h1><p>直接上例子：</p><pre><code>output: {    // filename可以指定目录，与名称    filename: '[name].js',    // path只能指定目录，且为所有资源的公共目录    path: resolve(__dirname, 'build'),    // 所有输出路径的公共路径来补充到路径之前：    //  'imgs/a/jpg'(不加/表示当前路径)  ---&gt;'/imgs/a.jpg'（加了/会以当前服务器地址补充，去服务器根目录找imgs，再找a.jpg）  //  publicPath:'/', //确定加不加/,一般用于生产环境    chunkFilename:'[name]_chunk.js',    // 非入口chunk名称,如果不加都会走filename    // 让打包的东西暴露出去使，外面也可以使用    library:'[name]',    // 对暴露的进行指定    libraryTarget: 'commonjs' //commonjs    // libraryTarget:'window'  变量名添加到那个node},</code></pre><h1 id="3、resolve"><a href="#3、resolve" class="headerlink" title="3、resolve"></a>3、resolve</h1><p>配置进行模块路径别名,解决import那个../与./的问题，但是写路径没有提示了</p><p>当然了也防止弄混了</p><pre><code>resolve:{    // 配置进行模块路径别名,解决import那个../与./的问题，但是写路径没有提示了    // 路径别名的方式：无提示    alias:{        $css:resolve(__dirname,'src/css')    },    // 配置省略路径的后缀名    // 省略的是index，js中引用处的后缀名    extensions:['.js','.json','.css','.jsx'],    // 注意这样文件名不要一样！！！    // 告诉webpack解析模块时，解析那个目录    // 这样写清楚绝对路径之后，找起来更快y一点点点    modules:[ resolve(__dirname,'../../node_modules'),'node_modules'    ]}</code></pre><p>这样在入口文件下引入就可以：</p><pre><code>import '$css/a'</code></pre><h1 id="4、devserver"><a href="#4、devserver" class="headerlink" title="4、devserver"></a>4、devserver</h1><p>使用npx webpack-dev-server运行之后会自动进行更新修改</p><pre><code>devServer:{    // 运行代码的目录    contBase:resolve(__dirname,'build'),    watchContentBase:true,    //监视contbase目录，一旦文件变化就会reload重载    watchOptions:{        // 忽略文件        ignored:/node_modules/    },    //启动gzip压缩    compress:true,    port:3000,  //端口号    //域名    host:'localhost',    // 自动打开浏览器    open:true,    // 开启HMR功能    hot:true,    // 不需要显示启动服务器日志信息    clientLogLevel:true,    // 除了一些基本启迪以外，其他内容都不要显示     quiet:true,    // 如果出现错误不要全屏提示    overlay:false,    // 服务器代理-----解决开发环境的跨域问题    proxy:{        // 一旦devserver（3000）服务器，接收到/api/xxx请求        // 就会把请求转发到另一个服务器:5000        '/api':{            target:'http://localhost:5000',            pathRewrite:{                // 发送请求时,请求路径重写               // 将/api/xxx改为/xxx(去掉/api)                '^/api':''            }        }    }}</code></pre><h1 id="5、optimization"><a href="#5、optimization" class="headerlink" title="5、optimization"></a>5、optimization</h1><p>optimization主要用于生产环境的代码分割</p><pre><code>optimization:{        splitChunks:{            chunks:'all',            //以下都是默认值，可以不写，直接写上面一句就行             // minSize:30*1024,  //分割的chunk最小为30kb            // maxSize:0,  //最大无限，有多大都可以分割            // minChunks:1,  //要被提取的chunks最少被引用一次            // maxAsyncRequest:5, //按需1加载时，并行加载的文件的最大数目为5            // maxInitialRequest:3,  //引入js文件最大并行请求数目            // automaticNameDelimiter:'~',  //名称连接符            // name:true,   //可以使用命名规则            // cacheGroups:{   //分割的chunk组,一组表示一种规则            //     // node_modules文件会被打包到vendor组的chunk中，  --》vendors ~ xxx.js            //     // node_modules还要满足上面的规则，如大小要超过30kb            //     vendors:{            //         test:/[\\/]node_modules[\\/]/,            //         // 优先级            //         priority:-10            //     },            //     default:{            //         // 要被提取的chunk最少要被引用两次            //         minChunks:2,            //         priority:-100,            //         // 实现代码的复用:            //         // 如果当前要打包的模块，和之前被提取的模块是同一个，就会复用，而不是重新打包            //         reuseExistingChunk:true            //     }            // }        },        // 将当前模块的记录其他模块的hash单独打包为一个文件runtime        // 如果不加这个会导致hash值储存在js文件（main）中,写了这个代码会使main.js中的代码少很多        //注意存储于js文件的原因是        runtimeChunk:{            name:entrypoint =&gt; `runtime-${entrypoint.name}`        },        // 上面解决的问题：修改a文件导致b文件的hash值变化，        minimizer:[            // 配置生产环境的压缩方案：js与css            new terserWebpackPlugin({                // 开启缓存                cache:true,                // 开启多进程打包                parallel:true,                // 启用source-map，否则被压缩掉                sourceMap:true,            })        ]}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、entry&quot;&gt;&lt;a href=&quot;#1、entry&quot; class=&quot;headerlink&quot; title=&quot;1、entry&quot;&gt;&lt;/a&gt;1、entry&lt;/h1&gt;&lt;p&gt;可以有单入口（string），array（多入口），object&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="webpack学习" scheme="https://useritem.github.io/categories/webpack%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack环境优化</title>
    <link href="https://useritem.github.io/2021/04/26/webpack%E5%AD%A6%E4%B9%A0/webpack%E7%8E%AF%E5%A2%83%E4%BC%98%E5%8C%96/"/>
    <id>https://useritem.github.io/2021/04/26/webpack%E5%AD%A6%E4%B9%A0/webpack%E7%8E%AF%E5%A2%83%E4%BC%98%E5%8C%96/</id>
    <published>2021-04-26T08:15:57.000Z</published>
    <updated>2021-04-28T03:54:15.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、HMR：模块热替换"><a href="#1、HMR：模块热替换" class="headerlink" title="1、HMR：模块热替换"></a>1、HMR：模块热替换</h1><p>当一个模块发生改变时，需要全部进行重新打包，所以使用HMR模块，提高其效率</p><p>样式文件:可以使用HMR功能,因为style-loader自动实习了—–&gt;这就是为啥开发时用style-loader</p><p>js文件:默认没有使用HMR功能–&gt;要修改js代码,添加支持HMR的代码<br>     注意:HMR功能对于js处理,只能处理非入口文件</p><p>html:默认不能使用HMR功能,同时html文件不能热更新，解决:修改entry入口,将html文件引入(它不需要做HMR功能)，不止在plugins中引入：</p><pre><code> entry:['./src/index.js','./src/index.html'],</code></pre><h2 id="js处理（index-js文件下的）："><a href="#js处理（index-js文件下的）：" class="headerlink" title="js处理（index.js文件下的）："></a>js处理（index.js文件下的）：</h2><pre><code>// 一旦module.hot为true,说明开启了HMR功能，这时对某个js文件进行监听module.hot.accept('./print.js',function(){    //方法会监听print.js文件变化,一旦发生变换,其他默认不会打包构建    // 会执行后面的回调函数    print()})}</code></pre><h1 id="2、source-map-–一种映射"><a href="#2、source-map-–一种映射" class="headerlink" title="2、source map   –一种映射"></a>2、source map   –一种映射</h1><h2 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h2><p>source-map:一种提供源代码到构建代码的映射技术(如果构建后代码错误,通过映射可以追踪源代码错误)(外部)</p><h2 id="2、参数（进行组合）"><a href="#2、参数（进行组合）" class="headerlink" title="2、参数（进行组合）"></a>2、参数（进行组合）</h2><pre><code>[inline-|hidden-|eval][nosources][cheap-[module-]] source-map</code></pre><p><strong>注意参数结合顺序</strong></p><pre><code>source-map --&gt;外部</code></pre><p>错误代码的准确信息以及”源代码”的错误位置(从f12中的soucer中看)</p><pre><code> inline-source-map  ---&gt;内联source-map文件</code></pre><p>1.只是一个内联的source-map</p><p>2.错误代码的准确信息以及源代码的错误位置(从f12中的soucer中看) 类似于上</p><pre><code>hidden-source-map --&gt;外部</code></pre><p>提供错误代码的错误原因,没有错误位置,不能指到源代码错误,只能指示到构键后的位置</p><pre><code>eval-source-map   --&gt;   内联</code></pre><p>1.每个文件都有对应的source-map,并且都在eval中</p><p>2.错误代码的准确信息以及源代码的错误位置(从f12中的soucer中看) 类似于上source-map</p><pre><code>nosources-source-map --&gt;外部</code></pre><p>提供错误代码的错误信息,没有任何源代码信息 —&gt;隐藏源代码hidden,nosources</p><pre><code>cheap-source-map --&gt;外部</code></pre><p> 错误代码的准确信息以及源代码的错误位置(从f12中的soucer中看),</p><p> 区别source-map   -=–仅能精确到行</p><pre><code>cheap-module-source-map --&gt;外部</code></pre><p>错误代码的准确信息以及源代码的错误位置</p><p>module会将loader的source,map加入</p><p>内联与外部区别:</p><p>1.外部生成的文件,内联没有</p><p>2.内联更快</p><h2 id="3、使用场景"><a href="#3、使用场景" class="headerlink" title="3、使用场景"></a>3、使用场景</h2><h3 id="（1）开发环境-速度快-调试友好"><a href="#（1）开发环境-速度快-调试友好" class="headerlink" title="（1）开发环境:速度快,调试友好"></a>（1）开发环境:速度快,调试友好</h3><p>速度快:eval –inline –cheap</p><p>eval-cheap-souce-map(1,3组合)  因为这时cheap仅仅精确到行,列忽略</p><p> 调试友好:</p><p>source-map</p><p>cheap-module-source-map</p><p>cheap-source-map</p><p>所以：<br>平衡感觉:eval-source-map(vue,react脚手架中使用)  /eval-cheap-module-source-map（就是没有列的信息）</p><h3 id="（2）生产环境下-源代码是否需要隐藏-调试是否需要友好"><a href="#（2）生产环境下-源代码是否需要隐藏-调试是否需要友好" class="headerlink" title="（2）生产环境下:源代码是否需要隐藏,调试是否需要友好"></a>（2）生产环境下:源代码是否需要隐藏,调试是否需要友好</h3><p>隐藏hidden,nosources</p><p>注意:内联导致代码非常,大,所有使用外部方式</p><pre><code>nosources-source-map-全部隐藏hidden-source-map之隐藏元源代码,会提示构建之后的错误信息</code></pre><p>推荐:source-map  / cheap-module-souce-map</p><h2 id="4、使用方法："><a href="#4、使用方法：" class="headerlink" title="4、使用方法："></a>4、使用方法：</h2><pre><code>devtool:'eval-source-map' //开发</code></pre><h1 id="3、优化打包速度"><a href="#3、优化打包速度" class="headerlink" title="3、优化打包速度"></a>3、优化打包速度</h1><h2 id="1-oneOf"><a href="#1-oneOf" class="headerlink" title="1.oneOf"></a>1.oneOf</h2><p>当在oneOf里面进行寻找loader时，但找到一个<strong>直接进行返回</strong>，注意如果有一种文件对应<strong>多种</strong>loader时，其余的放在oneof之外</p><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><pre><code>{oneOf：[        test:'/\.js$/'    ......    ]}</code></pre><p>把之前的loader放置在oneOf的大数组中，并用{}对数组进行包裹</p><h2 id="2-缓存"><a href="#2-缓存" class="headerlink" title="2.缓存"></a>2.缓存</h2><h3 id="（1）babel缓存"><a href="#（1）babel缓存" class="headerlink" title="（1）babel缓存"></a>（1）babel缓存</h3><pre><code>cacheDirectory:true ----&gt;第二次打包构建速度更快</code></pre><p>直接在presets数组后面的，加这一句话，表示开始babel缓存</p><h3 id="（2）文件资源缓存（优化代码运行）"><a href="#（2）文件资源缓存（优化代码运行）" class="headerlink" title="（2）文件资源缓存（优化代码运行）"></a>（2）文件资源缓存（优化代码运行）</h3><p>hash:每次webpack打包生成的唯一hash值</p><p>问题：由于js与css同时使用一个hash值，如果重新打包，会导致所有打包失效</p><p>但是可能只是改变了一个文件</p><p>chunkhash:根据chunk生成的hash值，如果打包同一个chunk，那么打包一样</p><p>问题：js与csshash值还是一样的</p><p>因为css是在js文件中被引入的，所有属于一个chunk（一个入口文件的所有依赖css，js文件，这些与入口形成一个代码块–chunk）</p><p>contenthash：根据文件的内容生成hash’值，不同的文件内容hash值一定不一样</p><p>—》让代码上线运行缓存更好用</p><pre><code>  output:{    filename:'js/built.[contenthash:10].js',    path:resolve(__dirname,'build')},</code></pre><h1 id="4、优化代码运行的性能"><a href="#4、优化代码运行的性能" class="headerlink" title="4、优化代码运行的性能"></a>4、优化代码运行的性能</h1><h2 id="1-缓存-hash-chunkhash-contenthash-见上"><a href="#1-缓存-hash-chunkhash-contenthash-见上" class="headerlink" title="1.缓存(hash-chunkhash-contenthash)  见上"></a>1.缓存(hash-chunkhash-contenthash)  见上</h2><h2 id="2-tree-shaking"><a href="#2-tree-shaking" class="headerlink" title="2.tree shaking"></a>2.tree shaking</h2><h3 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h3><p>1.必须使用ES6模块化</p><p>2.开启production环境</p><p>主要在于去除无用的代码，，减少代码打包的体积</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p> 在package.js”中配置sideEffects”:false，</p><p>—》这代表所有代码都是没有副作用的—都可以进行tree shaking</p><pre><code>问题：可能干掉css/@babel/polyfill被认为是副作用文件，被干掉</code></pre><ul><li><pre><code> 解决："sideEffects":["*.css","*.less"]</code></pre></li></ul><h2 id="3-code-split-–代码分割"><a href="#3-code-split-–代码分割" class="headerlink" title="3.code split –代码分割"></a>3.code split –代码分割</h2><h3 id="1、通过entry进行文件输出，输出多个文件-多入口"><a href="#1、通过entry进行文件输出，输出多个文件-多入口" class="headerlink" title="1、通过entry进行文件输出，输出多个文件(多入口)"></a>1、通过entry进行文件输出，输出多个文件(多入口)</h3><h3 id="2、optimization设置"><a href="#2、optimization设置" class="headerlink" title="2、optimization设置"></a>2、optimization设置</h3><p>1.可以自动将node_module中的代码打包为一个chunk进行输出</p><p>2.自动分析多入口chunk中，有没有公共文件，有的话单独打包为一个chunk<br>    optimization:{<br>        splitChunks:{<br>            chunks:”all”<br>        }<br>    },</p><h3 id="3、使用js使文件单独打包："><a href="#3、使用js使文件单独打包：" class="headerlink" title="3、使用js使文件单独打包："></a>3、使用js使文件单独打包：</h3><pre><code>// 使后面的test.js进行单独打包 import (/* webpackChunkName:'test'*/'./test.js') .then(({mul,count})=&gt;{     console.log(mul(2,5)) }).catch(()=&gt;{     console.log('文件加载失败') })</code></pre><p>这种使用js语法让<strong>某个</strong>文件打包为一个chunk</p><p>即使用import的动态打包</p><p>而webpackChunkName则是名字的固体规范否则是hash动态变化值</p><h2 id="4-懒加载与预加载"><a href="#4-懒加载与预加载" class="headerlink" title="4.懒加载与预加载"></a>4.懒加载与预加载</h2><p>一个是真的不点击不加载，一个是等着其他加载完了，会偷偷加载</p><p>在原js文件中设置、</p><p>预加载：</p><pre><code>import (/* webpackChunkName:'test',webpackPrefetch:true */'./test').then(({mul}) =&gt;{    console.log(mul(4,6))})</code></pre><p>懒加载：</p><pre><code>import (/* webpackChunkName:'test'*/'./test').then(({mul}) =&gt;{    console.log(mul(4,6))})</code></pre><p>合理使用prefetch可以防止出现点击延迟的问题，等着浏览器空闲时加载也是可以的</p><p>当然了延迟也是第一次延迟，只会内存中就有了，不延迟了</p><h1 id="5、其他设置"><a href="#5、其他设置" class="headerlink" title="5、其他设置"></a>5、其他设置</h1><h2 id="1-pwa-—-渐进式网路开发应用程序（保障离线也可以访问）"><a href="#1-pwa-—-渐进式网路开发应用程序（保障离线也可以访问）" class="headerlink" title="1.pwa — 渐进式网路开发应用程序（保障离线也可以访问）"></a>1.pwa — 渐进式网路开发应用程序（保障离线也可以访问）</h2><p>实现：</p><p>workbox实现—》webpack体现为workbox-webpack-plugin</p><p>代码：</p><pre><code>const WorkboxWebpackPlugin = require('workbox-webpack-plugin') new WorkboxWebpackPlugin.GenerateSW({            // 先设置配置,作用：            /*            1、帮助serviceworker快速启动            2、删除旧的serviceworker            最后生成一个serviceWorker配置文件，之后通过它在入口js文件注册            */          clientsClaim:true,          skipWaiting:true        })</code></pre><p>js入口:</p><pre><code>// 注意这里的servWorker的写法为小驼峰式，第一个小写，其余为大写 if('serviceWorker' in navigator){window.addEventListener('load',()=&gt;{    // 这个文件之后由webpack中的生成    navigator.serviceWorker.register('/service-worker.js').then(()=&gt;{        // 通过then与catch判断是否成功        console.log('sw注册成功')    })    .catch(()=&gt;{        console.log('注册sw失败')    })})}// 成功之后，会在f12中的application中生成一个service Workers//          且Cache中的Cache Storage中会有对应文件的缓存</code></pre><h3 id="配置问题"><a href="#配置问题" class="headerlink" title="配置问题"></a>配置问题</h3><p>1、eslint不认识window，navigator全局变量</p><p> 解决：修改package。json中的eslintConfig配置</p><pre><code>"env":{      "browser":true  //支持浏览器全局变量,browser表示浏览器}</code></pre><p>2.sw必须运行在服务器上  –nodejs</p><p> npm i serve -g   快速创建一个静态资源服务器</p><p> 多了一个指令：– serve -s build  –build表示运行代码的目录</p><p> 之后：会启动一个服务器，将build目录下的静态资源进行部署</p><h2 id="2-externals-–cdn引入文件，不会打包"><a href="#2-externals-–cdn引入文件，不会打包" class="headerlink" title="2.externals  –cdn引入文件，不会打包"></a>2.externals  –cdn引入文件，不会打包</h2><p>在webpack.congfig.js中设置：</p><pre><code>externals:{    // 忽略的库名  --npm包名    jquery:'jQuery'    //目的就是禁止，jquery被打包，但是注意：需要在src中的html中进行引入    // 加一个cdn链接引入，拒绝进行打包}</code></pre><p>表示对某文件的禁用</p><p>之后需要在使用的文件中，用cdn方式进行引入</p><h2 id="3-dll"><a href="#3-dll" class="headerlink" title="3.dll"></a>3.dll</h2><p>当第三方文件需要对文件进行打包引入时，使用dll对文件进行单独打包，注意开始先运行一下webpack.dll.js(webpack –config webpack.dll.js)</p><p>webpack.dll.js:</p><pre><code>const {resolve} = require('path')const webpack = require('webpack')module.exports = {entry:{    // 最终打包生成的[name]  --&gt;jquery    // ['jquery'] --&gt;要打包的库是jquery    jquery:['jquery']},output:{    filename:'[name].js',    //通过resolve进行绝对路径的拼接    path: resolve(__dirname,'dll'),    library:'[name]_[hash]',//打包的库向外暴露的内容叫啥名字},// 前面专门为了打报jqueryplugins:[    // 打包生成一个manifest.json  ----》提供一个jquery映射关系    new webpack.DllPlugin({        name:'[name]_[hash]',  //映射哭的暴露的内容是什么        path:resolve(__dirname,'dll/manifest.json')  //输出路径    })],mode:'production'}</code></pre><p>之后在webpack.config.js文件中进行声明（那些忽略,那些进行引入）</p><pre><code>    // 告诉webpack那些库不参与打包，同时使用时的库也需要修改    new webpack.DllReferencePlugin({        manifest: resolve(__dirname, 'dll/manifest.json')    //忽略jquery    }),    // 将某个文件打包输出出去，并在html中自动引入修改    new AddssetHtmlWebpackPlugin({        filepath:resolve(__dirname,'dll/jquery.js')        //将之前打包的引入    })</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、HMR：模块热替换&quot;&gt;&lt;a href=&quot;#1、HMR：模块热替换&quot; class=&quot;headerlink&quot; title=&quot;1、HMR：模块热替换&quot;&gt;&lt;/a&gt;1、HMR：模块热替换&lt;/h1&gt;&lt;p&gt;当一个模块发生改变时，需要全部进行重新打包，所以使用HMR模块，提高</summary>
      
    
    
    
    <category term="webpack学习" scheme="https://useritem.github.io/categories/webpack%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack生产环境配置</title>
    <link href="https://useritem.github.io/2021/04/26/webpack%E5%AD%A6%E4%B9%A0/webpacks%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://useritem.github.io/2021/04/26/webpack%E5%AD%A6%E4%B9%A0/webpacks%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2021-04-26T01:59:12.000Z</published>
    <updated>2021-04-28T02:16:09.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack生产环境的配置"><a href="#webpack生产环境的配置" class="headerlink" title="webpack生产环境的配置"></a>webpack生产环境的配置</h1><p>主要内容就是。实现css的单独提取，把js，css，html文件实现压缩以及语法的检查：</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>const {resolve} = require('path')const MiniCssExtractPlugin = require('mini-css-extract-plugin')const yasucss = require("optimize-css-assets-webpack-plugin")const HtmlWebpackPlugin = require('html-webpack-plugin')//定义nodejs环境变量，确定browlist的环境process.env.NODE_ENV = 'production'// 减少代码的复用const commonCssLoader = [MiniCssExtractPlugin.loader,'css-loader',{    loader: 'postcss-loader',    options: {        ident: 'postcss',        plugins: () =&gt; [            // 使用postcss的插件            require('postcss-preset-env')()        ]    }}]// commonjs语法暴露对象module.exports = {entry: './src/js/index.js',output: {    filename: 'js/built.js',    path: resolve(__dirname, 'build')},module: {    rules: [{            test: /\.css$/,            use: [                // 把css提取为单独文件                // 还需要对browserslist的定义               ...commonCssLoader            ]        },        {            test: /\.less$/,            use: [                // 把css提取为单独文件                ...commonCssLoader,                'less-loader'            ]        },        // 正常来说一个文件要被一个loader处理        //一旦被多个loader处理要明白,loader的执行顺序 :        // 先执行eslint,在执行babel        //js语法配置:        {            // package.json中的eslintConfig进行配置写法  --airbnb            test: /\.js$/,            exclude: /node_modules/,            // 下面表示优先执行            enforce: 'pre',            loader: 'eslint-loader',            options: {                fix: true            }        },        {            test: /\.js$/,            exclude: /node_modules/,            loader: 'babel-loader',            options: {                presets: [                  [                        '@babel/preset-env',                    {                        //值进行按需加载                        useBuiltIns: 'usage',                            //指定corejs的版本                        corejs: {                            version: 3                        },                        targets: {                            chrome: '60',                            firefox: '50'                        }                    }                ]                ]            }        },        {            test: /\.(jpg|png|gif)/,            loader: 'url-loader',            options: {                limit: 8 * 1024,                name: '[hash:10].[ext]',                // 输出路径                outputPath: 'imgs',                esModule: false            }        },        {            test: /\.html$/,            loader: 'html-loader'        },        {            exclude: /\.(js|css|less|html|jpg|png|gif)/,            loader: 'file-loader',            options: {                outputPath: 'media'            }        }    ]},plugins: [    new MiniCssExtractPlugin({        // 修改路径        filename: 'css/built.css'    }),    new yasucss(),    new HtmlWebpackPlugin({        template: "./src/index.html",        //压缩html        minify: {        minify:{            //移除空格            collapseWhitespace:true,            // 移除注释            removeComments:true        }        }    })],mode: "production"}</code></pre><h2 id="2、解释"><a href="#2、解释" class="headerlink" title="2、解释"></a>2、解释</h2><h3 id="（1）css的单独打包"><a href="#（1）css的单独打包" class="headerlink" title="（1）css的单独打包"></a>（1）css的单独打包</h3><p>主要通过mini-css-extract-plugin实现，并且用它来代替原来的style loader ：</p><pre><code>const MiniCssExtract = require('mini-css-extract-plugin')// 'style-loader',// 这里原本表示创建style标签，把css存入js文件中   MiniCssExtract.loader,   // 上面的Mini取代style-loader保证取代js中，变为css文件,单独提取css，保证速度</code></pre><h3 id="（2）css兼容性处理："><a href="#（2）css兼容性处理：" class="headerlink" title="（2）css兼容性处理："></a>（2）css兼容性处理：</h3><p>css兼容性处理：postcss –需要postcss-loader ，</p><p>还需要插件postcss-preset-env用于帮助postcss识别某些环境，从而加载指定的配置，用于保证兼容性<br>帮post-css找到package.json中的browserslist里的配置，通过配置加载指定的css兼容样式.</p><p>package.json的设置：</p><pre><code> "browserslist":{    "development":[        "last 1 chrome version",        "last 1 firefox version",        "last 1 safari version"    ],    "production":[        "&gt;0.2%",        //   后面表示不要什么浏览器         "not dead",        "not op_mini all"    ]    }</code></pre><p>postcss实际处理代码见上面例子，需要在loader中写明，并且在plugins中注明打包的位置</p><h3 id="3、压缩css"><a href="#3、压缩css" class="headerlink" title="3、压缩css"></a>3、压缩css</h3><p>两步：<br>    const optimzieCssAssetsWebpackPlugin = require(‘optimize-css-assets-webpack-plugin’)</p><pre><code>new optimzieCssAssetsWebpackPlugin()</code></pre><h3 id="4、js语法检查"><a href="#4、js语法检查" class="headerlink" title="4、js语法检查"></a>4、js语法检查</h3><h4 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h4><p>语法检查：保证工作时，写的代码大致一样 —》eslint，</p><p>此时需要eslint-loader，与eslint库</p><p>注意：只检查自己写的源代码，第三方的库不用检查</p><p>注意在package.json中需要进行设置</p><pre><code>"eslintConfig":{    "extends":"airbnb-base"   //确定配置 }</code></pre><p>使用的是airbnb规则，需要 eslint-config-airbnb-base eslint eslint-plugin-import</p><p>loader中的内容见上</p><h3 id="4、js兼容性处理-—高级语法的简化"><a href="#4、js兼容性处理-—高级语法的简化" class="headerlink" title="4、js兼容性处理  —高级语法的简化"></a>4、js兼容性处理  —高级语法的简化</h3><p>首先注意当loader的引入是use方法时,<strong>不能进行options设置,否则报错</strong></p><p>只能通过单个loader设置: loader:’babel-loader’,才可以设置option参数</p><h4 id="进行兼容性处理的方法及压缩"><a href="#进行兼容性处理的方法及压缩" class="headerlink" title="进行兼容性处理的方法及压缩"></a>进行兼容性处理的方法及压缩</h4><pre><code>js兼容性处理：babel-loader</code></pre><p>1、它的配置的包还有@babel/preset-env，@babel/core<br>把es6相关东西变为es5的东西<br>问题：只能修改基础语法~~，例如Promise不可以改变</p><p>2、全部js兼容性处理 –》@babel/polyfill</p><p>这个在原文件中通过import引用即可<br>问题：由于我只需要解决部分兼容性问题，但是全部引入，所以会增大代码的体积</p><p>3、需要做兼容性处理的就做：按需加载 –》core-js</p><p>具体代码见上</p><h4 id="压缩-在production环境下会自动进行压缩"><a href="#压缩-在production环境下会自动进行压缩" class="headerlink" title="压缩:在production环境下会自动进行压缩"></a>压缩:在production环境下会自动进行压缩</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;webpack生产环境的配置&quot;&gt;&lt;a href=&quot;#webpack生产环境的配置&quot; class=&quot;headerlink&quot; title=&quot;webpack生产环境的配置&quot;&gt;&lt;/a&gt;webpack生产环境的配置&lt;/h1&gt;&lt;p&gt;主要内容就是。实现css的单独提取，把js，</summary>
      
    
    
    
    <category term="webpack学习" scheme="https://useritem.github.io/categories/webpack%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack开发环境配置</title>
    <link href="https://useritem.github.io/2021/04/26/webpack%E5%AD%A6%E4%B9%A0/webpack%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://useritem.github.io/2021/04/26/webpack%E5%AD%A6%E4%B9%A0/webpack%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2021-04-26T01:57:25.000Z</published>
    <updated>2021-04-26T02:00:10.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack开发环境配置"><a href="#webpack开发环境配置" class="headerlink" title="webpack开发环境配置"></a>webpack开发环境配置</h1><p>对于development环境，主要就是直观上webpack不会进行代码压缩为一行，可以直接清除看看到源码</p><p>开发环境主要要求的是，代码速度运行快，调试友好</p><h2 id="1、主要内容"><a href="#1、主要内容" class="headerlink" title="1、主要内容"></a>1、主要内容</h2><p>分为打包css，js资源，html资源，打包图片资源，打包html中的图片资源，打包其他资源，devServer模式等</p><p>例子：</p><pre><code>/** * 开发环境配置：主要保证代码运行正确 */const {resolve} = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = {entry:'./src/index.js',output:{    filename:'built.js',    path:resolve(__dirname,'build')},module:{           // loader配置    rules:[        {    //处理less            test:/\.less$/,            use:[                'style-loader',                'css-loader',                'less-loader'            ]        },        {    //处理css            test:/\.css$/,            use:[                'style-loader',                'css-loader',            ]        },        {  //处理图片loader            test:/\.(jpg||png||gif)$/,            loader:'url-loader',            options:{                limit:20*1024,                name:'[hash:10].[ext]',                // 关闭es6模块规则，打开commonjs的规则                esModule:false            }        },        {  //处理html中的loader照片            test:/\.html$/,            loader:'html-loader'        },        {//处理其他资源            exclude:/\.(html||js||css||jpg||png||gif||less)$/,            loader:'file-loader',            options:{                name:'[hash:10].[ext]',            }        }    ]},plugins:[        new HtmlWebpackPlugin({            template:'./src/index.html'        })    ],mode:'development',devServer:{    contentBase:resolve(__dirname,'build'),    // 启动gzip压缩，使代码体积小，运行快    compress:true,    // 开发服务器端口号    port:3000,    // 自动打开浏览器    open:true    }}</code></pre><h2 id="2、注意："><a href="#2、注意：" class="headerlink" title="2、注意："></a>2、注意：</h2><h3 id="1-对于html图片资源进行打包时，webpack5-0以下版本注意："><a href="#1-对于html图片资源进行打包时，webpack5-0以下版本注意：" class="headerlink" title="1.对于html图片资源进行打包时，webpack5.0以下版本注意："></a>1.对于html图片资源进行打包时，webpack5.0以下版本注意：</h3><p>此时是commonjs模块语法,而<strong>url-loader默认是es6的语法</strong></p><p>所以直接解析会出问题</p><p>解决:关闭url-loader的es6模块化,使用commonJS解析</p><pre><code>esModule:false在上面关</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;webpack开发环境配置&quot;&gt;&lt;a href=&quot;#webpack开发环境配置&quot; class=&quot;headerlink&quot; title=&quot;webpack开发环境配置&quot;&gt;&lt;/a&gt;webpack开发环境配置&lt;/h1&gt;&lt;p&gt;对于development环境，主要就是直观上web</summary>
      
    
    
    
    <category term="webpack学习" scheme="https://useritem.github.io/categories/webpack%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack初体验</title>
    <link href="https://useritem.github.io/2021/04/26/webpack%E5%AD%A6%E4%B9%A0/webpack%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://useritem.github.io/2021/04/26/webpack%E5%AD%A6%E4%B9%A0/webpack%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2021-04-26T01:56:17.000Z</published>
    <updated>2021-04-26T02:00:10.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、webpack"><a href="#1、webpack" class="headerlink" title="1、webpack"></a>1、webpack</h1><h2 id="1、webpack介绍"><a href="#1、webpack介绍" class="headerlink" title="1、webpack介绍"></a>1、webpack介绍</h2><p>webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。</p><p> 在 webpack 看来, 前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理。 </p><p>它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。</p><p>解决问题主要可以也针对那些浏览器无法识别的问题，比如es6某些语法等等</p><h2 id="2、学习思路及流程"><a href="#2、学习思路及流程" class="headerlink" title="2、学习思路及流程"></a>2、学习思路及流程</h2><p><a href="https://imgtu.com/i/czbN40"><img src="https://z3.ax1x.com/2021/04/26/czbN40.png" alt="czbN40.png"></a></p><h3 id="打包过程："><a href="#打包过程：" class="headerlink" title="打包过程："></a>打包过程：</h3><p>由于模块化思想，所以一个文件会引入项目中全部的资源构建工具的处理过程：</p><p>（1）首先告诉webpack入口文件，（及以什么为起点进行打包）</p><p>（2）之后记录依赖：‘$’,’./‘等等，并形成树状结构图</p><p>（3）之后再根据图中依赖顺序进行引用，形成一个chunk代码块，</p><p>（4）之后再对代码块进行处理，比如把less变为css等等，即为进行打包</p><p>（5）最后再进行输出（搬动）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、webpack&quot;&gt;&lt;a href=&quot;#1、webpack&quot; class=&quot;headerlink&quot; title=&quot;1、webpack&quot;&gt;&lt;/a&gt;1、webpack&lt;/h1&gt;&lt;h2 id=&quot;1、webpack介绍&quot;&gt;&lt;a href=&quot;#1、webpack介绍&quot; c</summary>
      
    
    
    
    <category term="webpack学习" scheme="https://useritem.github.io/categories/webpack%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>js学习9</title>
    <link href="https://useritem.github.io/2021/04/20/js%E5%AD%A6%E4%B9%A0/js%E5%AD%A6%E4%B9%A09/"/>
    <id>https://useritem.github.io/2021/04/20/js%E5%AD%A6%E4%B9%A0/js%E5%AD%A6%E4%B9%A09/</id>
    <published>2021-04-20T08:04:47.000Z</published>
    <updated>2021-04-21T13:33:22.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、类"><a href="#一、类" class="headerlink" title="一、类"></a>一、类</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>es6所引入的类class，可以理解为新的基础性的语法糖结构，虽然是面向对象编程，但是背后仍是原型与构造函数的概念。</p><h2 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h2><p>（1）类的声明不可以提升</p><p>（2）类受块级作用域限制</p><h2 id="3、构造"><a href="#3、构造" class="headerlink" title="3、构造"></a>3、构造</h2><pre><code>class a{    constructor(name){        this.name = name    //    sayhello = function(){    //        console.log('he')    //    }    //不能在构造函数中定义属性    }    age =     sayname(){            console.log(this.name)    }}let bob = new a('bob')bob.sayname()</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>类构造函数必须为new，如果没有new会报错，且constructor中只可以写属性，new时<strong>自动调用</strong></p><h3 id="特殊："><a href="#特殊：" class="headerlink" title="特殊："></a>特殊：</h3><pre><code>class person{    say(){        console.log(`名字是${person.tname} 年龄是${this.age} my的名字是${this.name} ${person.name}`)    }}person.name = 'bob'person.tname = 'bob'person.prototype.age = 15let a = new person()a.name = 'a' a.tname = 'a'  //无用a.say()名字是bob 年龄是15 my的名字是a person</code></pre><p>解释：函数外部可以<strong>手动添加成员数据</strong>，且在 person.prototype.age上添加属性，<strong>实例也可以使用</strong></p><p>如果直接person.tname = ‘bob’这样加，<strong>实例无法对属性变化</strong>，</p><p>且注意名字person.name，这是自身属性，无法变，指向类名！！</p><h2 id="4、关键字"><a href="#4、关键字" class="headerlink" title="4、关键字"></a>4、关键字</h2><p>extends  —继承</p><p>super（）–  这个行为等同于调用构造函数</p><pre><code>class father{    constructor(age){        this.age = age    }}class me extends father{    // constructor(age){    //     super(age)    // }    // super()   不能单独用    sayage(){        console.log(this.age)        // console.log(super)    }}let a = new me('aa')a.sayage()console.log(a instanceof me)     //trueconsole.log(a instanceof father)   //true</code></pre><p>当没有使用constructor函数时，系统自动调用父类方法</p><p>当使用super时，也要注意传入参数（向father中）</p><h1 id="二、代理"><a href="#二、代理" class="headerlink" title="二、代理"></a>二、代理</h1><h2 id="1、理解"><a href="#1、理解" class="headerlink" title="1、理解"></a>1、理解</h2><p>代理可以理解为对象的替身，可以对处理对象的方法进行处理：</p><pre><code>const temple = {    name:'bob',    sex:'nan'}// 处理对象:const handler = {    // 这个捕获器名字也是固定的    get(trap,prop,rece){        console.log(trap)// {name: "bob", sex: "nan"}        console.log(prop)   //name,第二次sex        console.log(rece) //{name: "bob", sex: "nan"}    }}// 代理对象,调用Proxy函数时,注意// 1必须传入原对象,以及处理对象//2传入时,注意名字同上const proxy = new Proxy(temple,handler)proxy.name proxy.sex //同上都被get事件捕获,执行get事件proxy.age =23console.log(temple.age)  //23</code></pre><h1 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h1><h2 id="1、特殊的理解"><a href="#1、特殊的理解" class="headerlink" title="1、特殊的理解"></a>1、特殊的理解</h2><p>由于函数的实际是对象，所以函数名实际表示的是<strong>对象的指针</strong>，可以通过函数名进行指针的传递</p><pre><code>function fun(){    console.log('fun')}fun()const fun1 = fun  //使fun1指向函数对象fun = nullfun1()   //funfun()  //报错</code></pre><p>fun = null 这可以切断函数名与函数的关联</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>箭头函数中的大括号表示<strong>函数体</strong>，如果省略表示隐式返回这行代码值</p><pre><code>let doubel = x =&gt;x*3console.log(doubel(4))  //12</code></pre><h2 id="2、实参与形参"><a href="#2、实参与形参" class="headerlink" title="2、实参与形参"></a>2、实参与形参</h2><p>直接上例子：</p><pre><code>    function fun(num1,num2){        console.log('----------------')        console.log(num1+'   '+num2)        arguments[1] = 23           console.log(num1+'   '+num2)        num2 = 334        console.log(num1+'   '+num2)        console.log(arguments[0]+'   '+arguments[1])            }    fun(1)    fun(1,4)</code></pre><p><a href="https://imgtu.com/i/c7IjxS"><img src="https://z3.ax1x.com/2021/04/20/c7IjxS.png" alt="c7IjxS.png"></a></p><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><p>（1）当参数数目一样时，调用实参与形参一样的，且会保持同步的关系</p><p>（2）但是当实参数目少时，改变argument时，<strong>不会影响形参nums2</strong>，当再次设置nums2值时，两者已经不同步</p><p>（3）当然了，当实参数目要多时，那么等于实参数目的部分和情况一一样</p><h2 id="3、重载？"><a href="#3、重载？" class="headerlink" title="3、重载？"></a>3、重载？</h2><pre><code>    function fun(a){        console.log(a)    }    function fun(a,b){        console.log('2222')        console.log(a+b+999)    }    fun(3,4)  //2222  1006    fun(2)  // 2222 NaN</code></pre><p>由于函数名相当于指针，所以函数<strong>没有重载！！！</strong></p><p>且注意函数会提升变量，且<strong>优先级高于var</strong></p><h2 id="4、默认参数"><a href="#4、默认参数" class="headerlink" title="4、默认参数"></a>4、默认参数</h2><pre><code>  const fun = function(name = 'mike',name1 = '23',name2 = name){        console.log(name+'   '+name1+'   '+name2)  //mike 23 mike    }    fun()</code></pre><p>当没有传入参数时，可以使用默认参数进行赋值，并且argumens<strong>不会对默认参数进行读取</strong></p><p>默认参数中可以用<strong>函数或者之前声明的变量</strong>，</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>（1）使用函数做参数时，仅有fun被调用<strong>并且</strong>无参数时，该函数才会调用</p><p>（2）只能是之前的，否则报错：</p><pre><code>  const fun = function(name = 'mike',name1 = name2,name2 = name){        console.log(name+'   '+name1+'   '+name2)  //mike 23 mike   }   fun()  //name1 is undefined</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、类&quot;&gt;&lt;a href=&quot;#一、类&quot; class=&quot;headerlink&quot; title=&quot;一、类&quot;&gt;&lt;/a&gt;一、类&lt;/h1&gt;&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介</summary>
      
    
    
    
    <category term="js学习" scheme="https://useritem.github.io/categories/js%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>js学习8</title>
    <link href="https://useritem.github.io/2021/04/12/js%E5%AD%A6%E4%B9%A0/js%E5%AD%A6%E4%B9%A08/"/>
    <id>https://useritem.github.io/2021/04/12/js%E5%AD%A6%E4%B9%A0/js%E5%AD%A6%E4%B9%A08/</id>
    <published>2021-04-12T14:10:37.000Z</published>
    <updated>2021-04-15T14:21:25.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、创建对象方式"><a href="#一、创建对象方式" class="headerlink" title="一、创建对象方式"></a>一、创建对象方式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然Object构造函数以及对象字面量可以方便的创建对象，但是他们有着明显的不足：对于有着相同接口的对象需要引入重复的代码</p><p>于是，有了以下几种：</p><h2 id="1、工厂函数"><a href="#1、工厂函数" class="headerlink" title="1、工厂函数"></a>1、工厂函数</h2><pre><code>function creat(name,age){    let a = new Object    a.name = name    a.age = age    a.sayname = function(){        console.log(this.name)    }    return a}let person = creat('bob',23)</code></pre><p>但是此时没有解决<strong>对象识别问题</strong>（就是新建的对象是什么类型）</p><h2 id="2、构造函数模式"><a href="#2、构造函数模式" class="headerlink" title="2、构造函数模式"></a>2、构造函数模式</h2><pre><code>function creat(name,age){    this.name = name    this.age = age    this.sayname = function(){        console.log(this.name)    }}let person1 = new creat('bob',23) let person2 = new creat('poa',21)person.sayname()    //bob</code></pre><p>主要区别在于：</p><p>（1）没有显示的建立对象</p><p>（2）属性与方法直接赋值给this</p><p>（3）没有return</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>构造函数的首字母名称是要大写的，非构造函数以小写字母开头</p><p>这个构造函数在于就是new之后会新建立对象，并且进行赋值（this，prototype），然后如果没有return，就返回这个新建的对象。</p><p>并且在上面的例子里面，person1与person2保存着<strong>不同的creat实例</strong></p><pre><code>person1.constructor == creat   //trueperson1.constructor == creat   //true</code></pre><div style="color: #008c8c; margin-top: 10px; font-size: 20px;">任何函数只要使用了new操作符调用都是构造函数，否则就是普通函数</div><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>此时上例如果没有使用new形成构造函数，那么this<strong>始终指向global对象</strong>，</p><p>此时window对象上有了sayname方法，此时的调用需要指定作用域（apply与call）</p><pre><code>function creat(name,age){    this.name = name    this.age = age    this.sayname = function(){        console.log(this.name)    }}let person1 = creat('bob',23)   //undefined 由于没有returnwindow.sayname()  //boblet person2 = new Object()creat.call(person2,'jill',34)person2.sayname()    //jill</code></pre><h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题:"></a>构造函数的问题:</h3><p>主要问题在于它定义的方法在每一个实例上都会<strong>创建一个</strong>，虽然function的实例机制一样，</p><p>但是有着<strong>不同的作用域链以及标识符解析</strong></p><pre><code>person1.sayname == person2.sayname   //false</code></pre><p>由于是同样的事，所以这是没必要的：</p><h2 id="3、原型模式"><a href="#3、原型模式" class="headerlink" title="3、原型模式"></a>3、原型模式</h2><pre><code>function creat(){}   //每个函数都会创建一个prototype属性    creat.prototype.name = 'as'    creat.prototype.age = '23'    creat.prototype.sayname = function(){        console.log(this.name)    }let person1 = new creat()let person2 = new creat()console.log(person1.sayname==person2.sayname) //true</code></pre><p>此时所有的属性以及方法都直接添加在Person的protype属性上</p><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><p>对象联系：</p><p><a href="https://imgtu.com/i/cDTHhT"><img src="https://z3.ax1x.com/2021/04/12/cDTHhT.png" alt="cDTHhT.png"></a></p><pre><code>   console.log(person1.sayname==person2.sayname) //trueconsole.log(person1.__proto__)console.log(creat.prototype)   //与上面的是一样的，上面那个实际是访问[[prototype]]方式，（直接访问不行） console.log(typeof(person1.__proto__))  //object console.log(person1.constructor  === creat)   //true  指向构造函数</code></pre><p>当然可以通过原型对象isPertotypeof()来判断是否在原型链上</p><pre><code>creat.prototype.isPrototypeOf(person1)  //true</code></pre><p>这个主要检查是否<strong>有链接指向Person.prototype</strong></p><p>当然还可以使用instanceof方法：</p><pre><code>person1 instanceof creat    //true</code></pre><h1 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h1><h2 id="1、原型链"><a href="#1、原型链" class="headerlink" title="1、原型链"></a>1、原型链</h2><p>之前我们讨论了好多关于原型链的继承，但是也有好多问题，比如：无法给父类传递构造函数，无法做到私有，于是引入了盗用构造函数，</p><h2 id="2、盗用构造函数"><a href="#2、盗用构造函数" class="headerlink" title="2、盗用构造函数"></a>2、盗用构造函数</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>子类中调用父类的构造函数，并且用call与apply在使其</p><div style="color: red; margin-top: 10px; font-size: 20px;">以子类为执行上下文来构造父类的函数:</div><p></p><p>  function father(name) {<br>        this.name = name<br>        this.color = [‘red’, ‘blue’, ‘pink’]<br>        function sayname(){<br>            console.log(name)<br>        }<br>    }</p><pre><code>function me() {    // 子类中以子类为执行上下文调用父类的方法    // 也可以：father.call(this)     father.apply(this)}let son1 = new me()// son1.sayname()  //报错son1.color.push('black')console.log(...son1.color) //red blue pink blacklet son2 = new meconsole.log(...son2.color) //red blue pink </code></pre><p>注意：由于是在构造函数中调用方法：father.apply(this)，所以子类<strong>不能访问父类的构造方法！！</strong></p><h2 id="扩展：apply与call"><a href="#扩展：apply与call" class="headerlink" title="扩展：apply与call"></a>扩展：apply与call</h2><h3 id="call-和-apply-之间的区别"><a href="#call-和-apply-之间的区别" class="headerlink" title="call() 和 apply() 之间的区别"></a>call() 和 apply() 之间的区别</h3><p>不同之处是：</p><p>call() 方法分别接受参数。</p><p>apply() 方法接受数组形式的参数。</p><p>如果要使用数组而不是参数列表，则 apply() 方法非常方便。例：</p><pre><code>var person = {    fullName: function (city, country) {        console.log(this.firstName + " " + this.lastName + "," + city + "," + country);    }}var person1 = {    firstName: "John",    lastName: "Doe"}person.fullName.call(person1, "Oslo", "Norway");//John Doe,Oslo,Norway//  person.fullName.apply(person1, ["Oslo", "Norway"]);//John Doe,Oslo,Norwayconsole.log(son1 instanceof me)   //trueconsole.log(son1 instanceof father)   //false//不可识别</code></pre><p>由于以上方法都具有问题，所以采用组合继承</p><h2 id="3、组合继承"><a href="#3、组合继承" class="headerlink" title="3、组合继承"></a>3、组合继承</h2><p>即综合起来，<strong>通过原型链继承原型的属性与方法，通过盗用函数继承实例属性</strong></p><p>   function father(name) {<br>        this.name = name<br>        this.color = [‘red’, ‘blue’]<br>    }<br>    father.prototype.sayname = function () {<br>        console.log(this.name)<br>    }</p><pre><code>function me(name, age) {    father.call(this, name)    this.age = age}me.prototype = new father()me.prototype.sayage = function () {    console.log(this.age)}let son1 = new me('nike', 25)son1.color.push('black') console.log(...son1.color)   // red blue son1.sayage()  //25son1.sayname()  //nikelet son2 = new me('mike',65)console.log(...son2.color)   //red blueson2.sayname()   //mikeson2.sayage()    //65console.log(son1 instanceof me)   //trueconsole.log(son1 instanceof father)   //true</code></pre><p>组合继承也可以通过instanceof识别，目前最为广泛</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、创建对象方式&quot;&gt;&lt;a href=&quot;#一、创建对象方式&quot; class=&quot;headerlink&quot; title=&quot;一、创建对象方式&quot;&gt;&lt;/a&gt;一、创建对象方式&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="js学习" scheme="https://useritem.github.io/categories/js%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>js学习7</title>
    <link href="https://useritem.github.io/2021/04/12/js%E5%AD%A6%E4%B9%A0/js%E5%AD%A6%E4%B9%A07/"/>
    <id>https://useritem.github.io/2021/04/12/js%E5%AD%A6%E4%B9%A0/js%E5%AD%A6%E4%B9%A07/</id>
    <published>2021-04-12T12:40:20.000Z</published>
    <updated>2021-04-20T08:04:08.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、私有变量实现"><a href="#一、私有变量实现" class="headerlink" title="一、私有变量实现"></a>一、私有变量实现</h1><p>弱映射WeakMap实现了JS私有变量</p><p>前提：私有变量存储在若映射中，以对象实例为键，私有对象的字典为值</p><pre><code>const User = (() =&gt; {    const wm = new WeakMap()    class User {        constructor(id) {            // 定义symbol类型的数据作为对象属性标识符，里面的id相当于对它的描述            // 注意symbol不支持new，且每次都会新建一个symbol类型            // Symbol("foo") === Symbol("foo"); // false            this.idProperty = Symbol('id')            // 这里直接 = id也是对的，但是无法体现特点            this.setId(id)        }        // 这下面的get，set函数是真正进行操作的函数        setPrivate(prop, id) {            const priNumber = wm.get(this) || {}  // 这里相当于进行了两部操作，先get再赋值                       priNumber[prop] = id            console.log(priNumber)            // weakmap键必须为object            wm.set(this, priNumber)        }        getPrivate(prop) {            return wm.get(this)[prop]        }        // 由于进行set，get操作时，仅有一个参数，所以需要进行转换        //这里的set与get相当于转化的平台        setId(id) {            this.setPrivate(this.idProperty, id)        }        getId(id) {            return this.getPrivate(this.idProperty)        }    }    return User})()const user = new User(123)alert(user.getId())  //123user.setId('54654')console.log(user.getId())  //54654</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>weakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名</p><p>且键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</p><p>而WeakSet成员<strong>都是对象</strong></p><p>它是<strong>真正的弱弱地拿着</strong>,即值不属于正式的引用,可以被垃圾回收</p><p>这两者都不可以被遍历!!</p><h1 id="二、经典例题："><a href="#二、经典例题：" class="headerlink" title="二、经典例题："></a>二、经典例题：</h1><h2 id="1、-运算"><a href="#1、-运算" class="headerlink" title="1、+运算"></a>1、+运算</h2><pre><code>var a = {valueOf(){    console.log('sad')},toString(){    console.log('asas')}}const ar = i+a  //sad   ·//对象进行加法的时候，会自动调用函数valueOf，在这样此方法执行的是被重置之后的函数</code></pre><h2 id="2、提升"><a href="#2、提升" class="headerlink" title="2、提升"></a>2、提升</h2><pre><code>var a =12   //开始是undefinedfunction a(){    console.log('aa')}console.log(typeof(a))  //number</code></pre><p>注意变量提升的顺序，<strong>函数优先级高</strong>，所以同一个变量，分别声明时，先定义的是函数</p><p>但是注意这里有赋值，不会提升！所以三次变化：</p><pre><code>undefined --function --number</code></pre><p>理解：</p><pre><code>function a(){    console.log('aa')}    var a console.log(typeof(a))  //functiona= 12console.log(typeof(a))  //number</code></pre><h2 id="3、let提升"><a href="#3、let提升" class="headerlink" title="3、let提升??"></a>3、let提升??</h2><pre><code>let a =3a++console.log(a++)  //报错,let不会提升的原因在于出现暂时性死区,所以没有提升,但是浏览器会注意到后面的let申明let a =23</code></pre><p>不提升,只是因为暂时性死区,不是没看见!!!!</p><h2 id="4、变量问题"><a href="#4、变量问题" class="headerlink" title="4、变量问题"></a>4、变量问题</h2><pre><code>var a = 3;(function(){a = 10var a = 5})()console.log(a)  //3</code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>（1）由于（）的原因，所以a = 3后面的;是必须的</p><p>（2）由于作用域提升的关系所以后面的var a = 5中的var会提升到a = 10之前，所以这里的 a = 10不是全局声明</p><p>如果去掉var a = 5，那么前面的a = 10的作用域与a =3一样，都是windows，所以最后的输出结果为10~</p><h1 id="三、计算属性—实现属性的动态化"><a href="#三、计算属性—实现属性的动态化" class="headerlink" title="三、计算属性—实现属性的动态化"></a>三、计算属性—实现属性的动态化</h1><pre><code>let a = 'adsa'let b = 'name'let person = {    [a]:'1234',    [b]:'asds'}console.log(person.adsa)    //1234console.log(person)     {adsa: "1234", name: "asds"}</code></pre><p>但是注意此时对对象的属性的操作时，应该使用变量的值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、私有变量实现&quot;&gt;&lt;a href=&quot;#一、私有变量实现&quot; class=&quot;headerlink&quot; title=&quot;一、私有变量实现&quot;&gt;&lt;/a&gt;一、私有变量实现&lt;/h1&gt;&lt;p&gt;弱映射WeakMap实现了JS私有变量&lt;/p&gt;
&lt;p&gt;前提：私有变量存储在若映射中，以对象实</summary>
      
    
    
    
    <category term="js学习" scheme="https://useritem.github.io/categories/js%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>js学习6</title>
    <link href="https://useritem.github.io/2021/04/08/js%E5%AD%A6%E4%B9%A0/js%E5%AD%A6%E4%B9%A06/"/>
    <id>https://useritem.github.io/2021/04/08/js%E5%AD%A6%E4%B9%A0/js%E5%AD%A6%E4%B9%A06/</id>
    <published>2021-04-08T13:37:41.000Z</published>
    <updated>2021-04-12T12:40:45.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、定型数组"><a href="#一、定型数组" class="headerlink" title="一、定型数组"></a>一、定型数组</h1><h2 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h2><p>主要为了提升向原生库传输数据的速率，最早是在WebGL中使用的，最早是在WebGL中使用的，</p><p>在WebGL早期中，由于JS默认以<strong>双精度浮点格式</strong>传输数值，这也是JS内存中的格式，但是此时出现了不匹配的问题</p><p>所以WebGL需要重新分配数组并且进行迭代，转型。</p><h2 id="2、ArrayBuffer（）"><a href="#2、ArrayBuffer（）" class="headerlink" title="2、ArrayBuffer（）"></a>2、ArrayBuffer（）</h2><p>他是定型数组及视图引用的基本单位，它创建之后不可变化大小</p><pre><code>  const vat = new ArrayBuffer(3,4,5)  //这里就是相当于传入了一个3，表示大小，后面4，5没用</code></pre><p>这里代表的是分配的字节数目：</p><pre><code>console.log(vat.byteLength)  //3</code></pre><p>可以与c语言进行相似理解，但注意它的区别特性在于</p><p>（1）分配失败会抛出错误</p><p>（2）回对二进制位进行初始化</p><p>（3）会自动进行垃圾回收，不用手动释放</p><h3 id="3、DataView"><a href="#3、DataView" class="headerlink" title="3、DataView"></a>3、DataView</h3><p>注意上面的ArrayBuffer（）对其进行读写必须要<strong>视图控制—DataView</strong></p><pre><code> const vat = new ArrayBuffer(3,4,5) const a = new DataView(vat) a.setInt8(1,14)          //14 console.log(a.getInt8(1))  a.setInt16(0,2445)  console.log(a.getUint16(0))          //2445</code></pre><p>注意DateView由于它不能对缓冲内容进行预设或者迭代。。。</p><p>但是优点就是只要<strong>地址够</strong>，可以分配不同类型的</p><p>所以只能通过每种类型自动封装的get，set方法来进行操作，类型有如下：</p><pre><code>有符号的8位整数(int8)无符号的8位整数(uint8)有符号的16位整数(int16)无符号的16位整数(uint16)有符号的32位整数(int32)无符号的32位整数(uint32)32位浮点数(float32)64位浮点数(float64)</code></pre><p>注意上面两种可以在之前的基础上进行分割：</p><p>ArrayBuffer：</p><pre><code>let buffer = new ArrayBuffer(10); // 分配了 10 个字节let buffer2 = buffer.slice(4, 6);console.log(buffer2.byteLength); // 2</code></pre><p>DataView：</p><pre><code>let buffer = new ArrayBuffer(10),view = new DataView(buffer, 5, 2); // 包含位置 5 与位置 6 的字节</code></pre><h2 id="3、定型数组创建"><a href="#3、定型数组创建" class="headerlink" title="3、定型数组创建"></a>3、定型数组创建</h2><h3 id="（1）of（）-from（）"><a href="#（1）of（）-from（）" class="headerlink" title="（1）of（） from（）"></a>（1）of（） from（）</h3><p>of（）括号里面<strong>直接是元素</strong>，而form里面是数组</p><p>例子：</p><pre><code>     const res = Int16Array.of(2,3,4)    const res1 = Int32Array.from([2,3,4,5])     console.log(res)    console.log(res1)    console.log(res.byteLength)   //6    console.log(res1.byteLength)  //16</code></pre><p>他们可以好多与数组一样，可以直接通过[],进行复制或取值</p><p>注意of与form对于ArrayBuffer单位不行</p><pre><code>     const b = Int16Array.from(vat)    //不行    b[1] = 32    console.log(b[1])</code></pre><p>虽然不报错，但是也不行</p><h3 id="（2）直接创建new方法"><a href="#（2）直接创建new方法" class="headerlink" title="（2）直接创建new方法"></a>（2）直接创建new方法</h3><pre><code>    const aa = new Int32Array(4)    aa[2] = 23    console.log(aa[2]) //23</code></pre><p>这个new参数就和ArrayBuffer类似，只能是一个数，表示大小，其余多的会忽略</p><p>但是除了一个数还可以传<strong>一个数组</strong>：</p><pre><code> const ab = new Int32Array([3,234,523])</code></pre><p>且定型数组有一个Symbol.iterator属性</p><pre><code>  for(const i of aa){        document.write(i)        document.write('   ')    }alert(Math.max(...aa))   //523</code></pre><p>所以它可以通过<strong>for of循环或者 扩展运算符操作</strong></p><p>注意DataView不行！！！</p><h1 id="Map映射"><a href="#Map映射" class="headerlink" title="Map映射"></a>Map映射</h1><p>对于‘键/值’数据的储存与管理时，JS作为一种新的集合类型对键/值问题进行了，细致解决</p><h2 id="1、构造："><a href="#1、构造：" class="headerlink" title="1、构造："></a>1、构造：</h2><p>空映射：</p><pre><code>const m = new Map()</code></pre><p>嵌套数组进行映射：</p><pre><code>const a =new Map([['key1':'name1'],['key2':'name2']])</code></pre><p>遍历时：</p><pre><code>for(const i of mapp.values()){    console.log(i)  //这样说整个键值对}for(const i of mapp.keys()){    console.log(i)  //这样说values值，}</code></pre><p>由于for of是 遍历values,而for in是遍历keys，所以这时for in无法使用</p><h4 id="注意values，与-keys值不可变化"><a href="#注意values，与-keys值不可变化" class="headerlink" title="注意values，与 keys值不可变化"></a>注意values，与 keys值不可变化</h4><h2 id="2、基础操作"><a href="#2、基础操作" class="headerlink" title="2、基础操作"></a>2、基础操作</h2><h3 id="1-set增加"><a href="#1-set增加" class="headerlink" title="(1)set增加"></a>(1)set增加</h3><pre><code>mapp.set('key23','name23')</code></pre><p>当然了也可以直接进行链式操作，.set().set()</p><h3 id="2-删除-delete-与clear（）"><a href="#2-删除-delete-与clear（）" class="headerlink" title="(2)删除 delete()与clear（）"></a>(2)删除 delete()与clear（）</h3><pre><code>mapp.delete('key1')  //仅删除一个mapp.clear()  全部删除</code></pre><h3 id="3-查找get（）与has（）"><a href="#3-查找get（）与has（）" class="headerlink" title="(3)查找get（）与has（）"></a>(3)查找get（）与has（）</h3><pre><code>mapp.has('key1')   //这是判断有无mapp.get('keys')   //这是找values值</code></pre><p>无法直接进行查询：</p><pre><code>console.log(mapp['key1'])   //不行----undefined</code></pre><p>注意映射中的内部引用<strong>无法修改！！！</strong>，且他们的keys键值也无法修改</p><pre><code>mapp.set('key23','name23')for(let i of mapp.values()){     i = '2323'    console.log(i)  // 2323}</code></pre><p>  console.log(mapp.get(‘key1’))  //name23</p><p>且values也是同理</p><p>但是他们如果是一个对象时，可以改变其对象属性：</p><pre><code>key12 = {name:'sadasd'}const mapp = new Map([    [key12,name1],    ])    key12.name= '1212'之后key12内部属性，就会变化</code></pre><h2 id="3、迭代器"><a href="#3、迭代器" class="headerlink" title="3、迭代器"></a>3、迭代器</h2><p>映射实例会提供迭代器</p><pre><code>let ma = new Map([    ['name','keys'],    ['name1','keyser'],    ['name2','keys2'],])   //如果重名,按照最先出现的,且迭代就显示一个for(let i of ma){    console.log(i)}// 把映射变为数组console.log([...ma])</code></pre><h3 id="注意map与object作为键值时区别为"><a href="#注意map与object作为键值时区别为" class="headerlink" title="注意map与object作为键值时区别为"></a>注意map与object作为键值时区别为</h3><p>（1）object只能以数值，字符串或符号作为键，而map可以用JS任意类型</p><p>（2）之后就是属性值的改变问题</p><p>（3）Map会维护键值对的插入顺序，可以根据插入顺序进行迭代</p><p>在选择上，只有有大量查找时，object要由于map，其余无论是插入或是内存，删除，都是map优一点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、定型数组&quot;&gt;&lt;a href=&quot;#一、定型数组&quot; class=&quot;headerlink&quot; title=&quot;一、定型数组&quot;&gt;&lt;/a&gt;一、定型数组&lt;/h1&gt;&lt;h2 id=&quot;1、作用&quot;&gt;&lt;a href=&quot;#1、作用&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="js学习" scheme="https://useritem.github.io/categories/js%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>js学习5</title>
    <link href="https://useritem.github.io/2021/04/07/js%E5%AD%A6%E4%B9%A0/js%E5%AD%A6%E4%B9%A05/"/>
    <id>https://useritem.github.io/2021/04/07/js%E5%AD%A6%E4%B9%A0/js%E5%AD%A6%E4%B9%A05/</id>
    <published>2021-04-07T13:20:07.000Z</published>
    <updated>2021-04-07T13:21:17.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、substring（）方法"><a href="#1、substring（）方法" class="headerlink" title="1、substring（）方法"></a>1、substring（）方法</h2><p>作用：用于截取指定位置的字符串并返回</p><pre><code>  var s1 = 'some test'console.log(s1.substring(1,3))   //om</code></pre><p>注意虽然s1是原始值，本身不是对象，本身应该不具有方法，但是在执行的过程中，实际执行了三步：</p><pre><code>（1）创建一个String类型的实例（2）调用实例上的特定方法（3）销毁实例</code></pre><p>这个叫做<strong>原始值包装类型</strong></p><p>与引用类型最大的区别在于生命周期，它仅仅在访问那行代码时，存在，且不能为其添加方法和属性</p><p>而引用类型则是在离开作用域时，销毁</p><p>当然，可以通过Boolean，Number,String构造函数创建原始值包装对象</p><h2 id="类似：slice（）与substr（）"><a href="#类似：slice（）与substr（）" class="headerlink" title="类似：slice（）与substr（）"></a>类似：slice（）与substr（）</h2><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><pre><code>  var s1 = 'some test'console.log(s1.slice(1,3))   //om</code></pre><p>与substring（）方法一样，两个参数分别代表第一个开始值和最后一个结束值</p><h3 id="substr（）"><a href="#substr（）" class="headerlink" title="substr（）"></a>substr（）</h3><pre><code> var s1 = 'some test'console.log(s1.substr(1,3))   //ome</code></pre><p>substr（）第一个参数表示的是开始位置，第二个参数表示的是字符<strong>数目</strong></p><h3 id="处理负数不同："><a href="#处理负数不同：" class="headerlink" title="处理负数不同："></a>处理负数不同：</h3><p>slice将所有的负数值，看作<strong>字符串长度+负数值</strong></p><p>substring则是将所有负数<strong>看作零</strong></p><p>substr是将第一个负数看作<strong>字符串长度+负数值</strong>，第二个看作<strong>零</strong></p><pre><code>var s1 = 'some test'       console.log(s1.slice(-2))    //stconsole.log(s1.substring(-3))  //some testconsole.log(s1.substr(2,-3))  // ''</code></pre><h2 id="2、indexof-方法"><a href="#2、indexof-方法" class="headerlink" title="2、indexof()方法"></a>2、indexof()方法</h2><p>indexof()与lastindexof（）一个是返回第一个找到的位置，一个是返回最后一个找到的位置</p><pre><code>let aaa = 'asdasdasdwfasdf'console.log(aaa.indexOf('a'))     //0console.log(aaa.lastIndexOf('a'))   //11</code></pre><p>可以传入第二个参数a表示开始的位置，indexof（）从a往后找，lastindexof往前找</p><pre><code> let aaa = 'asdasdasdwfasdf'console.log(aaa.indexOf('a',7))     //11console.log(aaa.lastIndexOf('a',7))   //6</code></pre><p>所以可以利用递归获得所有位置</p><h1 id="3、全局上下文"><a href="#3、全局上下文" class="headerlink" title="3、全局上下文"></a>3、全局上下文</h1><p>注意全局上下文具有两个内置对象，一个是global对象，但是它不能<strong>直接进行访问</strong>，ECMAscript没有！</p><p>所以window对象可以作为global对象的<strong>代理</strong>，所有的全局变量与函数都是它的方法</p><h2 id="global的UML方法"><a href="#global的UML方法" class="headerlink" title="global的UML方法"></a>global的UML方法</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>用于编码统一资源标识符，以便传给浏览器</p><p>注意有效的URI不能包含某些字符，比如空格（替换为%20）</p><h3 id="编码方法："><a href="#编码方法：" class="headerlink" title="编码方法："></a>编码方法：</h3><h3 id="encodeURI（）与-encodeURIComponent"><a href="#encodeURI（）与-encodeURIComponent" class="headerlink" title="encodeURI（）与 encodeURIComponent()"></a>encodeURI（）与 encodeURIComponent()</h3><p>encodeURI（）主要对整个URI进行编码，它<strong>不会编码属于URI组件的特殊字符</strong>，比如，冒号，井号</p><p>encodeURIComponent()主要用于编码URI中的单独的组件，它会编码</p><p>样例：</p><pre><code>let url = 'http://localhost:8000/ user/login?mobile=” 22222222222 “&amp;password=”111“'console.log(encodeURI(url))console.log(encodeURIComponent(url))</code></pre><p>答案：</p><p><a href="https://imgtu.com/i/c17Rtf"><img src="https://z3.ax1x.com/2021/04/06/c17Rtf.png" alt="c17Rtf.png"></a></p><p>当然与他们相对应的是decodeURI（）与decodeURIComponent（）函数：</p><pre><code> var uri = 'http://localhost:8000/%20user/login?mobile=%E2%80%9D%2022222222222%20%E2%80%9C&amp;password=%E2%80%9D111%E2%80%9C'console.log(decodeURI(uri))console.log(decodeURIComponent(uri))</code></pre><p>注意decodeURIComponent可以<strong>全部进行解码</strong></p><p>而decodeURI<strong>只能解码</strong>被decodeURI（）进行编码的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、substring（）方法&quot;&gt;&lt;a href=&quot;#1、substring（）方法&quot; class=&quot;headerlink&quot; title=&quot;1、substring（）方法&quot;&gt;&lt;/a&gt;1、substring（）方法&lt;/h2&gt;&lt;p&gt;作用：用于截取指定位置的字符串并返回</summary>
      
    
    
    
    <category term="js学习" scheme="https://useritem.github.io/categories/js%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>js学习4</title>
    <link href="https://useritem.github.io/2021/04/04/js%E5%AD%A6%E4%B9%A0/js%E5%AD%A6%E4%B9%A04/"/>
    <id>https://useritem.github.io/2021/04/04/js%E5%AD%A6%E4%B9%A0/js%E5%AD%A6%E4%B9%A04/</id>
    <published>2021-04-04T14:21:32.000Z</published>
    <updated>2021-04-04T14:22:44.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、sort函数"><a href="#1、sort函数" class="headerlink" title="1、sort函数"></a>1、sort函数</h2><h3 id="（1）无参的情况：按照字符编码的顺序进行排序"><a href="#（1）无参的情况：按照字符编码的顺序进行排序" class="headerlink" title="（1）无参的情况：按照字符编码的顺序进行排序"></a>（1）无参的情况：按照字符编码的顺序进行排序</h3><pre><code>    var arr = ['General','Tom','Bob','John','Army'];    var resArr = arr.sort();    console.log(resArr);//输出   ["Army", "Bob", "General", "John", "Tom"]        var arr2 = [30,10,111,35,1899,50,45];    var resArr2 = arr2.sort();    console.log(resArr2);//输出   [10, 111, 1899, 30, 35, 45, 50]</code></pre><h3 id="（2）有参升序"><a href="#（2）有参升序" class="headerlink" title="（2）有参升序"></a>（2）有参升序</h3><pre><code>    var arr3 = [30,10,111,35,1899,50,45];    arr3.sort(function(a,b){        return a - b;    })    console.log(arr3);//输出  [10, 30, 35, 45, 50, 111, 1899]</code></pre><h3 id="（3）有参降序"><a href="#（3）有参降序" class="headerlink" title="（3）有参降序"></a>（3）有参降序</h3><pre><code>    var arr4 = [30,10,111,35,1899,50,45];    arr4.sort((a,b)=&gt;b - a)    console.log(arr4);//输出 [1899, 111, 50, 45, 35, 30, 10]</code></pre><p>注意a在开始，要是a-b就是升序，（瞎理解为因为a是开始，所以就升。。。）</p><h2 id="2、with语句"><a href="#2、with语句" class="headerlink" title="2、with语句"></a>2、with语句</h2><p>主要用于将代码作用域设为<strong>特定对象</strong></p><pre><code>var a =12var c = 23var obj = {    a:'a',    b:'b',    c:'cc'}with(obj){    console.log(a)    //a    console.log(c)   //cc}</code></pre><p>‘<br>with之后每个变量被认为是一个局部变量，没有该局部变量，就从obj中搜索该属性</p><p>注意当函数里面使用with时，其作用域还在with中，并且在with中的定义的，只能用obj.访问</p><p>且是undefined，直接访问会报错，且obj中也没有新定义的东西</p><pre><code>function fun(){    var a = '12233'    with(obj){        console.log(a)          console.log(c)        let obj1 = '23'        var obj2 = '34'        const obj3 = '455'    }    console.log(obj.obj1)   //undefined    console.log(obj.obj2) //undefined    console.log(obj.obj3) //undefined}fun()// console.log(obj2)    //报错console.log(obj.obj1) //undefinedconsole.log(obj.obj2) //undefinedconsole.log(obj.obj3) //undefinedconsole.log(obj)   //{ a: 'a', b: 'b', c: 'cc' }</code></pre><h2 id="3、typeof与instanceof应用"><a href="#3、typeof与instanceof应用" class="headerlink" title="3、typeof与instanceof应用"></a>3、typeof与instanceof应用</h2><h3 id="1-typeof（）"><a href="#1-typeof（）" class="headerlink" title="(1)typeof（）"></a>(1)typeof（）</h3><p>确定值的<strong>原始类型</strong></p><p>. typeof的返回值</p><pre><code>typeof运算符的返回类型为字符串，值包括如下几种：    1. 'undefined'              --未定义的变量或值    2. 'boolean'                 --布尔类型的变量或值    3. 'string'                     --字符串类型的变量或值    4. 'number'                  --数字类型的变量或值    5. 'object'                    --对象类型的变量或值，或者null(这个是js历史遗留问题，将null作为object类型处理)    6. 'function'                 --函数类型的变量或值</code></pre><p>样例：</p><pre><code>console.log(typeof(true));  //'boolean'console.log(typeof '123');  //'string'</code></pre><h3 id="1-instanceof（）"><a href="#1-instanceof（）" class="headerlink" title="(1)instanceof（）"></a>(1)instanceof（）</h3><p>判断值的<strong>引用类型</strong>，也就是检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</p><pre><code>var simpleStr = "This is a simple string"; var myString  = new String();var newStr    = new String("String created with constructor");var myDate    = new Date();var myObj     = {};    var myNonObj  = Object.create(null);simpleStr instanceof String; // 返回 false, simpleStr并不是对象myString  instanceof String; // 返回 truenewStr    instanceof String; // 返回 truemyString  instanceof Object; // 返回 true myObj instanceof Object;    // 返回 true, 尽管原型没有定义({})  instanceof Object;    // 返回 true, 同上myNonObj instanceof Object; // 返回 false, 一种创建非 Object 实例的对象的方法     myString instanceof Date; // 返回 false myDate instanceof Date;     // 返回 truemyDate instanceof Object;   // 返回 truemyDate instanceof String;   // 返回 false</code></pre><p>它的手动实现：</p><pre><code>function myInstanceof (left, right) {// 基本数据类型直接返回falseif (typeof left !== 'object' || left === null) return false// getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象let proto = Object.getPrototypeOf(left)while (true) {    // 查找到尽头，还没找到    if (proto == null) return false    // 找到相同的原型对象    if (proto == right.prototype) return true    proto = Object.getPrototypeOf(proto)}}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、sort函数&quot;&gt;&lt;a href=&quot;#1、sort函数&quot; class=&quot;headerlink&quot; title=&quot;1、sort函数&quot;&gt;&lt;/a&gt;1、sort函数&lt;/h2&gt;&lt;h3 id=&quot;（1）无参的情况：按照字符编码的顺序进行排序&quot;&gt;&lt;a href=&quot;#（1）无参的情</summary>
      
    
    
    
    <category term="js学习" scheme="https://useritem.github.io/categories/js%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>扩展运算符与深拷贝</title>
    <link href="https://useritem.github.io/2021/04/03/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://useritem.github.io/2021/04/03/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2021-04-03T12:15:47.000Z</published>
    <updated>2021-04-03T12:18:12.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、扩展运算符-…"><a href="#1、扩展运算符-…" class="headerlink" title="1、扩展运算符 …"></a>1、扩展运算符 …</h1><h2 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h2><p>三个点（…）真名叫扩展运算符，是在ES6中新增加的内容，它可以在函数调用/数组构造时，将数组表达式或者string在<strong>语法层面展开</strong>；还可以在构造字面量对象时将对象表达式按照key-value的方式展开</p><pre><code>字面量一般指[1,2,3]或者{name:'chuichui'}这种简洁的构造方式,多层嵌套的数组和对象三个点就无能为力了</code></pre><p>样例：</p><pre><code>var obj = {    a:{        b:'c',        d:'d'    }}var obj1 = {    b:'b'}console.log({...obj})                a:{b:'c',d:'d'}console.log({...obj1})               {b:'b'}var number = [1,2,3,4,5,6]console.log(...number) //1 2 3 4 5 6</code></pre><p>可以理解为把外层的衣服脱掉，比如脱掉外面的obj1</p><h2 id="（2）应用"><a href="#（2）应用" class="headerlink" title="（2）应用"></a>（2）应用</h2><h3 id="a、复制作用："><a href="#a、复制作用：" class="headerlink" title="a、复制作用："></a>a、复制作用：</h3><pre><code>//数组的复制var arr1 = ['hello']var arr2 =[...arr1]arr2 // ['hello']//对象的复制var obj1 = {name:'chuichui'}var obj2 ={...arr}ob12 //  {name:'chuichui'}</code></pre><h3 id="b、合并作用"><a href="#b、合并作用" class="headerlink" title="b、合并作用"></a>b、合并作用</h3><pre><code>//数组的合并var arr1 = ['hello']var arr2 =['chuichui']var mergeArr = [...arr1,...arr2]mergeArr  // ['hello','chuichui']// 对象分合并var obj1 = {name:'chuichui'}var obj2 = {height:176}var mergeObj = {...obj1,...obj2}mergeObj // {name: "chuichui", height: 176}</code></pre><h3 id="c、字符串转数组"><a href="#c、字符串转数组" class="headerlink" title="c、字符串转数组"></a>c、字符串转数组</h3><pre><code>var arr1 = [...'hello']arr1 // ["h", "e", "l", "l", "o"]</code></pre><p>注意扩展运算符外面的，表示转化之后的类型，[]就表示转化为数组</p><pre><code>function f(v,w,x,y,z){ }var args = [2,3]f(1,...args,4,...[5])由于这里展开了，所以相当于传入了1，2，3，4，5</code></pre><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>扩展运算符是实现的拷贝并不是<strong>完全</strong>的深拷贝:</p><pre><code>  var obj = {   a:'a',   b:[2,3]   }   var obj1 = obj   var obj2 = {...obj}   obj.a = 'b'   obj.b[1]=4   console.log(obj1.a)     //b   console.log(obj2.a)     //a   console.log( obj1.b[1])   //4   console.log( obj2.b[1])   //4</code></pre><p>所以这时候当其中的元素是<strong>一维元素</strong>是深拷贝，否则为浅拷贝</p><p>这类似于对象的</p><p>####Object.assign(target，…sources)方法：</p><p>把可枚举将所有可枚举属性的值从一个或多个源对象复制到目标对象，且<strong>返回目标对象</strong></p><pre><code>Object.assign(target, ...sources)</code></pre><p>target ： 目标对象</p><p>sources：源对象</p><pre><code>  var obj = {    name:'a',    info:{        b:'b',        c:'c'    }}let obj1 = Object.assign({},obj)obj.info.b = 'bb'console.log(obj1.info.b)    //bb</code></pre><p>数组的</p><p>####concat(arr1, arr2,….)连接并返回</p><p>当使用 a.concat(arr)时，注意a<strong>必须是数组</strong></p><p>后面的arr等等会拼接在a的<strong>后面</strong></p><p><a href="https://imgtu.com/i/cnxc1e"><img src="https://z3.ax1x.com/2021/04/03/cnxc1e.png" alt="cnxc1e.png"></a></p><h4 id="arr-slice-idx1-idx2-方法"><a href="#arr-slice-idx1-idx2-方法" class="headerlink" title="arr.slice(idx1, idx2)方法"></a>arr.slice(idx1, idx2)方法</h4><p>用于从数组读取从idx1到idx2部分，如果不加参数就是直接复制</p><p>当然了如果idx2大于等于arr.length</p><pre><code>   var obj = [1,2,3]   obj1 = obj   obj2 = obj.slice()   obj.push(4)   console.log(obj1)   //1.2.3.4   console.log(obj2)   //1,2,3</code></pre><h1 id="扩展：实现深拷贝"><a href="#扩展：实现深拷贝" class="headerlink" title="扩展：实现深拷贝"></a>扩展：实现深拷贝</h1><h2 id="1、递归方式："><a href="#1、递归方式：" class="headerlink" title="1、递归方式："></a>1、递归方式：</h2><pre><code> var obj = {    a: 'a',    b: [2, 3]}var obj3 = deepClone(obj)obj.b[1]=4console.log(obj3.b[1])   //4function deepClone(obj) {    let objClone = Array.isArray(obj) ? [] : {};    if (obj &amp;&amp; typeof obj === 'object') {        for (let key in obj) {            if (obj[key] &amp;&amp; typeof obj[key] === 'object') {                objClone[key] = deepClone(obj[key]);            } else {                objClone[key] = obj[key]            }        }    }    return objClone;}</code></pre><h2 id="2、json对象实现："><a href="#2、json对象实现：" class="headerlink" title="2、json对象实现："></a>2、json对象实现：</h2><pre><code>var obj = {    a: 'a',    b: [2, 3]}var obj1 = deepClone(obj)obj.b[1]=4console.log(obj1.b[1])   //4function deepClone2(obj) {      let _obj = JSON.stringify(obj),      return JSON.parse(_obj);}</code></pre><p>###JSON代码分析：</p><pre><code>JSON.stringify(obj) --- 先转化为json字符串：</code></pre><p>语法：</p><pre><code> JSON.stringify(value[, replacer[, space]])（后面一个参数一般不用）</code></pre><h4 id="value"><a href="#value" class="headerlink" title="value:"></a>value:</h4><p>必需， 要转换的 JavaScript 值（通常为对象或数组）。</p><p>####replacer:<br>可选。用于转换结果的函数或数组。</p><p>如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：””。</p><p>如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。</p><p>####space:<br>可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\t</p><pre><code>JSON.parse(_obj);  ---把JSON字符串转化为js对象</code></pre><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><pre><code>JSON.parse(text[, reviver])</code></pre><p>参数说明：</p><p>text:必需， 一个有效的 JSON 字符串。</p><p>reviver: 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、扩展运算符-…&quot;&gt;&lt;a href=&quot;#1、扩展运算符-…&quot; class=&quot;headerlink&quot; title=&quot;1、扩展运算符 …&quot;&gt;&lt;/a&gt;1、扩展运算符 …&lt;/h1&gt;&lt;h2 id=&quot;（1）介绍&quot;&gt;&lt;a href=&quot;#（1）介绍&quot; class=&quot;header</summary>
      
    
    
    
    <category term="js经典问题" scheme="https://useritem.github.io/categories/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>迭代器与生成器</title>
    <link href="https://useritem.github.io/2021/04/02/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://useritem.github.io/2021/04/02/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2021-04-02T05:10:46.000Z</published>
    <updated>2021-04-09T12:48:58.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h1><p>首先为了处理集合中的每一项，JS可以通过简单的for foreach,还有如下方法:</p><h3 id="map-："><a href="#map-：" class="headerlink" title="map()："></a>map()：</h3><pre><code>var numbers = [4, 9, 16, 25];function myFunction() {    x = document.getElementById("demo")    x.innerHTML = numbers.map(Math.sqrt);   /2，3，4，5}</code></pre><p>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p><p>map() 方法按照原始数组元素顺序依次处理元素。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><pre><code>var ages = [32, 33, 16, 40];function checkAdult(age) {    return age &gt;= 18;}function myFunction() {    document.getElementById("demo").innerHTML = ages.filter(checkAdult);}</code></pre><p>这是返回<strong>原数组中达到要求的数组</strong></p><h3 id="array-comprehensions-数组推导式"><a href="#array-comprehensions-数组推导式" class="headerlink" title="array comprehensions(数组推导式)"></a>array comprehensions(数组推导式)</h3><p>而且在JavaScript 1.7中，迭代器和生成器在JavaScript核心语法中带来了新的迭代机制，而且还提供了定制 for…in 和 for each 循环行为的机制。</p><h1 id="1、迭代器"><a href="#1、迭代器" class="headerlink" title="1、迭代器"></a>1、迭代器</h1><h2 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h2><p>是一个每次访问集合序列中一个<strong>元素的对象</strong>，并跟踪该序列中迭代的当前位置。</p><p>在JavaScript中迭代器是一个对象，这个对象提供了一个 next() 方法（必须实现），next() 方法返回序列中的下一个元素，即为IteratorReault对象。此对象具有value与done两个属性，一个表示值，一个表示是否结束：</p><pre><code>ab = [23,4,5]console.log(ab[Symbol.iterator]().next())  //{value: 23, done:false}</code></pre><p>当序列中所有元素都遍历完成时，该方法抛出 StopIteration 异常，done也变为true。</p><p>[Symbol.iterator]表示可迭代属性，可以作为一个工厂函数使用</p><p>迭代器对象一旦被建立，就可以通过显式的重复调用next()，或者使用JavaScript的 for…in 和 for each 循环隐式调用。</p><p>但是注意迭代器是一次性的!!!</p><pre><code>ab = [23,4,5] let s = ab[Symbol.iterator]()for(const i of s){    console.log(i)}console.log("-----")//这个s已经迭代完了，这就反映了迭代器的一次性遍历的特点for(const i of s){    console.log(i)}</code></pre><h2 id="（2）创建"><a href="#（2）创建" class="headerlink" title="（2）创建"></a>（2）创建</h2><p>简单的对对象和数组进行迭代的迭代器可以使用 [Symbol.iterator]工厂函数：</p><pre><code>let lang = [23,34]//var lang = { name: 'JavaScript', birthYear: 1995 };//对象是错误的var it = lang[Symbol.iterator];</code></pre><p>之后可以通过next进行操作</p><pre><code>var pair = it.next(); </code></pre><p>如果进想输出key值，则可以传入第二个参数</p><pre><code> var langs = ['JavaScript', 'Python', 'Haskell'];var it = langs[Symbol.iterator]();for (const pair of it){    console.log(pair); //每次迭代输出 [index, language]}</code></pre><p>此时把true当作<strong>数组索引</strong></p><p>##（3） 声明自定义迭代器</p><p>实现Iterable接口的类型有:</p><pre><code>字符串数组映射集合arguments对象NodeList等DOM集合类型</code></pre><h3 id="注意-没有Object"><a href="#注意-没有Object" class="headerlink" title="注意:没有Object"></a>注意:没有Object</h3><p>##（4）声明自定义迭代器</p><p>一些代表元素集合的对象应该用一种指定的方式来迭代。例如：</p><p>1.迭代一个表示范围(Range)的对象应该一个接一个的返回这个范围包含的数字</p><p>2.一个树的叶子节点可以使用深度优先或者广度优先访问到</p><p>3.迭代一个代表数据库查询结果的对象应该一行一行的返回，即使整个结果集尚未全部加载到一个单一数组</p><p>4.作用在一个无限数学序列(像斐波那契序列)上的迭代器应该在不创建无限长度数据结构的前提下一个接一个的返回结果</p><p>JavaScript 允许你写<strong>自定义迭代逻辑</strong>的代码，并把它作用在一个对象上</p><h3 id="迭代器缺点："><a href="#迭代器缺点：" class="headerlink" title="迭代器缺点："></a>迭代器缺点：</h3><p>虽然自定义的迭代器是一种很有用的工具，但是创建它们的时候要仔细规划，因为需要显式的维护它们的内部状态。于是我们引入了：</p><h1 id="2、生成器（创建迭代器的更好的方式）"><a href="#2、生成器（创建迭代器的更好的方式）" class="headerlink" title="2、生成器（创建迭代器的更好的方式）"></a>2、生成器（创建迭代器的更好的方式）</h1><p>生成器提供了很强大的功能：它允许你定义一个包含自有迭代算法的函数， 同时它可以<strong>自动维护</strong>自己的状态。</p><p>(因为它的默认的迭代器是自引用的)</p><p>生成器形式是一个函数,函数名称前面加”星号”即可,<strong>只要是自定义函数的地方,就可以定义生成器</strong>,除非是箭头函数</p><pre><code>let try = function *(){}</code></pre><h2 id="1-执行过程"><a href="#1-执行过程" class="headerlink" title="(1) 执行过程"></a>(1) 执行过程</h2><p>调用生成器函数会产生生成器对象,其一开始为暂停状态,它也有Iterator接口和next方法,这个next方法是其<strong>开始的标志</strong>.</p><pre><code>function* gen(){    console.log('lala')    return '1'}let as = gen()as.next()生成器函数初次只有在用next之后才会开始</code></pre><p>且next()返回值类似于迭代器,也是value与done,value表示的是函数的返回值</p><h3 id="yeild—-停止生成器直到下次next"><a href="#yeild—-停止生成器直到下次next" class="headerlink" title="yeild—-停止生成器直到下次next"></a>yeild—-停止生成器直到下次next</h3><p>每次调用 generator-iterator 的 next() 方法，函数体就会执行到下一个 yield 表达式，然后返回它的结果。</p><div style="color: red; font-size: 16px;">使用yield关键字退出的生成器会在done:flase的状态,而return出去的则是 done:true</div><p>当函数结束或者碰到 return 语句，一个 StopIteration 异常会被抛出。 例子：</p><p>function *simpleGenerator(){<br>      yield “first”;<br>      yield “second”;<br>      yield “third”;<br>      for (var i = 0; i &lt; 3; i++)<br>        yield i;<br>    }</p><pre><code>var g = simpleGenerator();console.log(g.next()); //输出 "first",done:falseconsole.log(g.next()); //输出 "second"done:falseconsole.log(g.next()); //输出 "third"done:falseconsole.log(g.next()); //输出 0,done:falseconsole.log(g.next()); //输出 1,done:falseconsole.log(g.next()); //输出 2,done:falseconsole.log(g.next()); //抛出 StopIteration 异常</code></pre><h3 id="注意-1-yield必须直接位于生成器定义函数中-不可嵌套"><a href="#注意-1-yield必须直接位于生成器定义函数中-不可嵌套" class="headerlink" title="注意:1.yield必须直接位于生成器定义函数中,不可嵌套"></a>注意:1.yield必须直接位于生成器定义函数中,不可嵌套</h3><pre><code>function* fun(){    function a(){    yield   ---无效    }        }     </code></pre><h3 id="2-yield可以用于输入输出"><a href="#2-yield可以用于输入输出" class="headerlink" title="2.yield可以用于输入输出"></a>2.yield可以用于输入输出</h3><p>yeild会接收给next方法的第一个值,但是<strong>第一次调用next()时,里面的值,不会被调用,相当于开始执行</strong></p><pre><code> function* gens(lala){    console.log(lala)//如果第一个就输出yield则啥都没有    console.log(yield)    console.log(yield)}let gun = gens('foo')gun.next('123')  //foogun.next('555')    //555gun.next('52353255')   //52353255</code></pre><p>作为输入与输出的yield</p><pre><code> function * fun(){    return yield 'foo'    // 这个foo相当于开始第一个参数，由于第一个next无效}let aaaa = fun()console.log(aaaa.next('asdsad')) //第一个参数没有用console.log(aaaa.next('asd'))</code></pre><h3 id="（3）高级特性-yield参数的加强—星号"><a href="#（3）高级特性-yield参数的加强—星号" class="headerlink" title="（3）高级特性 yield参数的加强—星号"></a>（3）高级特性 yield参数的加强—星号</h3><p>当使用星号加强时,使其可以迭代一个可迭代对象,从而产出一个值</p><pre><code>  function* ntimes(n){    if(n&gt;0){        yield* ntimes(n-1); //实例话对象        yield n-1;    //减少值,也先当于打印返回    }}for(const i of ntimes(4)){        console.log(i)  //0 1 2 3    }</code></pre><h3 id="4-关闭"><a href="#4-关闭" class="headerlink" title="4.关闭"></a>4.关闭</h3><p>生成器的关闭方式有return(),throw(),next()!!</p><h4 id="对于return-方法"><a href="#对于return-方法" class="headerlink" title="对于return()方法"></a>对于return()方法</h4><p>对于它提供的值,就是<strong>终止对象的值</strong>,且之后再执行next(),只会改变done状态,但是value值<strong>不会传播</strong></p><pre><code>function* fun(){    for(const x of [2,3,4,5]){        yield x    }}const x = fun()console.log(x.next())   //{value: 2, done: false}console.log(x.return(4))   //{value: 4, done: true}console.log(x.next())      //{value: undefined, done: true}</code></pre><h4 id="对于throw-方法"><a href="#对于throw-方法" class="headerlink" title="对于throw()方法"></a>对于throw()方法</h4><p>它是往其中放置错误,如果错误被解决则可进行,但是会跳过本次yield值,否则则关闭</p><pre><code>function* gen(){    for(const i of [2,3,4,5,45]){        try{            yield i;        }catch(e){            console.log(e)        }    }}const g = gen()    console.log(g.next())  //2     g.throw('fooo')   //catch得到打印为fooo    console.log(g.next())   //4</code></pre><p>yield</p><h2 id="扩展：基础Iterator的原生实现"><a href="#扩展：基础Iterator的原生实现" class="headerlink" title="扩展：基础Iterator的原生实现"></a>扩展：基础Iterator的原生实现</h2><pre><code>function myIterator(arr) {let index = 0;return {    next() {        return index &lt; arr.length ? {            value: arr[index++],            done: false//可以省略        } : {            value: undefined,//可以省略            done: true        }    }}}const it = myIterator([1, 2])console.log(it.next());// {value: 1, done: false}console.log(it.next());// {value: 2, done: false}console.log(it.next());// {value: undefined, done: true}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;迭代器与生成器&quot;&gt;&lt;a href=&quot;#迭代器与生成器&quot; class=&quot;headerlink&quot; title=&quot;迭代器与生成器&quot;&gt;&lt;/a&gt;迭代器与生成器&lt;/h1&gt;&lt;p&gt;首先为了处理集合中的每一项，JS可以通过简单的for foreach,还有如下方法:&lt;/p&gt;
&lt;h3</summary>
      
    
    
    
    <category term="js经典问题" scheme="https://useritem.github.io/categories/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
</feed>
