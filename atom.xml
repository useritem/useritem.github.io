<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hb的博客站</title>
  
  
  <link href="https://useritem.github.io/atom.xml" rel="self"/>
  
  <link href="https://useritem.github.io/"/>
  <updated>2021-07-06T14:28:08.428Z</updated>
  <id>https://useritem.github.io/</id>
  
  <author>
    <name>〃不枉俗尘づ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组件初始化</title>
    <link href="https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/vue.js%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E7%BB%84%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/vue.js%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E7%BB%84%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2021-07-06T14:19:32.000Z</published>
    <updated>2021-07-06T14:28:08.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="setup组件渲染流程"><a href="#setup组件渲染流程" class="headerlink" title="setup组件渲染流程"></a>setup组件渲染流程</h1><h2 id="一、分析介绍大致流程"><a href="#一、分析介绍大致流程" class="headerlink" title="一、分析介绍大致流程"></a>一、分析介绍大致流程</h2><p>主要是对vnode的渲染过程进行分析，也就是在挂载组件，步骤主要为—</p><p>1、创建组件实例</p><pre><code>const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense))</code></pre><p>2、设置组件实例</p><pre><code>setupComponent(instance)</code></pre><p>3、设置并运行带副作用的渲染函数  — 这里不做讨论</p><pre><code>setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)</code></pre><h2 id="二、1创建组件实例-createComponentInstance方法"><a href="#二、1创建组件实例-createComponentInstance方法" class="headerlink" title="二、1创建组件实例 createComponentInstance方法"></a>二、1创建组件实例 createComponentInstance方法</h2><p>该方法主要是对<strong>instance对象</strong>的创建与属性的定义，主要的属性分为</p><pre><code>setupState: EMPTY_OBJ,   --- setup 函数返回的响应式结果 // data 数据data: EMPTY_OBJ,// props 数据props: EMPTY_OBJ,instance.ctx = { _: instance }   ----  初始化渲染上下文</code></pre><h2 id="三、2设置组件实例"><a href="#三、2设置组件实例" class="headerlink" title="三、2设置组件实例"></a>三、2设置组件实例</h2><p>这里也就是对setup 函数的处理，即为setupComponent 方法的实现</p><p>代码具体如下：</p><pre><code>function setupComponent (instance, isSSR = false) {    //组件 vnode 中获取了 props、children、shapeFlag 等属性      const { props, children, shapeFlag } = instance.vnode      // 判断是否是一个有状态的组件      const isStateful = shapeFlag &amp; 4      // 初始化 props      initProps(instance, props, isStateful, isSSR)      // 初始化 插槽      initSlots(instance, children)      // 设置有状态的组件实例      const setupResult = isStateful    ? setupStatefulComponent(instance, isSSR)        : undefined      return setupResult}</code></pre><p>函数主要的作用在于属性的获取与其对应的初始化，以及</p><p>设置有状态的组件实例setupStatefulComponent函数</p><p>其主要功能同样也是三步：</p><ul><li>1、创建渲染上下文代理。</li><li>2、判断处理 setup 函数</li><li>3、完成组件实例设置</li></ul><p>接下来再对这三步进行具体分析</p><h3 id="1-创建渲染上下文代理"><a href="#1-创建渲染上下文代理" class="headerlink" title="1.创建渲染上下文代理"></a>1.创建渲染上下文代理</h3><p>创建渲染上下文代理流程，主要对 instance.ctx 做了代理，也就是<strong>初始化上下文部分</strong>进行代理</p><h4 id="扩展：代理的原因"><a href="#扩展：代理的原因" class="headerlink" title="扩展：代理的原因"></a>扩展：代理的原因</h4><p>首先vue2.0中的data中的数据主要存储在this._data上，所以当模板渲染的时候访问 this.msg，实际上访问的是 <strong>this._data.msg</strong>，这是因为 Vue.js 2.x 在初始化 data 的时候，做了一层 proxy 代理。</p><p>于是，在到了 Vue.js 3.0，为了方便维护，我们把组件中不同状态的数据存储到不同的属性中，比如存储到 setupState、ctx、data、props 中。</p><p>我们在执行组件渲染函数的时候，为了方便用户使用，会直接访问渲染上下文 <strong>instance.ctx</strong> 中的属性，所以我们也要做一层 proxy，对渲染上下文 instance.ctx 属性的访问和修改，代理到对 setupState、ctx、data、props 中的数据的访问和修改。</p><p>代理proxy的主要方法也就是 — get，set，has。于是我们又又又分析下面三个方法，主要原理就是想的一样。</p><h4 id="1、get方法"><a href="#1、get方法" class="headerlink" title="1、get方法"></a>1、get方法</h4><p>当我们一访问 instance.ctx 渲染上下文中的属性时，立刻进入get函数</p><p>其中get方法的主要在于判断key的开头方式，重点在于顺序的确定：</p><p>首先判断以 $ 开头，否则就依次判断 setupState、data、props、ctx 中是否包含这个 key，如果包含就返回对应值。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>这个判断顺序很重要，在 key 相同时它会决定数据获取的<strong>优先级</strong></p><h4 id="2、set方法"><a href="#2、set方法" class="headerlink" title="2、set方法"></a>2、set方法</h4><p>当我们修改 instance.ctx 渲染上下文中的属性的时 — set方法</p><p>仍然要注意顺序问题，和 get 一样，优先判断 setupState，然后是 data，接着是 props。</p><h4 id="3、has方法"><a href="#3、has方法" class="headerlink" title="3、has方法"></a>3、has方法</h4><p>判断属性是否存在于 instance.ctx 渲染上下文中时，就会进入 has 函数。</p><p>使用比较少</p><p>接下来我们才回到 setupStatefulComponent 函数中</p><h3 id="2、判断处理-setup-函数"><a href="#2、判断处理-setup-函数" class="headerlink" title="2、判断处理 setup 函数"></a>2、判断处理 setup 函数</h3><p>逻辑代码为：</p><pre><code>// 判断处理 setup 函数const { setup } = Componentif (setup) {      // 如果 setup 函数带参数，则创建一个 setupContext      const setupContext = (instance.setupContext =        setup.length &gt; 1 ? createSetupContext(instance) : null)      // 执行 setup 函数获取结果      const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [instance.props, setupContext])      // 处理 setup 执行结果      handleSetupResult(instance, setupResult)</code></pre><p>}</p><p>同样如上所示为三步：创建 setup 函数上下文、执行 setup 函数并获取结果和处理 setup 函数的执行结果</p><p>1、createSetupContext 函数来创建 setupContext</p><pre><code>function createSetupContext (instance) {      return {            attrs: instance.attrs,         slots: instance.slots,         emit: instance.emit  }}</code></pre><p>就是返回了一个对象，包括 attrs、slots 和 emit 三个属性。  </p><p>2、执行 setup 函数并获取结果：</p><pre><code>const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [instance.props, setupContext])</code></pre><p>3、用 handleSetupResult 函数来处理结果</p><pre><code>handleSetupResult(instance, setupResult) {  if (isFunction(setupResult)) {    // setup 返回渲染函数    instance.render = setupResult  }  else if (isObject(setupResult)) {        // 把 setup 返回结果变成响应式    instance.setupState = reactive(setupResult)}  finishComponentSetup(instance)}</code></pre><p>此外 setup 不仅仅支持返回一个对象，也可以返回一个函数作为组件的渲染函数，并且在 handleSetupResult 的最后，会执行 finishComponentSetup 函数完成组件实例的设置。</p><p>当组件没有定义的 setup 的时候，也会执行 finishComponentSetup 函数去完成组件实例的设置。</p><h3 id="3、完成组件实例设置"><a href="#3、完成组件实例设置" class="headerlink" title="3、完成组件实例设置"></a>3、完成组件实例设置</h3><p>也就是finishComponentSetup 函数的实现，主要作用就是</p><p>标准化模板或者渲染函数 和 兼容 Options API</p><p>对于兼容 Options API，大家比较属性，主要就是对兼容 Vue.js 2.x的兼容，主要是applyOptions方法实现，所以重点说 — </p><h4 id="标准化模板"><a href="#标准化模板" class="headerlink" title="标准化模板"></a>标准化模板</h4><h5 id="问题由来：版本问题"><a href="#问题由来：版本问题" class="headerlink" title="问题由来：版本问题"></a>问题由来：版本问题</h5><p>由于在一些古老的项目中有些开发方式不适用webpack编译，直接引用vue.js</p><p>因此 Vue.js 在 Web 端有两个版本：runtime-only 和 runtime-compiled。我们更推荐用 runtime-only 版本的 Vue.js，因为相对而言它体积更小，而且在运行时不用编译，不仅耗时更少而且性能更优秀。遇到一些不得已的情况比如上述提到的古老项目，我们也可以选择 runtime-compiled 版本。</p><p>runtime-only 和 runtime-compiled 的主要区别在于是否注册了这个 compile 方法。</p><h6 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h6><p>首先看 instance.render 是否存在，如果不存在则开始标准化流程，处理以下三种情况：</p><ul><li>情况一：compile 和组件 template 属性存在，render 方法不存在的情况。此时， runtime-compiled 版本会在 JavaScript 运行时进行模板编译，生成 render 函数。 ———–新</li><li>情况二：compile 和 render 方法不存在，组件 template 属性存在的情况。此时由于没有 compile，这里用的是 runtime-only 版本（老），因此要报一个警告来告 诉用户，想要运行时编译得使用 runtime-compiled 版本的 Vue.js。      —————老</li><li>情况三：组件既没有写 render 函数，也没有写 template 模板，此时要报一个警告，告诉用户组件缺少了 render 函数或者 template 模板。    —————-缺</li></ul><p>之后就要把组件的 render 函数赋值给 instance.render。到了组件渲染的时候，就可以运行 instance.render 函数生成组件的子树 vnode 了。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>Vue.js 3.0 组件的初始化流程：</p><p><a href="https://imgtu.com/i/RYLeOK"><img src="https://z3.ax1x.com/2021/06/27/RYLeOK.png" alt="RYLeOK.png"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;setup组件渲染流程&quot;&gt;&lt;a href=&quot;#setup组件渲染流程&quot; class=&quot;headerlink&quot; title=&quot;setup组件渲染流程&quot;&gt;&lt;/a&gt;setup组件渲染流程&lt;/h1&gt;&lt;h2 id=&quot;一、分析介绍大致流程&quot;&gt;&lt;a href=&quot;#一、分析介绍大</summary>
      
    
    
    
    <category term="vue3.0源码简析" scheme="https://useritem.github.io/categories/vue3-0%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    
    
    <category term="vue3.0核心组件实现" scheme="https://useritem.github.io/tags/vue3-0%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>组件问题 - 组件渲染</title>
    <link href="https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/vue.js%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E7%BB%84%E4%BB%B6%E9%97%AE%E9%A2%98-%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93/"/>
    <id>https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/vue.js%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E7%BB%84%E4%BB%B6%E9%97%AE%E9%A2%98-%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93/</id>
    <published>2021-07-06T14:18:03.000Z</published>
    <updated>2021-07-06T14:28:08.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言：介绍"><a href="#前言：介绍" class="headerlink" title="前言：介绍"></a>前言：介绍</h2><p>组件是一个抽象的概念，它是对一棵 DOM 树的抽象，当我们写一个组件节点时：</p><pre><code>&lt;hello-world&gt;&lt;/hello-world&gt;</code></pre><p>它具体渲染成什么与编写子组件模板的方式决定的</p><p>组件渲染过程！</p><p><a href="https://imgtu.com/i/RZyIvq"><img src="https://z3.ax1x.com/2021/06/22/RZyIvq.png" alt="RZyIvq.png"></a></p><p>vnode可以简单理解为— 可以简单描述组件的JS对象</p><h1 id="组件渲染问题"><a href="#组件渲染问题" class="headerlink" title="组件渲染问题"></a>组件渲染问题</h1><h2 id="一、vue3-0的改变"><a href="#一、vue3-0的改变" class="headerlink" title="一、vue3.0的改变"></a>一、vue3.0的改变</h2><p>首先需要注意的是：Vue.js 3.0 初始化应用的方式和 Vue.js 2.x 差别并不大，本质上都是把 App 组件挂载到 id 为 app 的 DOM 节点上。</p><p>其中vue3.0如下：</p><pre><code>// 在 Vue.js 3.0 中，初始化一个应用的方式如下import { createApp } from 'vue'import App from './app'const app = createApp(App)app.mount('#app')</code></pre><p>重要是多了一个createApp，其重点在于：</p><p><strong>创建app对象与重写mount方法</strong></p><p>其中在整个 app 对象创建过程中，Vue.js 利用闭包和函数柯里化（是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术）的技巧</p><p>从 app.mount 开始，才算真正进入组件渲染流程，那么接下来，我们就重点看一下核心渲染流程做的两件事情：创建 vnode 和渲染 vnode。</p><h2 id="二、创建vnode"><a href="#二、创建vnode" class="headerlink" title="二、创建vnode"></a>二、创建vnode</h2><p>vnode 本质上是用来描述 DOM 的 JavaScript 对象，它在 Vue.js 中可以描述不同类型的节点，比如普通元素节点、组件节点等。</p><p>普通节点可以理解为一个<strong>真实的DOM</strong>，而组件节点就表示组件</p><h3 id="普通节点："><a href="#普通节点：" class="headerlink" title="普通节点："></a>普通节点：</h3><pre><code>&lt;button class="btn" style="width:100px;height:50px"&gt;click me&lt;/button&gt;</code></pre><p>vnode表示：</p><pre><code>const vnode = {  type: 'button',  //标签属性  props: {      //DOM的附加信息    'class': 'btn',    style: {      width: '100px',      height: '50px'    }  },  children: 'click me'   //子节点}</code></pre><h3 id="组件节点："><a href="#组件节点：" class="headerlink" title="组件节点："></a>组件节点：</h3><pre><code>&lt;custom-component msg="test"&gt;&lt;/custom-component&gt;</code></pre><p>表示：</p><pre><code>const CustomComponent = {      // 在这里定义组件对象}const vnode = {      type: CustomComponent,      props: {     msg: 'test'  }}</code></pre><p>组件 vnode 其实是<strong>对抽象事物的描述</strong>，这是因为我们并不会在页面上真正渲染一个 <custom-component> 标签，而是 </custom-component></p><p style="color: red; font-size: 16px;">渲染组件内部定义的 HTML 标签。</p><p></p><p>两种 vnode 类型外，还有纯文本 vnode、注释 vnode 等等</p><h3 id="1-vnode的优势"><a href="#1-vnode的优势" class="headerlink" title="1.vnode的优势"></a>1.vnode的优势</h3><ul><li>1、抽象化 — 把渲染过程抽象化，从而使得组件的抽象能力也得到提升。</li><li>2、跨平台 – 因为 patch vnode 的过程不同平台可以有自己的实现，基于 vnode 再做服务端渲染、Weex 平台、小程序平台的渲染都变得容易了很多。</li></ul><p>但是不是有了vnode就不需要操作DOM了，两者的优势不一定</p><h3 id="2-创建vnode的过程"><a href="#2-创建vnode的过程" class="headerlink" title="2.创建vnode的过程"></a>2.创建vnode的过程</h3><p>对于app.mount 函数的实现，内部是通过 createVNode 函数创建了根组件的 vnode ：</p><pre><code>const vnode = createVNode(rootComponent, rootProps)</code></pre><p>createVNode内部的关键在于对 props 做标准化处理、对 vnode 的类型信息编码、创建 vnode 对象，标准化子节点 children 。</p><h2 id="二、vnode的渲染"><a href="#二、vnode的渲染" class="headerlink" title="二、vnode的渲染"></a>二、vnode的渲染</h2><p>app.mount 函数中的render(vnode, container)渲染函数实现了，</p><pre><code>render(vnode, rootContainer)const render = (vnode, container) =&gt; {      if (vnode == null) {// 销毁组件if (container._vnode) {  unmount(container._vnode, null, null, true)}  } else {    // 创建或者更新组件    patch(container._vnode || null, vnode, container)  }  // 缓存 vnode 节点，表示已经渲染  container._vnode = vnode}</code></pre><p>当其第一个参数vnode 为空，则执行销毁组件的逻辑，否则执行创建或者更新组件的逻辑。</p><p>对于上面<strong>创建与更新组件</strong>中的patch函数实现中，其patch函数功能如下：</p><ul><li><p>1、是根据 vnode 挂载 DOM</p></li><li><p>2、根据新旧 vnode 更新 DOM</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) =&gt; {<br>  。。。。<br>  }<br>在创建的过程中，patch 函数接受多个参数，这里我们目前只重点关注前三个：</p></li><li><p>第一个参数 n1 表示旧的 vnode，当 n1 为 null 的时候，表示是一次挂载的过程；</p></li><li><p>第二个参数 n2 表示新的 vnode 节点，后续会根据这个 vnode 类型执行不同的处理逻辑；</p></li><li><p>第三个参数 container 表示 DOM 容器，也就是 vnode 渲染生成 DOM 后，会挂载到 container 下面。</p></li></ul><h3 id="处理方式："><a href="#处理方式：" class="headerlink" title="处理方式："></a>处理方式：</h3><h4 id="对组件的处理-–-processComponent-函数"><a href="#对组件的处理-–-processComponent-函数" class="headerlink" title="对组件的处理 –  processComponent 函数"></a>对组件的处理 –  processComponent 函数</h4><pre><code>const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; {  if (n1 == null) {   // 执行挂载组件   mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)  }  else {        // 执行更新组件        updateComponent(n1, n2, parentComponent, optimized)  }}</code></pre><p>挂载组件的mountComponent的实现：</p><pre><code>        三件事情：const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; {  // 1、创建组件实例  --内部通过对象的方式进行创建  const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense))  // 2、设置组件实例  setupComponent(instance)  // 3、设置并运行带副作用的渲染函数  setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)}</code></pre><p>在设置组件实例中，instance 保留了很多组件相关的数据，维护了组件的上下文，包括对 props、插槽，以及其他实例的属性的初始化处理。</p><h4 id="渲染函数setupRenderEffect："><a href="#渲染函数setupRenderEffect：" class="headerlink" title="渲染函数setupRenderEffect："></a>渲染函数setupRenderEffect：</h4><pre><code>const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; {  // 创建响应式的副作用渲染函数//副作用：当组件的数据发生变化时，effect 函数包裹的内部渲染函数 componentEffect 会重新执行一遍，从而达到重新渲染组件的目的。  instance.update = effect(function componentEffect() {//进行初始渲染if (!instance.isMounted) {  // 渲染组件生成子树 vnode  const subTree = (instance.subTree = renderComponentRoot(instance))  // 把子树 vnode 挂载到 container 中  patch(null, subTree, container, anchor, instance, parentSuspense, isSVG)  // 保留渲染生成的子树根 DOM 节点  initialVNode.el = subTree.el  instance.isMounted = true}else {  // 更新组件        }      }, prodEffectOptions)}</code></pre><p>初始渲染主要做两件事情：渲染组件生成 subTree、把 subTree 挂载到 container 中。</p><p>还有注意要注意别把 subTree 和 initialVNode 弄混了</p><p>以父组件 App 中里引入了 Hello 组件为例：</p><pre><code>&lt;template&gt;  &lt;div class="app"&gt;    &lt;p&gt;This is an app.&lt;/p&gt;    &lt;hello&gt;&lt;/hello&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>Hello组件如下：</p><pre><code>&lt;template&gt;  &lt;div class="hello"&gt;    &lt;p&gt;Hello, Vue 3.0!&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>在 App 组件中， <hello> 节点渲染生成的 vnode ，对应的就是 Hello 组件的 initialVNode ，为了好记，你也可以把它称作“组件 vnode”。外部组件</hello></p><p>而 Hello 组件内部整个 DOM 节点对应的 vnode 就是执行 renderComponentRoot（见渲染函数setupRenderEffect） 渲染生成对应的 subTree，我们可以把它称作“子树 vnode” – 内部DOM</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>回到patch函数进行对vnode判断，对于接下来看对普通 DOM 元素的处理流程。</p><p>上面的processElement函数中可知</p><p>该函数的逻辑很简单，如果 n1 为 null，走挂载元素节点的逻辑，否则走更新元素节点逻辑。</p><p>我们接着来看挂载元素的 mountElement 函数的实现：</p><pre><code>const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; {  let el  const { type, props, shapeFlag } = vnode  // 创建 DOM 元素节点  el = vnode.el = hostCreateElement(vnode.type, isSVG, props &amp;&amp; props.is)  if (props) {    // 处理 props，比如 class、style、event 等属性    for (const key in props) {          if (!isReservedProp(key)) {        hostPatchProp(el, key, null, props[key], isSVG)      }    }  }  if (shapeFlag &amp; 8 /* TEXT_CHILDREN */) {        // 处理子节点是纯文本的情况        hostSetElementText(el, vnode.children)  }  else if (shapeFlag &amp; 16 /* ARRAY_CHILDREN */) {            // 处理子节点是数组的情况        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG &amp;&amp; type !== 'foreignObject', optimized || !!vnode.dynamicChildren)  }  // 把创建的 DOM 元素节点挂载到 container 上  hostInsert(el, container, anchor)}</code></pre><p>可以看到，挂载元素函数主要做四件事：</p><ul><li>1、创建 DOM 元素节点（hostCreateElement 方法  –平台相关方法，实际还是要通过 document.createElement 创建元素，也是底层方法，只是不用用户直接操作DOM）。</li><li>2、处理 props、</li><li>3、处理 children、</li><li>4、挂载 DOM 元素到 container 上。</li></ul><p>vnode 同样也是一棵树，并且它和 DOM 结构是一一映射的。</p><p><a href="https://imgtu.com/i/RZzcLt"><img src="https://z3.ax1x.com/2021/06/22/RZzcLt.md.jpg" alt="RZzcLt.md.jpg"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言：介绍&quot;&gt;&lt;a href=&quot;#前言：介绍&quot; class=&quot;headerlink&quot; title=&quot;前言：介绍&quot;&gt;&lt;/a&gt;前言：介绍&lt;/h2&gt;&lt;p&gt;组件是一个抽象的概念，它是对一棵 DOM 树的抽象，当我们写一个组件节点时：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;</summary>
      
    
    
    
    <category term="vue3.0源码简析" scheme="https://useritem.github.io/categories/vue3-0%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    
    
    <category term="vue3.0核心组件实现" scheme="https://useritem.github.io/tags/vue3-0%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>组件问题 - 组件更新</title>
    <link href="https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/vue.js%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E7%BB%84%E4%BB%B6%E9%97%AE%E9%A2%98-%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0/"/>
    <id>https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/vue.js%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E7%BB%84%E4%BB%B6%E9%97%AE%E9%A2%98-%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0/</id>
    <published>2021-07-06T14:17:45.000Z</published>
    <updated>2021-07-06T14:28:08.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>组件渲染过程的本质在于吧各种类型的 vnode 渲染成真实 DOM。</p><p>组件是由模板、组件描述对象和数据构成的，数据的变化会影响组件的变化。组件的渲染过程中创建了一个带<strong>副作用</strong>的渲染函数，当数据变化的时候就会执行这个<strong>渲染函数</strong>来触发组件的更新。</p><h1 id="更新与渲染过程"><a href="#更新与渲染过程" class="headerlink" title="更新与渲染过程"></a>更新与渲染过程</h1><h2 id="一、副作用渲染函数更新组件的过程"><a href="#一、副作用渲染函数更新组件的过程" class="headerlink" title="一、副作用渲染函数更新组件的过程"></a>一、副作用渲染函数更新组件的过程</h2><p>带副作用渲染函数 setupRenderEffect 的实现：</p><p>const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; {</p><pre><code>// 创建响应式的副作用渲染函数instance.update = effect(function componentEffect() {if (!instance.isMounted) {  // 渲染组件}else {  // 更新组件  let { next, vnode } = instance  // next 表示新的组件 vnode  if (next) {    // 更新组件 vnode 节点信息    updateComponentPreRender(instance, next, optimized)  }  else {    next = vnode  }  // 渲染新的子树 vnode  const nextTree = renderComponentRoot(instance)  // 缓存旧的子树 vnode  const prevTree = instance.subTree  // 更新子树 vnode  instance.subTree = nextTree  // 组件更新核心逻辑，根据新旧子树 vnode 做 patch  patch(prevTree, nextTree,    // 如果在 teleport 组件中父节点可能已经改变，所以容器直接找旧树 DOM 元素的父节点    hostParentNode(prevTree.el),    // 参考节点在 fragment 的情况可能改变，所以直接找旧树 DOM 元素的下一个节点    getNextHostNode(prevTree),    instance,    parentSuspense,    isSVG)  // 缓存更新后的 DOM 节点  next.el = nextTree.el}  }, prodEffectOptions)}    </code></pre><p>更新组件主要做三件事情：</p><ul><li>更新组件 vnode 节点(以条件判断组件实例中是否有新的组件 vnode</li><li>渲染新的子树 vnode、（由数据发生了变化故子树也发生了变化）</li><li>根据新旧子树 vnode 执行 patch 逻辑。（找新旧子树 vnode 的不同，找到合适的方法更新DOM）</li></ul><p>主要就是patch函数的实现，其中</p><p>在这个过程中，首先判断新旧节点是否是<strong>相同的 vnode 类型</strong>，如果不同，比如一个 div 更新成一个 ul，直接进行删除再挂载，so easy</p><p>如果是相同的 vnode 类型，就需要走 diff 更新流程了，接着会根据不同的 vnode 类型执行不同的处理逻辑</p><p>vnode类型分为 - 普通元素类型和组件类型的处理过程。</p><h2 id="1、处理组件"><a href="#1、处理组件" class="headerlink" title="1、处理组件"></a>1、处理组件</h2><p>一个组件重新渲染可能会有两种场景，</p><ul><li>一种是组件本身的数据变化，这种情况下 next 是 null；</li><li>另一种是父组件在更新的过程中，遇到子组件节点，先判断子组件是否需要更新</li></ul><p>如果需要则主动执行子组件的重新渲染方法，这种情况下 next 就是新的子组件 vnode。</p><p>子组件对应的新的组件 vnode 是在父组件重新渲染的过程中，通过 renderComponentRoot 渲染子树 vnode 的时候生成</p><p>原因在于 子树vnode为树形结构，通过遍历它的节点就可以访问对应位置的组件</p><p>processComponent 处理组件 vnode，本质上就是去判断子组件是否需要更新，</p><p>如果需要则递归执行子组件的副作用渲染函数来更新</p><p>否则仅仅更新一些 vnode 的属性，并让子组件实例保留对组件 vnode 的引用，用于子组件自身数据变化引起组件重新渲染的时候，在渲染函数内部可以拿到新的组件 vnode。</p><h2 id="2、处理普通元素"><a href="#2、处理普通元素" class="headerlink" title="2、处理普通元素"></a>2、处理普通元素</h2><p>举例：</p><pre><code>&lt;template&gt;      &lt;div class="app"&gt;        &lt;p&gt;This is {{msg}}.&lt;/p&gt;    &lt;button @click="toggle"&gt;Toggle msg&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {        data() {          return {            msg: 'Vue'      }    },methods: {  toggle() {    this.msg = 'Vue'? 'World': 'Vue'  }}  }&lt;/script&gt;</code></pre><p>当点击按钮时，就触发了toggle函数，进行对数据进行了改变，造成了重新渲染</p><p>App 组件的根节点是 div 标签，重新渲染的子树 vnode 节点是一个普通元素的 vnode，所以应该先走 processElement 逻辑。</p><p>更新元素关键在于：</p><ul><li><p>更新 props （ patchProps 函数就是在更新 DOM 节点的 class、style、event 以及其它的一些 DOM 属性）</p></li><li><p>更新子节点（九种情况讨论即可），具体代码如下：</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG,     optimized = false) =&gt; {</p><pre><code>const c1 = n1 &amp;&amp; n1.childrenconst prevShapeFlag = n1 ? n1.shapeFlag : 0const c2 = n2.childrenconst { shapeFlag } = n2// 子节点有 3 种可能情况：文本、数组、空if (shapeFlag &amp; 8 /* TEXT_CHILDREN */) {</code></pre><p>  if (prevShapeFlag &amp; 16 /* ARRAY_CHILDREN */) {</p><pre><code>// 数组 -&gt; 文本，则删除之前的子节点unmountChildren(c1, parentComponent, parentSuspense)</code></pre><p>  }<br>  if (c2 !== c1) {</p><pre><code>// 文本对比不同，则替换为新文本hostSetElementText(container, c2)</code></pre><p>  }</p><pre><code>}else {</code></pre><p>  if (prevShapeFlag &amp; 16 /* ARRAY_CHILDREN */) {</p><pre><code>// 之前的子节点是数组if (shapeFlag &amp; 16 /* ARRAY_CHILDREN */) {  // 新的子节点仍然是数组，则做--完整地 diff--  patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)}else {  // 数组 -&gt; 空，则仅仅删除之前的子节点  unmountChildren(c1, parentComponent, parentSuspense, true)}</code></pre><p>  }</p><p>  else {</p><pre><code>// 之前的子节点是文本节点或者为空// 新的子节点是数组或者为空if (prevShapeFlag &amp; 8 /* TEXT_CHILDREN */) {  // 如果之前子节点是文本，则把它清空  hostSetElementText(container, '')}if (shapeFlag &amp; 16 /* ARRAY_CHILDREN */) {  // 如果新的子节点是数组，则挂载新子节点  mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)}</code></pre><p>  }</p><pre><code>}</code></pre><p>  }</p></li></ul><h1 id="diff算法-–-新旧节点均为vnode数组"><a href="#diff算法-–-新旧节点均为vnode数组" class="headerlink" title="diff算法 – 新旧节点均为vnode数组"></a>diff算法 – 新旧节点均为vnode数组</h1><h2 id="叙述"><a href="#叙述" class="headerlink" title="叙述"></a>叙述</h2><p>新子节点数组相对于旧子节点数组的变化，无非是通过更新、删除、添加和移动节点来完成</p><p>而核心 diff 算法，就是在已知旧子节点的 DOM 结构、vnode 和新子节点的 vnode 情况下，以<strong>较低的成本</strong>完成子节点的更新为目的，求解生成新子节点 DOM 的系列操作。</p><p>由于发现新旧 children 拥有相同的头尾节点。对于相同的节点，我们只需要做对比更新即可</p><h2 id="一、同步头部节点"><a href="#一、同步头部节点" class="headerlink" title="一、同步头部节点"></a>一、同步头部节点</h2><p>diff 算法的第一步从头部开始同步。</p><p>需要注意的是–</p><p>在整个 diff 的过程，我们需要维护几个变量：<strong>头部的索引 i、旧子节点的尾部索引 e1和新子节点的尾部索引 e2。</strong></p><p>同步头部节点过程就是从头部开始，依次对比新节点和旧节点，如果它们相同的则执行 patch 更新节点；如果不同或者索引 i 大于索引 e1 或者 e2，则同步过程结束。</p><p>e1，e2指的是未同步的节点的尾</p><h2 id="二、同步尾部节点"><a href="#二、同步尾部节点" class="headerlink" title="二、同步尾部节点"></a>二、同步尾部节点</h2><p>道理与直接相同，当新旧节点相同时，执行patch更新节点，不同或者或者索引 i 大于索引 e1 或者 e2则同步结束</p><p>之后接下来只有 3 种情况要处理：</p><ul><li><p>新子节点有剩余要添加的新节点；</p></li><li><p>旧子节点有剩余要删除的多余节点；</p></li><li><p>未知子序列。</p></li></ul><h2 id="三-1、新子节点有剩余要添加的新节点"><a href="#三-1、新子节点有剩余要添加的新节点" class="headerlink" title="三.1、新子节点有剩余要添加的新节点"></a>三.1、新子节点有剩余要添加的新节点</h2><p>首先要判断新子节点是否有剩余的情况，如果满足则添加新子节点</p><p>用索引表示尾如果索引 i 大于尾部索引 e1 且 i 小于 e2，那么从索引 i 开始到索引 e2 之间，我们直接挂载新子树这部分的节点。</p><h2 id="三-2、删除多余节点"><a href="#三-2、删除多余节点" class="headerlink" title="三.2、删除多余节点"></a>三.2、删除多余节点</h2><p>如果不满足添加新节点的情况，我就要接着判断旧子节点是否有剩余，如果满足则删除旧子节点,即</p> <p style="color: red; font-size: 16px;font-weight: bolder;">i &gt; e2</p>那么从索引 i 开始到索引 e1 之间，我们直接删除**旧子树这部分的节点**<p>前两种处理完后，i都会大于e1与e2</p><h2 id="三-3、处理未知子序列"><a href="#三-3、处理未知子序列" class="headerlink" title="三.3、处理未知子序列"></a>三.3、处理未知子序列</h2><p>首先需要明白</p><p><strong>其实无论多复杂的情况，最终无非都是通过更新、删除、添加、移动这些动作来操作节点，而我们要做的就是找到相对优的解。</strong></p><p>所以此时确定完头尾之后，需要进行移动。</p><p>第一种思路在于进行移动更新查找时，需要双重循环，而双重循环的复杂度是 O(n2) </p><p>为了优化这个复杂度，我们可以用一种空间换时间的思路，建立索引图，把时间复杂度降低到 O(n)。</p><h3 id="建立索引图"><a href="#建立索引图" class="headerlink" title="建立索引图"></a>建立索引图</h3><p>通常我们在开发过程中， 会给 v-for 生成的列表中的每一项分配唯一 key 作为项的唯一 ID，这个 key 在 diff 过程中起到很关键的作用。对于新旧子序列中的节点，我们认为 key 相同的就是同一个节点，直接执行 patch 更新即可。</p><p>我们根据 key 建立新子序列的索引图，实现如下：</p><pre><code>const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; {  let i = 0  const l2 = c2.length  // 旧子节点的尾部索引  let e1 = c1.length - 1  // 旧子序列开始索引，从 i 开始记录  const s1 = i  // 新子序列开始索引，从 i 开始记录  const s2 = i //  // 5.1 根据 key 建立新子序列的索引图  const keyToNewIndexMap = new Map()  for (i = s2; i &lt;= e2; i++) {const nextChild = c2[i]keyToNewIndexMap.set(nextChild.key, i)  }}</code></pre><p>之后更新和移除旧节点，</p><p>最后移动和挂载新节点</p><p>需要注意的是子节点更新调用的是 patch 方法， Vue.js 正是通过这种递归的方式完成了整个组件树的更新。</p><p>核心 diff 算法中最复杂就是求解最长递增子序列</p><h2 id="总结、组件更新流程展示；"><a href="#总结、组件更新流程展示；" class="headerlink" title="总结、组件更新流程展示；"></a>总结、组件更新流程展示；</h2><p><a href="https://imgtu.com/i/RmkbtI"><img src="https://z3.ax1x.com/2021/06/22/RmkbtI.png" alt="RmkbtI.png"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;组件渲染过程的本质在于吧各种类型的 vnode 渲染成真实 DOM。&lt;/p&gt;
&lt;p&gt;组件是由模板、组件描述对象和数据构成的，数据的变化会影响</summary>
      
    
    
    
    <category term="vue3.0源码简析" scheme="https://useritem.github.io/categories/vue3-0%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    
    
    <category term="vue3.0核心组件实现" scheme="https://useritem.github.io/tags/vue3-0%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>侦听器的实现及应用</title>
    <link href="https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/Composition%20API%E8%AE%BE%E8%AE%A1/%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/Composition%20API%E8%AE%BE%E8%AE%A1/%E4%BE%A6%E5%90%AC%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-07-06T14:17:30.000Z</published>
    <updated>2021-07-06T14:28:08.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>侦听器 – 为了观察数据的变化然后并执行一定的逻辑</p><h3 id="vue2-x"><a href="#vue2-x" class="headerlink" title="vue2.x"></a>vue2.x</h3><p>2.x的两种方法：watch选项与$watch API去创建（可进行创建与销毁）</p><p>watch方法：</p><pre><code>export default {      watch: {         a(newVal, oldVal) {           console.log('new: %s,00 old: %s', newVal, oldVal)     }   } } </code></pre><p>$watch API方法：</p><pre><code>const unwatch = vm.$watch('a', function(newVal, oldVal) {       console.log('new: %s, old: %s', newVal, oldVal) }) </code></pre><p>这个方法通过 $watch API 创建的侦听器 watcher 会返回一个 unwatch 函数，你可以随时执行它来停止这个 watcher 对数据的侦听，而对于 watch 选项创建的侦听器，它会随着组件的销毁而停止对数据的侦听。</p><h1 id="一、watch-API-实现监听"><a href="#一、watch-API-实现监听" class="headerlink" title="一、watch API 实现监听"></a>一、watch API 实现监听</h1><h2 id="1、用法"><a href="#1、用法" class="headerlink" title="1、用法:"></a>1、用法:</h2><p>1 监听getter – 返回响应式对象 ，一旦响应式对象更新 — 就会返回对应回调函数。</p><pre><code>import { reactive, watch } from 'vue' const state = reactive({ count: 0 }) watch(() =&gt; state.count, (count, prevCount) =&gt; {       // 当 state.count 更新，会触发此回调函数 }) </code></pre><p>2.监听响应式对象 – 对象更新直接执行回调函数</p><pre><code>import { ref, watch } from 'vue' const count = ref(0) watch(count, (count, prevCount) =&gt; {       // 当 count.value 更新，会触发此回调函数 }) </code></pre><p>3.多个响应式对象（数组形式）  – 一个更新就执行回调</p><pre><code>import { ref, watch } from 'vue' const count = ref(0) const count2 = ref(1) watch([count, count2], ([count, count2], [prevCount, prevCount2]) =&gt; {       // 当 count.value 或者 count2.value 更新，会触发此回调函数 }) </code></pre><h2 id="2、实现原理"><a href="#2、实现原理" class="headerlink" title="2、实现原理"></a>2、实现原理</h2><p>通过联想侦听器与副作用函数effect很像（当侦听的对象或者函数发生了变化则自动执行某个回调函数）， 所以想到其内部实现了effect，看源码发出现其内部主要就是实现了doWatch函数，而doWatch部分确实实现了effect。</p><p>dowatch的具体行为 – <strong>五步走</strong></p><pre><code>function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {   // 标准化 source   // 构造 applyCb 回调函数   // 创建 scheduler 时序执行函数   // 创建 effect 副作用函数   // 返回侦听器销毁函数 }   </code></pre><p>具体分析：</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="1-标准化source-–-watch-函数的第一个参数"><a href="#1-标准化source-–-watch-函数的第一个参数" class="headerlink" title="1.标准化source  – watch 函数的第一个参数"></a>1.标准化source  – watch 函数的第一个参数</h3><p>它代表的是监听的<strong>目标是啥（即监听对象的处理）</strong> – 上面说的有三个，所以先应该进行标准化，即根据目标类型。标准成为<strong>getter函数</strong>。（三种情况）</p><ul><li><p>情况一：如果 source 是 ref 对象，则创建一个访问 source.value 的 getter 函数;</p></li><li><p>情况二 ：如果 source 是 reactive 对象，则创建一个访问 source 的 getter 函数，并设置 deep 为 true（deep 的作用我稍后会说）;</p></li><li><p>情况三：如果 source 是一个函数，则会进一步判断第二个参数 cb 是否存在，对于 watch API 来说，cb 是一定存在且是一个回调函数，这种情况下，getter 就是一个简单的对 source 函数封装的函数。</p></li></ul><h4 id="产物getter分析"><a href="#产物getter分析" class="headerlink" title="产物getter分析"></a>产物getter分析</h4><p>getter函数 – 返回响应式对象，在创建effect runner函数时，被作为watcher求值的结果。</p><p style="color: red; font-size: 16px;font-weight: bolder;">每次执行 runner 就会把 getter 函数返回的响应式对象作为 watcher 求值的结果</p><p></p><p>deep == true时 ，表示需要进行traverse 函数<strong>递归每一个value的子属性</strong>，</p><p>注意deeper意思  -=– 表面含义是深度侦听，实际上是通过遍历对象的每一个子属性来实现，—-解决嵌套较深的问题</p><p>例子：</p><pre><code>import { reactive, watch } from 'vue' const state = reactive({   count: {         a: {       b: 1     }   } }) watch(state.count, (count, prevCount) =&gt; { console.log(count) }) state.count.a.b = 2  </code></pre><p>前提：我们知道只有对象属性先被访问触发了依赖收集，再去修改这个属性，才可以通知对应的依赖更新。</p><p>当我们执行 watch 函数的时候，我们知道如果侦听的是一个 reactive 对象，那么内部会设置 deep 为 true，然后执行 traverse 去递归访问对象深层子属性。。。</p><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>减少traverse 函数递归的性能损耗  —- 只监听getter函数</p><pre><code>watch(() =&gt; state.count.a.b, (newVal, oldVal) =&gt; { console.log(newVal) }) state.count.a.b = 2 </code></pre><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="2-构造回调函数-–-第二个参数-cb（功能实现）"><a href="#2-构造回调函数-–-第二个参数-cb（功能实现）" class="headerlink" title="2.构造回调函数 – 第二个参数 cb（功能实现）"></a>2.构造回调函数 – 第二个参数 cb（功能实现）</h3><p>cb函数参数 — 作用在于侦听一个值的变化，如果值变了就执行回调函数，回调函数里可以访问到新值和旧值。</p><p>cb函数的三个参数 — 第一个 newValue 代表新值；第二个 oldValue 代表旧值。第三个参数 onInvalidate用于注册无效的回调函数。</p><h4 id="构造回调函数的处理逻辑"><a href="#构造回调函数的处理逻辑" class="headerlink" title="构造回调函数的处理逻辑"></a>构造回调函数的处理逻辑</h4><p>主要需要注意的是两个函数，一个是onInvalidate – 注册无效回调函数</p><p>另一个为applyCb  – 表示对cb的封装，*** 这个函数的实现就是“两步走”：</p><ul><li>1、执行runner函数求新值，实际上就是执行前面创建的 getter 函数求新值。</li><li>2、判断，如果是 deep 的情况或者新旧值发生了变化，则执行回调函数 cb，传入参数 newValue 和 oldValue。</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>（1）watch API 和组件实例相关，因为通常我们会在组件的 setup 函数中使用它，当组件销毁后，回调函数 cb 不应该被执行而是直接返回.</p><p>（2）第一次执行的时候旧值的初始值是空数组或者 undefined。执行完回调函数 cb 后，把旧值 oldValue 再更新为 newValue，这是为了下一次的比对</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h3 id="3-创建-scheduler-–-涉及到第三个参数"><a href="#3-创建-scheduler-–-涉及到第三个参数" class="headerlink" title="3.创建 scheduler – 涉及到第三个参数"></a>3.创建 scheduler – 涉及到第三个参数</h3><h4 id="1-scheduler作用"><a href="#1-scheduler作用" class="headerlink" title="1.scheduler作用"></a>1.scheduler作用</h4><p>scheduler 的作用是根据某种<strong>调度的方式</strong>去执行某种函数，在 watch API 中，主要影响到的是回调函数的执行方式。</p><p>options参数表示了 — <strong>配置，决定了watcher的不同的行为</strong>  – 一般就是deeper，即可以对其进行主动设置，不用再要求传入的是 – source==reactive</p><h4 id="2-scheduler的决定因素"><a href="#2-scheduler的决定因素" class="headerlink" title="2.scheduler的决定因素"></a>2.scheduler的决定因素</h4><p>scheduler 的创建逻辑受到了第三个参数 Options 中的 flush 属性值的影响，不同的 flush 决定了 watcher 的执行时机。 – flush的三种情况</p><ul><li><p>当 flush 为 sync 的时候，表示它是一个同步 watcher，即当数据变化时同步执行回调函数。</p></li><li><p>当 flush 为 pre 的时候，回调函数通过 queueJob 的方式在组件更新之前执行，如果组件还没挂载，则同步执行确保回调函数在组件挂载之前执行。</p></li><li><p>如果没设置 flush，那么回调函数通过 queuePostRenderEffect 的方式在组件更新之后执行。</p></li></ul><p style="color: red; font-size: 16px;font-weight: bolder;">watcher 的回调函数是通过一定的调度方式执行的。</p><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h3 id="4、创建effect-–-核心实现"><a href="#4、创建effect-–-核心实现" class="headerlink" title="4、创建effect  – 核心实现"></a>4、创建effect  – 核心实现</h3><p>前面的分析我们提到了 runner，它其实就是 watcher 内部创建的 effect 函数，–核心部分</p><pre><code>const runner = effect(getter, {       // 延时执行   lazy: true,       // computed effect 可以优先于普通的 effect 先运行，比如组件渲染的 effect    computed: true,   onTrack,    onTrigger,   scheduler: applyCb ? () =&gt; scheduler(applyCb) : scheduler })     // 在组件实例中记录这个 effect recordInstanceBoundEffect(runner)     // 初次执行 if (applyCb) {       if (immediate) {     applyCb()   }   else {     // 求旧值 oldValue = runner()   }     } else {       // 没有 cb 的情况   runner() } </code></pre><p>主要就是即通过 effect API 创建一个副作用函数 runner ，重要关注就是四大点</p><ul><li>1、runner 是一个 computed effect。（优先执行，即置 flush 为 pre 的时候，watcher 的执行可以优先于组件更新。）</li><li>2、runner 执行的方式</li><li>3、runner 的返回结果 (手动执行 runner 就相当于执行了前面标准化的 getter 函数)</li><li>4、配置了 immediate 的情况</li></ul><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><h3 id="5-返回销毁函数-–-最后一步"><a href="#5-返回销毁函数-–-最后一步" class="headerlink" title="5.返回销毁函数  – 最后一步"></a>5.返回销毁函数  – 最后一步</h3><p>销毁函数内部会执行 stop 方法让 runner 失活，并清理 runner 的相关依赖，这样就可以停止对数据的侦听。并且，如果是在组件中注册的 watcher，也会移除组件 effects 对这个 runner 的引用。</p><h3 id="内部总结"><a href="#内部总结" class="headerlink" title="内部总结"></a>内部总结</h3><p>我们可以侦听响应式数据的变化，内部创建 effect runner，首次执行 runner 做依赖收集，然后在数据发生变化后，以某种调度方式去执行回调函数。</p><h1 id="二、异步"><a href="#二、异步" class="headerlink" title="二、异步"></a>二、异步</h1><p>分析第三步，由于回调函数以一中调度的方式执行的，特别是当 flush 不是 sync 时，它会把回调函数执行的任务推到一个异步队列中执行。，所以开始对异步进行分析</p><h2 id="1、设计原因"><a href="#1、设计原因" class="headerlink" title="1、设计原因"></a>1、设计原因</h2><p>例子</p><pre><code>import { reactive, watch } from 'vue' const state = reactive({ count: 0 }) watch(() =&gt; state.count, (count, prevCount) =&gt; {       console.log(count) }) state.count++ state.count++ state.count++ </code></pre><p>解释：因为在一个 <strong>Tick（宏任务执行的生命周期）</strong>内，即使多次修改侦听的值，它的回调函数也只执行一次</p><p>扩展：</p><p>组件的更新过程是异步的，我们知道修改模板中引用的响应式对象的值时，会触发组件的重新渲染，但是在一个 Tick 内，即使你多次修改多个响应式对象的值，组件的重新渲染也<strong>只执行一次</strong>。这是因为如果每次更新数据都触发组件重新渲染，那么重新渲染的次数和代价都太高了。  – 节约渲染开销</p><h2 id="2、创建"><a href="#2、创建" class="headerlink" title="2、创建"></a>2、创建</h2><p>通过前面的分析我们知道，在创建一个 watcher 时，如果配置 flush 为 pre 或不配置 flush ，那么 watcher 的回调函数就会异步执行。此时分别是通过 queueJob 和 queuePostRenderEffect （见上面第三步）把回调函数推入异步队列中的。</p><p>在不涉及 suspense 的情况下，queuePostRenderEffect 相当于 queuePostFlushCb,</p><pre><code>// 异步任务队列 const queue = [] // 队列任务执行完后执行的回调函数队列 const postFlushCbs = [] function queueJob(job) {       if (!queue.includes(job)) {     queue.push(job)     queueFlush()   }     } function queuePostFlushCb(cb) {   if (!isArray(cb)) {     postFlushCbs.push(cb)   }   else {     // 如果是数组，把它拍平成一维 postFlushCbs.push(...cb)   }   queueFlush() }</code></pre><p>实现就是两个维护， queue 数组和一个 postFlushCbs 数组，其中 queue 数组用作异步任务队列， postFlushCbs 数组用作异步任务队列执行完毕后的回调函数队列。且两个任务，第二个任务中有queueFlush 函数</p><p>它的实现也是两个维护，两个函数，两个变量比较重要，主要用来控制异步任务的刷新逻辑 </p><p>isFlushPending 用于判断是否在等待 nextTick 执行 flushJobs，而 isFlushing 是判断是否正在执行任务队列。</p><h2 id="3、执行-–-进行异步执行队列"><a href="#3、执行-–-进行异步执行队列" class="headerlink" title="3、执行  – 进行异步执行队列"></a>3、执行  – 进行异步执行队列</h2><p>也就是flushJobs 函数开始执行</p><p>主要就是先对queueFlush中从参数进行重新赋值，会把 isFlushPending 重置为 false，把 isFlushing 设置为 true 来表示正在执行异步任务队列。</p><p>之后就是对queue进行从小到大的排序并遍历，之后执行flushPostFlushCbs 方法（遍历执行所有推入到 postFlushCbs 的回调函数）</p><p>（执行在这个函数需要注意应该进行拷贝）</p><p>最后遍历完 postFlushCbs 后，再对重置 isFlushing 为 false</p><h3 id="排序的原因"><a href="#排序的原因" class="headerlink" title="排序的原因"></a>排序的原因</h3><ul><li><p>（1）我们创建组件的过程是由父到子，所以创建组件副作用渲染函数也是先父后子，父组件的副作用渲染函数的 effect id 是小于子组件的，每次更新组件也是通过 queueJob 把 effect 推入异步任务队列 queue 中的。所以为了保证先更新父组再更新子组件，要对 queue 做从小到大的排序。</p></li><li><p>（2）如果一个组件在父组件更新过程中被卸载，它自身的更新应该被跳过。所以也应该要保证先更新父组件再更新子组件，要对 queue 做从小到大的排序。</p></li></ul><h2 id="4、检测循环更新"><a href="#4、检测循环更新" class="headerlink" title="4、检测循环更新"></a>4、检测循环更新</h2><p>由于在遍历执行异步任务和回调函数的过程中，都会在非生产环境下执行 checkRecursiveUpdates 检测是否有循环更新</p><h3 id="解决的问题："><a href="#解决的问题：" class="headerlink" title="解决的问题："></a>解决的问题：</h3><p>一旦watcher中进行了更新数据，即再一次<strong>进入回调函数</strong>，如果不控制，就凉凉–回调函数一直执行，直到内存耗尽造成浏览器假死。  （没办法侦听器本质就是数据变化–执行回调）</p><h3 id="解决：-checkRecursiveUpdates-方法："><a href="#解决：-checkRecursiveUpdates-方法：" class="headerlink" title="解决： checkRecursiveUpdates 方法："></a>解决： checkRecursiveUpdates 方法：</h3><pre><code>const RECURSION_LIMIT = 100 function checkRecursiveUpdates(seen, fn) {       if (!seen.has(fn)) {     seen.set(fn, 1)   } else {     const count = seen.get(fn) if (count &gt; RECURSION_LIMIT) {   throw new Error('Maximum recursive updates exceeded. ' +     "You may have code that is mutating state in your component's " +     'render function or updated hook or watcher source function.') } else {   seen.set(fn, count + 1) }   } } </code></pre><p>由于当异步函数flushJobs 一开始便创建了 seen（一个 Map 对象）</p><p>在 checkRecursiveUpdates 的时候会把任务添加到 seen 中，记录引用计数 count，初始值为 1，如果 postFlushCbs 再次添加了<strong>相同的任务</strong>，则引用计数 count 加 1，如果 count 大于我们定义的限制 100 ，则说明一直在添加这个相同的任务并超过了 100 次。那么，Vue.js 会抛出这个错误   — 代表正常使用中不应该这样。 例子如下</p><pre><code>import { reactive, watch } from 'vue' const state = reactive({ count: 0 }) watch(() =&gt; state.count, (count, prevCount) =&gt; {       state.count++       console.log(count) }) state.count++ </code></pre><p>如果你去跑这个示例，你会在控制台看到输出了 101 次值，然后报了错误： Maximum recursive updates exceeded 。</p><h2 id="5、优化：只用一个变量-对于queueFlush-函数"><a href="#5、优化：只用一个变量-对于queueFlush-函数" class="headerlink" title="5、优化：只用一个变量  - 对于queueFlush 函数"></a>5、优化：只用一个变量  - 对于queueFlush 函数</h2><p>首先说明两个变量的作用：</p><ul><li><p>在一个 Tick（宏任务执行的生命周期） 内可以多次添加任务到队列中，但是任务队列会在 nextTick 后执行；</p></li><li><p>在执行任务队列的过程中，也可以添加新的任务到队列中，并且在当前 Tick 去执行剩余的任务队列。</p></li></ul><p>优化 —仅用一个变量</p><pre><code>function queueFlush() {       if (!isFlushing) { isFlushing = true nextTick(flushJobs)   } } function flushJobs(seen) {       let job   if ((process.env.NODE_ENV !== 'production')) {     seen = seen || new Map()   } queue.sort((a, b) =&gt; getId(a) - getId(b)) while ((job = queue.shift()) !== undefined) { if (job === null) {   continue } if ((process.env.NODE_ENV !== 'production')) {   checkRecursiveUpdates(seen, job) } callWithErrorHandling(job, null, 14 /* SCHEDULER */)   } flushPostFlushCbs(seen) if (queue.length || postFlushCbs.length) { flushJobs(seen)   } isFlushing = false } </code></pre><p>可以看到，我们只需要一个 isFlushing 来控制就可以实现相同的功能了。在执行 queueFlush 的时候，判断 isFlushing 为 false，则把它设置为 true，然后 nextTick 会执行 flushJobs。在 flushJobs 函数执行完成的最后，也就是所有的任务（包括后添加的）都执行完毕，再设置 isFlushing 为 false。</p><h1 id="三、扩展：watchEffect-API"><a href="#三、扩展：watchEffect-API" class="headerlink" title="三、扩展：watchEffect API"></a>三、扩展：watchEffect API</h1><p>watchEffect API 的作用是注册一个<strong>副作用函数</strong>，副作用函数内部可以访问到响应式对象，当内部响应式对象变化后再<strong>立即执行</strong>这个函数。</p><pre><code>import { ref, watchEffect } from 'vue' const count = ref(0) watchEffect(() =&gt; console.log(count.value)) count.value++ //输出0 1</code></pre><h2 id="1、区分watch-API"><a href="#1、区分watch-API" class="headerlink" title="1、区分watch API"></a>1、区分watch API</h2><ul><li><p>1.<strong>侦听的源不同</strong> 。watch API 可以侦听一个或多个响应式对象，也可以侦听一个 getter 函数，而 watchEffect API 侦听的是<strong>一个普通函数，只要内部访问了响应式对象即可，这个函数并不需要返回响应式对象</strong>。</p></li><li><p>2.<strong>没有回调函数</strong> 。watchEffect API 没有回调函数，副作用函数的内部响应式对象发生变化后，会再次执行这个副作用函数。</p></li><li><p>3.<strong>立即执行</strong> 。watchEffect API 在创建好 watcher 后，会立刻执行它的副作用函数，而 watch API 需要配置 immediate（创建effect，即runner函数时进行配置） 为 true，才会立即执行回调函数。</p></li></ul><h2 id="2、onInvalidate-参数注册无效回调函数"><a href="#2、onInvalidate-参数注册无效回调函数" class="headerlink" title="2、onInvalidate 参数注册无效回调函数"></a>2、onInvalidate 参数注册无效回调函数</h2><p> onInvalidate 在 doWatch 中的实现：</p><pre><code>const onInvalidate = (fn) =&gt; { cleanup = runner.options.onStop = () =&gt; {     callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);   }; }; </code></pre><p>实际上，当你执行 onInvalidate 的时候，就是注册了一个 cleanup 和 runner 的 onStop 方法，这个方法内部会执行 fn，也就是你注册的无效回调函数。</p><p>也就是说当响应式数据发生变化，会执行 cleanup 方法，当 watcher 被停止，会执行 onStop 方法，这两者都会执行注册的无效回调函数 fn。</p><p>通过这种方式，Vue.js 就很好地实现了 watcher 注册无效回调函数的需求。</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>有些时候，watchEffect 会注册一个副作用函数，在函数内部可以做一些异步操作，但是当这个 watcher 停止后，如果我们想去对这个异步操作做一些额外事情（比如取消这个异步操作），我们可以通过 onInvalidate 参数注册一个无效函数。</p><pre><code>import {ref, watchEffect } from 'vue' const id = ref(0) watchEffect(onInvalidate =&gt; {   // 执行异步操作   const token = performAsyncOperation(id.value)   onInvalidate(() =&gt; {     // 如果 id 发生变化或者 watcher 停止了，则执行逻辑取消前面的异步操作     token.cancel()       }) }) </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;侦听器 – 为了观察数据的变化然后并执行一定的逻辑&lt;/p&gt;
&lt;h3 id=&quot;vue2-x&quot;&gt;&lt;a href=&quot;#vue2-x&quot; cl</summary>
      
    
    
    
    <category term="vue3.0源码简析" scheme="https://useritem.github.io/categories/vue3-0%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    
    
    <category term="Composition" scheme="https://useritem.github.io/tags/Composition/"/>
    
  </entry>
  
  <entry>
    <title>依赖注入分析</title>
    <link href="https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/Composition%20API%E8%AE%BE%E8%AE%A1/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <id>https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/Composition%20API%E8%AE%BE%E8%AE%A1/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/</id>
    <published>2021-07-06T14:16:59.000Z</published>
    <updated>2021-07-06T14:28:08.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>涉及到<strong>组件通信的问题时</strong>，一般都会想到父子组件之间的prop进行通信，但是要实现<strong>跨父子组件之间的通信</strong>，需要进行依赖注入。</p><h3 id="vue2-x实现依赖注入-–-Options的provide-和-inject"><a href="#vue2-x实现依赖注入-–-Options的provide-和-inject" class="headerlink" title="vue2.x实现依赖注入 – Options的provide 和 inject"></a>vue2.x实现依赖注入 – Options的provide 和 inject</h3><pre><code>//  父组件使用provide进行数据提供：  --代表祖先组件进行数据的提供   export default {      provide: function () {             return {               foo: this.foo         }       }     }// 任意子孙组件都可以进行变量的注入 -- injectexport default {     inject: ['foo'] }</code></pre><h3 id="vue3-x"><a href="#vue3-x" class="headerlink" title="vue3.x"></a>vue3.x</h3><p>本质就是换汤不换药，就是除了Options，就是变为了API可以在setup中进行调用，例子：</p><pre><code>// 祖先提供响应式数据themeimport { provide, ref } from 'vue'     export default {         setup() {             const theme = ref('dark')             provide('theme', theme)    //前一个变量key表示提供的依赖名字            }     }import { inject } from 'vue'     export default {         setup() {             const theme = inject('theme', 'light')  //第二个参数表示如果祖先组件上下文没有提供theme，那么就使用light            return {                   theme                 }         }     }</code></pre><p>实际理解上 – 可以依赖注入看作<strong>“大范围的prop”</strong>，最主要的是：</p> <p style="color: red; font-size: 16px;font-weight: bolder;">祖先组件不需要知道哪些后代组件在使用它提供的数据，后代组件也不需要知道注入的数据来自哪里。</p><h1 id="一、依赖注入实现"><a href="#一、依赖注入实现" class="headerlink" title="一、依赖注入实现"></a>一、依赖注入实现</h1><h2 id="1、provide-API"><a href="#1、provide-API" class="headerlink" title="1、provide API"></a>1、provide API</h2><p>在创建组件实例的时候，组件实例的 provides 对象指向父组件实例的 provides 对象：</p><pre><code>const instance = {     // 依赖注入相关 provides: parent ? parent.provides : Object.create(appContext.provides), // 主要理解就是一直想上指// 其它属性 // ... }</code></pre><p>图示：</p><p><a href="https://imgtu.com/i/R7pL7V"><img src="https://z3.ax1x.com/2021/07/06/R7pL7V.md.png" alt="R7pL7V.md.png"></a></p><p>个人理解就是一直向上寻找与继承 —–&gt; 组件实例的 provides 继承它的父组件，当中间组件需要自己的值的时候，会通过<strong>父级组件提供的对象</strong>，来创建自己的对象原型，之后在后面注入inject时，通过<strong>原型链</strong>进行获取。</p><p>另外，如果组件实例提供和父级 provides 中有相同 key（第一个参数一样） 的数据，是可以<strong>覆盖父级</strong>提供的数据。</p><h2 id="2、inject-API"><a href="#2、inject-API" class="headerlink" title="2、inject API"></a>2、inject API</h2><p>上面介绍了，inject的两个参数一个是key值（provide的第一个参数），第二个表示默认值（无数据时，直接返回的）</p><p>如果既查找不到数据且也没有传入默认值，则在非生产环境下报警告，提示用户找不到这个注入的数据。</p><p>inject实现源码：</p><pre><code>function inject(key, defaultValue) { const instance = currentInstance || currentRenderingInstance if (instance) { const provides = instance.provides if (key in provides) {   return provides[key] } else if (arguments.length &gt; 1) {   return defaultValue } else if ((process.env.NODE_ENV !== 'production')) {   warn(`injection "${String(key)}" not found.`) } } }</code></pre><p>抛出问题 —- 都是实现跨组件的数据的共享，provide/inject与export/import 的差异实际也是依赖注入和模块化共享数据的差异。</p><h1 id="二、对比与模块化共享数优劣"><a href="#二、对比与模块化共享数优劣" class="headerlink" title="二、对比与模块化共享数优劣"></a>二、对比与模块化共享数优劣</h1><h2 id="1、对比模块化共享数据的方式"><a href="#1、对比模块化共享数据的方式" class="headerlink" title="1、对比模块化共享数据的方式"></a>1、对比模块化共享数据的方式</h2><p>模块化共享数据的方式，例：</p><pre><code>// Root.js祖先组件export const sharedData = ref('') export default {   name: 'Root',   setup() {// ...   },   // ... }//子组件的引用sharedDataimport { sharedData } from './Root.js' export default { name: 'Root',   setup() {// 这里直接使用 sharedData 即可   } }</code></pre><p>这看似都是共享数据，但是其实有着三大不同：</p><h3 id="1-作用域不同"><a href="#1-作用域不同" class="headerlink" title="1.作用域不同"></a>1.作用域不同</h3><ul><li>依赖注入 — 局部范围，仅可以<strong>后代</strong>组件访问，不是整棵树</li><li>模块化 – 全局范围，任何地方都可以</li></ul><h3 id="2-数据来源不同"><a href="#2-数据来源不同" class="headerlink" title="2.数据来源不同"></a>2.数据来源不同</h3><ul><li>依赖注入 — 无需知道注入数据的来源</li><li>模块化 – 必须知道因为需要from</li></ul><h3 id="3-上下文不同"><a href="#3-上下文不同" class="headerlink" title="3.上下文不同"></a>3.上下文不同</h3><ul><li>依赖注入 —上下文就是组件实例，而且同一个组件定义是可以有多个组件实例的，我们可以根据<strong>不同的组件上下文</strong>提供不同的数据给后代组件</li><li>模块化 – 没有任何上下文的，仅仅是这个模块定义的数据，如果想要根据<strong>不同的情况提供不同数据</strong>，那么从 API 层面设计就需要做更改。比如允许用户传递一个参数：</li></ul><h1 id=""><a href="#" class="headerlink" title=""></a></h1><pre><code>export function getShareData(context) { // 根据不同的 context 参数返回不同的数据 }</code></pre><h2 id="2、依赖注入的缺陷和应用场景"><a href="#2、依赖注入的缺陷和应用场景" class="headerlink" title="2、依赖注入的缺陷和应用场景"></a>2、依赖注入的缺陷和应用场景</h2><p>由于依赖注入是和上下文相关的，所以它会将你应用<strong>程序中的组件与它们当前的组织方式耦合</strong>起来，这使得重构变得困难。，确认依赖注入的特点</p> <p style="color: red; font-size: 16px;font-weight: bolder;">祖先组件不需要知道哪些后代组件在使用它提供的数据，后代组件也不需要知道注入的数据来自哪里。</p><p>所以一旦在重构中不小心挪动了有依赖注入的后代组件的位置，或者是挪动了提供数据的祖先组件的位置，都有可能导致后代组件丢失注入的数据，进而导致应用程序异常。所以，个人感觉不应该在<strong>普通应用程序代码中使用依赖注入</strong>。</p><p>推荐方式就是在组件库的开发中使用，因为对于一个特定组件，它和其嵌套的子组件上下文联系很紧密。</p><p>主要原因在于组件库的场景中，依赖注入还是很方便的，除了示例中提供组件实例数据，还可以提供任意类型的数据。因为入口组件和它的相关子组件关联性是很强的，无论后代组件的结构如何变化，最终都会渲染在入口组件的子树上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了对依赖注入的使用场景和它的缺陷，更主要的是vue2.x与3.x的对比，主要就是3.x不再是通过编写一些<strong>组件配置去描述一个组件</strong>，更像是主动调用一些 API 去编写组件的实现逻辑,更在于去主动设计。</p><p>使用3.x的 Composition API 去编写组件，用户更清楚自己在做什么事情，不再是黑盒了。</p><p>还有就是Composition API 比 mixin（混入，分发 Vue 组件中的可复用功能） 更适合逻辑复用，例子对比</p><pre><code>//mixin使用&lt;template&gt;       &lt;div&gt;             Mouse position: x {{ x }} / y {{ y }}   &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import mousePositionMixin from './mouse' export default {       mixins: [mousePositionMixin] } &lt;/script&gt;</code></pre><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><p>在组件中申明了 mousePositionMixin，组件模板中使用的 x、y 就来源于这个 mixin，这一切都是 Vue.js 内部帮我们做的。如果该组件只引入这单个 mixin，问题倒不大，但如果这个组件引入的 mixin 越来越多，很容易出现命名冲突的情况，以及造成数据来源不清晰等问题。</p><p> Composition API 去编写功能类似的 hook 函数：</p><pre><code>&lt;template&gt;       &lt;div&gt; Mouse position: x {{ x }} / y {{ y }}       &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import useMousePosition from './mouse' export default { setup() {   const { x, y } = useMousePosition()   return { x, y }  } } &lt;/script&gt;</code></pre><p>我们可以清楚地分辨出模板中使用的 x、y 是来源于 useMousePosition 函数，即便我们引入更多的 hook 函数，也不会出现命名冲突的情况（就是代码量大一点）。</p><p>其实，二者都是把复用的逻辑放在单独的文件中维护。但从使用的方式而言，用户只是在需要混入 mixin 的组件中去申明这个 mixin</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前述&quot;&gt;&lt;a href=&quot;#前述&quot; class=&quot;headerlink&quot; title=&quot;前述&quot;&gt;&lt;/a&gt;前述&lt;/h2&gt;&lt;p&gt;涉及到&lt;strong&gt;组件通信的问题时&lt;/strong&gt;，一般都会想到父子组件之间的prop进行通信，但是要实现&lt;strong&gt;跨父子组件之</summary>
      
    
    
    
    <category term="vue3.0源码简析" scheme="https://useritem.github.io/categories/vue3-0%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    
    
    <category term="Composition" scheme="https://useritem.github.io/tags/Composition/"/>
    
  </entry>
  
  <entry>
    <title>响应式的实现</title>
    <link href="https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/Composition%20API%E8%AE%BE%E8%AE%A1/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/Composition%20API%E8%AE%BE%E8%AE%A1/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-07-06T14:16:43.000Z</published>
    <updated>2021-07-06T14:28:08.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>响应式与组件化都是vue.js的重要核心设计思想</p><p>对于响应式。它的本质是当数据变化后会自动执行某个函数，映射到组件的实现就是，当数据变化后，会自动触发组件的重新渲染。</p><h1 id="一、对比两代"><a href="#一、对比两代" class="headerlink" title="一、对比两代"></a>一、对比两代</h1><h2 id="vue2-0："><a href="#vue2-0：" class="headerlink" title="vue2.0："></a>vue2.0：</h2><p>vue.js2.0内部通过 Object.defineProperty API 劫持数据的变化，主要表现为在数据访问时，进行<strong>依赖收集</strong>，在数据变化时，进行<strong>依赖更新</strong>，其流程图为：</p><p><a href="https://imgtu.com/i/R66SzR"><img src="https://z3.ax1x.com/2021/07/02/R66SzR.png" alt="R66SzR.png"></a></p><p>在相应对象的实现上表现为：data与created中定义数据的区别，前者为响应式</p><h2 id="vue3-0"><a href="#vue3-0" class="headerlink" title="vue3.0"></a>vue3.0</h2><p>由于 Object.defineProperty API 的一些缺点：</p><div style="color: red; font-size: 20px;margin-top: 10px;">不能监听对象属性新增和删除；初始化阶段递归执行 Object.defineProperty 带来的性能负担。</div><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>vue3.0使用代理Proxy进行重写，并独立发布reactivity库，表现为<strong>使用reactvieAPI标记数据为响应式。</strong></p><p>流程图为</p><p><a href="https://imgtu.com/i/R669Q1"><img src="https://z3.ax1x.com/2021/07/02/R669Q1.png" alt="R669Q1.png"></a></p><h4 id="主要区别在于"><a href="#主要区别在于" class="headerlink" title="主要区别在于"></a>主要区别在于</h4><p>主要就是 劫持数据的方式改成用 Proxy 实现 ， 以及收集的依赖由 watcher 实例变成了组件副作用渲染函数 。</p><p>例子：</p><pre><code>setup() {  const state = reactive({    msg: 'msg reactive'  })return {    state}}</code></pre><p>解释：直接reactive API，它可以把一个对象数据变成响应式，让用户进行明确。</p><h1 id="二、分析Reactive-API"><a href="#二、分析Reactive-API" class="headerlink" title="二、分析Reactive API"></a>二、分析Reactive API</h1><h2 id="1、响应式原因"><a href="#1、响应式原因" class="headerlink" title="1、响应式原因"></a>1、响应式原因</h2><p>通过 createReactiveObject 函数把 target 变成了一个响应式对象。</p><p>此函数所作的几件事（五件）</p><ul><li>1.先判断target 是不是数组或者对象类型，如果不是则直接返回。<strong>所以原始数据 target 必须是对象或者数组。</strong>，对于本来就是响应式的返回自身，还有canObserve限制等     — 判断</li><li>2.利用 Proxy 创建响应式，返回结果就是响应式对象        —- 创建</li><li>3.给原始数据打个标识         — 标识</li></ul><h2 id="2、分析Proxy-API"><a href="#2、分析Proxy-API" class="headerlink" title="2、分析Proxy API"></a>2、分析Proxy API</h2><p>通过Proxy API劫持的target对象，也就是mutableHandlers 的实现，本质就是一种<strong>劫持</strong>observed 对象的一些操作，实现如下：</p><pre><code>const mutableHandlers = {      get,                              //访问对象属性时触发     set,                      //设置属性触发      deleteProperty,                  //删除      has,                    //in操作     ownKeys                         //通过 Object.getOwnPropertyNames 访问对象属性名会触发 }        </code></pre><p>因为无论命中哪个处理器函数，它都会做依赖收集和派发通知这两件事其中的一个，所以重点分析其中的get<strong>依赖的收集</strong>与set<strong>派发通知</strong>。</p><h2 id="3、依赖收集：get-函数"><a href="#3、依赖收集：get-函数" class="headerlink" title="3、依赖收集：get 函数"></a>3、依赖收集：get 函数</h2><p>其中get需要做的有四件事</p><h3 id="1-对特殊的-key-做了代理"><a href="#1-对特殊的-key-做了代理" class="headerlink" title="1.对特殊的 key 做了代理"></a>1.对特殊的 key 做了代理</h3><p>解释了为什么我们在 createReactiveObject 函数中判断响应式对象是否存在 __v_raw 属性，如果存在就返回这个响应式对象本身。</p><pre><code>  if (key === "__v_isReactive" /* isReactive */) {  // 代理 observed.__v_isReactive  return !isReadonly}else if (key === "__v_isReadonly" /* isReadonly */) {  // 代理 observed.__v_isReadonly  return isReadonly;}else if (key === "__v_raw" /* raw */) {  // 代理 observed.__v_raw  return target}</code></pre><h3 id="2-接着通过-Reflect-get-方法求值"><a href="#2-接着通过-Reflect-get-方法求值" class="headerlink" title="2.接着通过 Reflect.get 方法求值"></a>2.接着通过 Reflect.get 方法求值</h3><p>进行数组等判断处理：</p><pre><code>const targetIsArray = isArray(target)        // arrayInstrumentations 包含对数组一些方法修改的函数    //如果 target 是数组且 key 命中了 arrayInstrumentations，则执行对应的函数if (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) {  return Reflect.get(arrayInstrumentations, key, receiver)}        // 求值const res = Reflect.get(target, key, receiver)    // 内置 Symbol key 不需要依赖收集if (isSymbol(key) &amp;&amp; builtInSymbols.has(key) || key === '__proto__') {  return res}</code></pre><h3 id="3-执行-track-函数收集依赖"><a href="#3-执行-track-函数收集依赖" class="headerlink" title="3.执行 track 函数收集依赖"></a>3.执行 track 函数收集依赖</h3><pre><code> // 依赖收集!isReadonly &amp;&amp; track(target, "get" /* GET */, key)</code></pre><p>看似简单，但是想到我们的目的就是实现响应式，所以</p><div style="color: red; font-size: 20px;margin-top: 10px;">我们收集的依赖就是数据变化后执行的副作用函数。</div><p></p><p>回到实现原理的track函数中，直接看源码：</p><pre><code>// 是否应该收集依赖let shouldTrack = true// 当前激活的 effectlet activeEffect// 原始数据对象 map   -- 它的键是 target，值是 depsMap（也是一个map），作为依赖的 Map const targetMap = new WeakMap()//key 作为访问的属性function track(target, type, key) {      if (!shouldTrack || activeEffect === undefined) {        return  }//depsMap 的键是 target 的 key，值是 dep 集合  let depsMap = targetMap.get(target)  if (!depsMap) {        // 每个 target 对应一个 depsMap        targetMap.set(target, (depsMap = new Map()))  }  let dep = depsMap.get(key)   //存储依赖的副作用函数  if (!dep) {        // 每个 key 对应一个 dep 集合        depsMap.set(key, (dep = new Set()))  }  if (!dep.has(activeEffect)) {            // 收集当前激活的 effect 作为依赖    dep.add(activeEffect)           // 当前激活的 effect 收集 dep 集合作为依赖        activeEffect.deps.push(dep)  }}</code></pre><p>图片表示关系，实际就是<strong>大map：teagetMap 套 小map depsMap</strong>：</p><p><a href="https://imgtu.com/i/R6xEK1"><img src="https://z3.ax1x.com/2021/07/02/R6xEK1.md.png" alt="R6xEK1.md.png"></a></p><h4 id="实质："><a href="#实质：" class="headerlink" title="实质："></a>实质：</h4><p>所以每次 track ，就是把当前激活的副作用函数 activeEffect 作为依赖，然后收集到 target 相关的 depsMap 对应 key 下的依赖集合 dep 中。</p><h3 id="4-会对计算的值-res-进行判断"><a href="#4-会对计算的值-res-进行判断" class="headerlink" title="4.会对计算的值 res 进行判断"></a>4.会对计算的值 res 进行判断</h3><pre><code> return isObject(res)  ? isReadonly    ?    readonly(res)    // 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式    : reactive(res)  : res</code></pre><h2 id="4、派发通知：set-函数"><a href="#4、派发通知：set-函数" class="headerlink" title="4、派发通知：set 函数"></a>4、派发通知：set 函数</h2><p>，set即执行是执行 createSetter 函数需要做二件事：首先通过 Reflect.set 求值 ， 然后通过 trigger 函数派发通知 </p><p>重点就是trigger 函数的实现（四件事）：</p><ul><li><p>1.通过 targetMap 拿到 target 对应的依赖集合 depsMap；</p></li><li><p>2.创建运行的 effects 集合；</p></li><li><p>3.根据 key 从 depsMap 中找到对应的 effects 添加到 effects 集合；</p></li><li><p>4.遍历 effects 执行相关的副作用函数。</p></li></ul><p>所以每次 trigger 函数就是根据 target 和 key ，从 targetMap 中找到相关的所有副作用函数遍历执行一遍。</p><h1 id="三、名词解释"><a href="#三、名词解释" class="headerlink" title="三、名词解释"></a>三、名词解释</h1><h2 id="1、副作用函数"><a href="#1、副作用函数" class="headerlink" title="1、副作用函数"></a>1、副作用函数</h2><p>在Vue.js 3.0内部就有一个 effect 副作用函数，其函数内部通过执行 createReactiveEffect 函数去创建一个新的 effect 函数。</p><p>为了区分外部的 effect 函数，称为reactiveEffect 函数，它还有一些额外的属性以及参数，<strong>这个 reactiveEffect 函数就是响应式的副作用函数</strong>，当执行 trigger 过程派发通知的时候，执行的 effect 就是它。</p><h3 id="行为："><a href="#行为：" class="headerlink" title="行为："></a>行为：</h3><p>不仅仅是把全局的 activeEffect 指向它 ， 然后执行被包装的原始函数 fn 。真正为：</p><ul><li>1、首先它会判断 effect 的状态是否是 active</li><li>2、接着判断 effectStack 中是否包含 effect，如果没有就把 effect 压入栈内。之前我们提到，只要设置 activeEffect = effect 即可，</li></ul><h2 id="2、readonly-API"><a href="#2、readonly-API" class="headerlink" title="2、readonly API"></a>2、readonly API</h2><p>如果用 const 声明一个对象变量，虽然不能直接对这个变量赋值，但我们可以修改它的属。</p><p>如果我们希望创建只读对象，不能修改它的属性，也不能给这个对象添加和删除属性，让它变成一个真正意义上的<strong>只读对象</strong>。例：</p><pre><code>const original = {      foo: 1}const wrapped = readonly(original)wrapped.foo = 2// warn: Set operation on key "foo" failed: target is readonly.</code></pre><p>需要注意的是其实 readonly 和 reactive 函数的主要区别，就是执行 createReactiveObject 函数时的参数 isReadonly 不同。</p><h2 id="3、ref-API"><a href="#3、ref-API" class="headerlink" title="3、ref API"></a>3、ref API</h2><p>通过前面的分析，我们知道 reactive API 对传入的 target 类型有限制，必须是对象或者数组类型，而对于一些基础类型（比如 String、Number、Boolean）是不支持的。</p><p>但是有时候从需求上来说，可能我只希望把一个字符串变成响应式，却不得不封装成一个对象，这样使用上多少有一些不方便，于是 Vue.js 3.0 设计并实现了 ref API，<strong>直接对字符串进行封装</strong>。</p><p>例子：<br>    const msg = ref(‘Hello World’)<br>    msg.value = ‘Hello Vue’</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;响应式与组件化都是vue.js的重要核心设计思想&lt;/p&gt;
&lt;p&gt;对于响应式。它的本质是当数据变化后会自动执行某个函数，映射到组件的实</summary>
      
    
    
    
    <category term="vue3.0源码简析" scheme="https://useritem.github.io/categories/vue3-0%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    
    
    <category term="Composition" scheme="https://useritem.github.io/tags/Composition/"/>
    
  </entry>
  
  <entry>
    <title>生命周期</title>
    <link href="https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/Composition%20API%E8%AE%BE%E8%AE%A1/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/Composition%20API%E8%AE%BE%E8%AE%A1/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-07-06T14:16:20.000Z</published>
    <updated>2021-07-06T14:28:08.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vue.js 组件的生命周期包括创建、更新、销毁等过程。在这些过程中也会运行叫<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p><h3 id="vue2-x与3-x的对比"><a href="#vue2-x与3-x的对比" class="headerlink" title="vue2.x与3.x的对比"></a>vue2.x与3.x的对比</h3><pre><code>// Vue.js 2.x 定义生命周期钩子函数 export default {       created() {     // 做一些初始化工作   },   mounted() {         // 可以拿到 DOM 节点   },   beforeDestroy() { // 做一些清理操作   } } // &nbsp;Vue.js 3.x 生命周期 API 改写上例 import { onMounted, onBeforeUnmount } from 'vue' export default {  setup() {     // 做一些初始化工作 onMounted(() =&gt; {   // 可以拿到 DOM 节点 }) onBeforeUnmount(()=&gt;{   // 做一些清理操作 })   } }    </code></pre><p>说白了就是使用setup 函数代替了beforeCreate 和 created 钩子函数；onMounted API 替代了 Vue.js 2.x 的 mounted 钩子函数，用 onBeforeUnmount API 替代了 Vue.js 2.x 的 beforeDestroy 钩子函数。</p><p>3.x对于2.x的替换映射关系如下：</p><pre><code> beforeCreate -&gt; 使用 setup() created -&gt; 使用 use setup() beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy-&gt; onBeforeUnmount destroyed -&gt; onUnmounted activated -&gt; onActivated deactivated -&gt; onDeactivated errorCaptured -&gt; onErrorCaptured新增了两个用于调试的生命周期 API：onRenderTracked 和 onRenderTriggered。</code></pre><h1 id="生命周期钩子函数的背后原理"><a href="#生命周期钩子函数的背后原理" class="headerlink" title="生命周期钩子函数的背后原理"></a>生命周期钩子函数的背后原理</h1><h2 id="1、钩子函数的注册与实现"><a href="#1、钩子函数的注册与实现" class="headerlink" title="1、钩子函数的注册与实现"></a>1、钩子函数的注册与实现</h2><pre><code>const onBeforeMount = createHook('bm' /* BEFORE_MOUNT */) const onMounted = createHook('m' /* MOUNTED */) const onBeforeUpdate = createHook('bu' /* BEFORE_UPDATE */) const onUpdated = createHook('u' /* UPDATED */) const onBeforeUnmount = createHook('bum' /* BEFORE_UNMOUNT */) const onUnmounted = createHook('um' /* UNMOUNTED */) const onRenderTriggered = createHook('rtg' /* RENDER_TRIGGERED */) const onRenderTracked = createHook('rtc' /* RENDER_TRACKED */) const onErrorCaptured = (hook, target = currentInstance) =&gt; {       injectHook('ec' /* ERROR_CAPTURED */, hook, target) }</code></pre><p>除了onErrorCaptured，其他钩子函数都是通过 createHook 函数创建的，通过传入不同的字符串来表示不同的钩子函数。</p><p>所以实际就是探究<strong>createHook钩子函数的实现原理</strong></p><pre><code>const createHook = function(lifecycle)  {       return function (hook, target = currentInstance) {         injectHook(lifecycle, hook, target)       } }</code></pre><p>createHook 会返回一个函数，它的内部通过 <strong>injectHook</strong> 注册钩子函数。</p><p>注意使用craeteHook封装而不用injectHook进行封装主要原因就是体现一种<strong>函数柯里化技巧，减少参数</strong>，也可以：</p><pre><code>const onBeforeMount = function(hook,target = currentInstance) {     injectHook('bm', hook, target) } </code></pre><p>于是又变为探究<strong>injectHook函数的实现原理</strong></p><pre><code>function injectHook(type, hook, target = currentInstance, prepend = false) {       const hooks = target[type] || (target[type] = [])       // 封装 hook 钩子函数并缓存   const wrappedHook = hook.__weh || (hook.__weh = (...args) =&gt; {   if (target.isUnmounted) {     return   }   // 停止依赖收集   pauseTracking()   // 设置 target 为当前运行的组件实例   setCurrentInstance(target)   // 执行钩子函数   const res = callWithAsyncErrorHandling(hook, target, type, args)   setCurrentInstance(null)   // 恢复依赖收集   resetTracking()   return res })   if (prepend) {     hooks.unshift(wrappedHook)   }   else {     hooks.push(wrappedHook)   } }</code></pre><p>实际过程就是对对用户注册的钩子函数 hook 做了一层封装，然后添加到一个数组中，把数组保存在当前组件实例的 target 上，</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对于相同的钩子函数，会把封装的 wrappedHook 钩子函数缓存到 hook.__weh 中，这样后续通过 scheduler 方式执行的钩子函数就会被去重。</p><p>在后续执行 wrappedHook 函数时，会先<strong>停止依赖收集</strong>，因为钩子函数内部访问的响应式对象，通常都已经执行过依赖收集，防止二次以节约性能。</p><p>接着是设置 target 为当前组件实例。在 Vue.js 的内部，会一直维护当前运行的组件实例 currentInstance，在注册钩子函数的过程中，我们可以拿到当前运行组件实例 currentInstance，并用 target 保存，然后在钩子函数执行时，为了确保此时的 currentInstance 和注册钩子函数时一致，<strong>会通过 setCurrentInstance(target) 设置 target 为当前组件实例</strong>。</p><p>接下来就是通过 callWithAsyncErrorHandling 方法去执行我们注册的 hook 钩子函数，函数执行完毕则设置当前运行组件实例为 null，并恢复依赖收集。</p><h1 id="分析钩子函数的执行时机和应用场景"><a href="#分析钩子函数的执行时机和应用场景" class="headerlink" title="分析钩子函数的执行时机和应用场景"></a>分析钩子函数的执行时机和应用场景</h1><h2 id="1、onBeforeMount-和-onMounted-–组件挂载"><a href="#1、onBeforeMount-和-onMounted-–组件挂载" class="headerlink" title="1、onBeforeMount 和 onMounted –组件挂载"></a>1、onBeforeMount 和 onMounted –组件挂载</h2><p>onBeforeMount 注册的 beforeMount 钩子函数会在组件挂载之前执行，onMounted 注册的 mounted 钩子函数会在组件挂载之后执行。</p><p>先说一下三个钩子setup 函数、beforeMount 钩子函数与 mounted 钩子函数的使情况：</p><ul><li>对于组件初始化阶段发送异步请求的逻辑，三种都可以，注意的是由于异步请求有网络耗时，所以其时间大于一个Tick。</li><li>你想依赖 <strong>DOM</strong> 去做一些初始化操作，那就只能把相关逻辑放在 mounted 钩子函数中了，只有它晚于渲染。</li></ul><p>对于本周期函数的的执行时间的嵌套情况：</p><p>组件在挂载相关的生命周期钩子函数时，先执行父组件的 beforeMount，然后是子组件的 beforeMount，接着是子组件的 mounted ，最后执行父组件的 mounted。</p><h2 id="2、onBeforeUpdate-和-onUpdated-–-组件更新"><a href="#2、onBeforeUpdate-和-onUpdated-–-组件更新" class="headerlink" title="2、onBeforeUpdate 和 onUpdated – 组件更新"></a>2、onBeforeUpdate 和 onUpdated – 组件更新</h2><p>onBeforeUpdate 注册的 beforeUpdate 钩子函数会在组件更新之前执行，onUpdated 注册的 updated 钩子函数会在组件更新之后执行。</p><h3 id="对于beforeUpdate与updated需要注意的是："><a href="#对于beforeUpdate与updated需要注意的是：" class="headerlink" title="对于beforeUpdate与updated需要注意的是："></a>对于beforeUpdate与updated需要注意的是：</h3><p>在 beforeUpdate 钩子函数执行时，组件的 DOM 还未更新，如果你想在组件更新前访问 DOM，比如手动移除已添加的事件监听器，你可以注册这个钩子函数，在更新之前</p><p>在 updated 钩子函数执行时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</p><p>如果要<strong>监听数据的改变并执行某些逻辑</strong>，最好不要使用 updated 钩子函数而用<strong>计算属性或 watcher</strong> 取而代之，因为任何数据的变化导致的组件<strong>更新都会执行 updated 钩子函数</strong>。另外注意， <strong>不要</strong>在 updated 钩子函数中更改数据，因为这样会再次触发组件更新，导致<strong>无限递归更新</strong> 。</p><p>还有就是 Vue.js 的更新粒度是组件级别的，所以父组件更新不一定导致子组件的更新。</p><h2 id="3、onBeforeUnmount-和-onUnmounted-–-组件销毁"><a href="#3、onBeforeUnmount-和-onUnmounted-–-组件销毁" class="headerlink" title="3、onBeforeUnmount 和 onUnmounted  – 组件销毁"></a>3、onBeforeUnmount 和 onUnmounted  – 组件销毁</h2><p>一个之前一个之后，并且整个组件销毁的逻辑很简单，主要就是清理组件实例上绑定的 effects 副作用函数和注册的副作用渲染函数 update，以及调用 unmount 销毁子树。</p><h3 id="执行销毁"><a href="#执行销毁" class="headerlink" title="执行销毁"></a>执行销毁</h3><p>需要注意组件的销毁与渲染类似，都是通过使用<strong>递归</strong>，进行并且unmount 主要就是遍历子树，遇到组件节点时执行 unmountComponent，遇到普通节点时则删除 DOM 元素。</p><p>在组件销毁前，会检测组件实例上是有否有注册的 beforeUnmount 钩子函数 bum，如果有则通过 invokeArrayFns 执行。</p><h3 id="销毁之后"><a href="#销毁之后" class="headerlink" title="销毁之后"></a>销毁之后</h3><p>会检测组件实例上是否有注册的 unmounted 钩子函数 um，如果有则通过 queuePostRenderEffect 把 unmounted 钩子函数推入到 postFlushCbs 中，因为组件的销毁就是组件更新的一个分支逻辑，所以在 nextTick 后进行 flushJobs，因此此时再次执行 queuePostRenderEffect 推入队列的任务，会在同一个 Tick 内执行这些 postFlushCbs，也就是执行所有的 unmounted 钩子函数。</p><p>对于嵌套组件，组件在执行销毁相关的生命周期钩子函数时，先执行父组件的 beforeUnmount，再执行子组件的 beforeUnmount，然后执行子组件的 unmounted ，最后执行父组件的 unmounted。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>组件销毁虽然会清理一些定义的 effects 函数，删除组件内部的 DOM 元素，但是有些就只能在**beforeUnmount 或者 unmounted **钩子函数中清除（比如定时器）</p><p>例子：</p><pre><code>&lt;template&gt;      &lt;div&gt;         &lt;div&gt;   &lt;p&gt;{{count}}&lt;/p&gt;         &lt;/div&gt;     &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { ref, onBeforeUnmount } from 'vue' export default { setup () {   const count = ref(0)   const timer = setInterval(() =&gt; {     console.log(count.value++)   }, 1000)   onBeforeUnmount(() =&gt; {     clearInterval(timer)   })   return {     count   } }   } &lt;/script&gt;</code></pre><p>当我们在setup中进行定义定时器时，组件销毁之后，会触发触发 onBeforeUnmount 注册的 beforeUnmount 钩子函数，进行清除；</p><p>否则就会发现组件销毁后，虽然 DOM 被移除了，计时器仍然存在，并且会一直计时并在控制台输出，这就造成了不必要的内存泄漏。</p><h2 id="4、onErrorCaptured-–-处理错误"><a href="#4、onErrorCaptured-–-处理错误" class="headerlink" title="4、onErrorCaptured – 处理错误"></a>4、onErrorCaptured – 处理错误</h2><p>经典例子就是callWithErrorHandling，它就是执行一段函数并通过 handleError 处理错误。</p><h3 id="handleError实现-–找errorCaptured"><a href="#handleError实现-–找errorCaptured" class="headerlink" title="handleError实现 –找errorCaptured"></a>handleError实现 –找errorCaptured</h3><p>会从当前报错的组件的父组件实例开始，尝试去查找注册的 errorCaptured 钩子函数，如果有则遍历执行并且判断 errorCaptured 钩子函数的返回值是否为 true，如果是则说明这个错误已经得到了正确的处理，就会直接结束。</p><p>否则会继续遍历，遍历完当前组件实例的 errorCaptured 钩子函数后，如果这个错误还没得到正确处理，则向上查找它的父组件实例，以同样的逻辑去查找是否有正确处理该错误的 errorCaptured 钩子函数，直到查找完毕。</p><p>如果整个链路上都没有正确处理错误的 errorCaptured 钩子函数，则通过 logError 往控制台输出未处理的错误。所以 <strong>errorCaptured 本质上是捕获一个来自子孙组件的错误，它返回 true 就可以阻止错误继续向上传播。</strong></p><p>作用在于<strong>捕获所有子孙组件的错误，并且可以根据错误的类型和信息统计和上报错误。</strong></p><h2 id="5、onRenderTracked-和-onRenderTriggered"><a href="#5、onRenderTracked-和-onRenderTriggered" class="headerlink" title="5、onRenderTracked 和 onRenderTriggered"></a>5、onRenderTracked 和 onRenderTriggered</h2><p>新API，主要是在开发阶段渲染调试用的，其中onRenderTracked 和 onRenderTriggered 注册的钩子函数，原来是在副作用渲染函数的 onTrack 和 onTrigger 对应的函数中执行的。</p><h3 id="onTrack"><a href="#onTrack" class="headerlink" title="onTrack"></a>onTrack</h3><p>当访问一个响应式对象时，会执行 track 函数做<strong>依赖收集</strong>，然后在非生产环境下检测当前的 activeEffect 的配置有没有定义 onTrack 函数，如果有的则执行该方法。trigger 函数的实现：</p><pre><code>function trigger (target, type, key, newValue) { / 添加要运行的 effects 集合 const run = (effect) =&gt; { if ((process.env.NODE_ENV !== 'production') &amp;&amp; effect.options.onTrigger) {     // 执行 onTrigger   effect.options.onTrigger({     effect,     target,     key,     type,     newValue,     oldValue,     oldTarget   }) } if (effect.options.scheduler) {   effect.options.scheduler(effect) } else {   effect() }   } // 遍历执行 effects effects.forEach(run) }</code></pre><p>所以副作用渲染函数执行的时候，activeEffect 就是这个副作用渲染函数，这时访问响应式数据就会触发 track 函数，在<strong>执行完依赖收集</strong>后，会<strong>执行 onTrack 函数</strong>，也就是遍历执行我们注册的 renderTracked 钩子函数。</p><p>renderTracked 和 renderTriggered 钩子函数的实际应用：</p><pre><code>&lt;template&gt; &lt;div&gt; &lt;div&gt;   &lt;p&gt;{{count}}&lt;/p&gt;   &lt;button @click="increase"&gt;Increase&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { ref, onRenderTracked, onRenderTriggered } from 'vue' export default { setup () {   const count = ref(0)   function increase () {     count.value++   }   onRenderTracked((e) =&gt; {     console.log(e)     debugger   })   onRenderTriggered((e) =&gt; {     console.log(e)     debugger   })   return {     count,     increase   } } } &lt;/script&gt;</code></pre><p>像这样在开发阶段，我们可以通过注册这两个钩子函数，来追踪组件渲染的依赖来源以及触发组件重新渲染的数据更新来源</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://imgtu.com/i/RIpWb8"><img src="https://z3.ax1x.com/2021/07/05/RIpWb8.md.png" alt="RIpWb8.md.png"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Vue.js 组件的生命周期包括创建、更新、销毁等过程。在这些过程中也会运行叫&lt;strong&gt;生命周期钩子&lt;/strong&gt;的函数，这给了用</summary>
      
    
    
    
    <category term="vue3.0源码简析" scheme="https://useritem.github.io/categories/vue3-0%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    
    
    <category term="Composition" scheme="https://useritem.github.io/tags/Composition/"/>
    
  </entry>
  
  <entry>
    <title>计算属性API</title>
    <link href="https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/Composition%20API%E8%AE%BE%E8%AE%A1/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7API/"/>
    <id>https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/Composition%20API%E8%AE%BE%E8%AE%A1/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7API/</id>
    <published>2021-07-06T14:15:58.000Z</published>
    <updated>2021-07-06T14:28:08.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算属性是vue一个常用的响应式API，它允许用户定义一个计算方法，然后根据一些依赖的响应式数据计算出新值并返回。依赖发生变化时，计算属性也会进行自动计算与值的获取。</p><p>对于vue.js2.0表现为定义组件对象中的computed属性</p><p>而3.0版本则可以使用单独的计算属性API</p><h1 id="一、使用方法"><a href="#一、使用方法" class="headerlink" title="一、使用方法"></a>一、使用方法</h1><h2 id="1、传入函数-–只能获取get，"><a href="#1、传入函数-–只能获取get，" class="headerlink" title="1、传入函数 –只能获取get，"></a>1、传入函数 –只能获取get，</h2><pre><code>const count = ref(1) const plusOne = computed(() =&gt; count.value + 1) console.log(plusOne.value) // 2 plusOne.value++ // error count.value++ console.log(plusOne.value) // 3</code></pre><p>我们先使用 ref API 创建了一个响应式对象 count，然后使用 computed API 创建了另一个响应式对象 plusOne。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>这时候我们只能修改count的值来是plusOne.value的值发生变化，修改plusOne.value会报错。</p><p>主要由于传递的是一个函数，所以表示这为get函数，只能进行值的获取，我们只能根据响应式对象count重新计算出新的值，这也就是它被叫做计算属性的原因。</p><p>而这个响应式对象，就是计算属性的依赖。</p><h2 id="2、传入对象-–-可获得也可改"><a href="#2、传入对象-–-可获得也可改" class="headerlink" title="2、传入对象 – 可获得也可改"></a>2、传入对象 – 可获得也可改</h2><p>主要表现为函数是嵌套在对象中的，具体表现为</p><pre><code>const count = ref(1) const plusOne = computed({       get: () =&gt; count.value + 1,       set: val =&gt; { count.value = val - 1   } }) plusOne.value = 1 console.log(count.value) // 0</code></pre><p>这里多了一个setter函数  — 修改plusOne.value 的值就会触发</p><p> setter 函数内部实际上会根据传入的参数修改计算属性的<strong>依赖值 count.value</strong>，因为一旦依赖的值被修改了，此时进而调用getter函数，金额对获取值进行修改。</p><h1 id="二、分析实现"><a href="#二、分析实现" class="headerlink" title="二、分析实现"></a>二、分析实现</h1><h2 id="1、分析-computed-API的实现"><a href="#1、分析-computed-API的实现" class="headerlink" title="1、分析 computed API的实现"></a>1、分析 computed API的实现</h2><p>computed函数的三件事情 – <strong>一标准两创建</strong></p><h3 id="（1）标准化参数"><a href="#（1）标准化参数" class="headerlink" title="（1）标准化参数"></a>（1）标准化参数</h3><p>由于computed 函数接受两种类型的参数，一个是 getter 函数，一个是拥有 getter 和 setter 函数的对象。</p><p>所以我们通过判断参数的类型，初始化了函数内部定义的 getter 和 setter 函数。</p><h3 id="（2）创建副作用函数-runner-–对getter的封装"><a href="#（2）创建副作用函数-runner-–对getter的封装" class="headerlink" title="（2）创建副作用函数 runner –对getter的封装"></a>（2）创建副作用函数 runner –对getter的封装</h3><p>computed 内部通过 effect 创建了一个副作用函数</p><pre><code> const runner = effect(getter, { // 延时执行，如果lazy不置为true的话，每次创建effect的时候都会立即执行一次// 而我们要实现computed显然是不需要的lazy: true, // 标记这是一个 computed effect 用于在 trigger 阶段的优先级排序 computed: true, // 调度执行的实现 scheduler: () =&gt; {   if (!dirty) {     dirty = true     // 派发通知，通知运行访问该计算属性的 activeEffect     trigger(computed, "set" /* SET */, 'value')   } } </code></pre><p>  })<br>主要就是对getter函数的封装，第二个参数分别表示：</p><ul><li> lazy 为 true 表示 effect 函数返回的 runner 并不会立即执行</li><li> computed 为 true 用于表示这是一个 computed effect，用于 trigger 阶段的优先级排序</li><li> scheduler 表示它的调度运行的方式</li></ul><h4 id="effect函数："><a href="#effect函数：" class="headerlink" title="effect函数："></a>effect函数：</h4><p>effect 函数一般都是做了三步工作：</p><p>1、是否已经被effect勾搭过</p><p>2、创建effect勾搭过程</p><p>3、是否默认执行effect函数</p><h3 id="（3）创建-computed-对象并返回"><a href="#（3）创建-computed-对象并返回" class="headerlink" title="（3）创建 computed 对象并返回"></a>（3）创建 computed 对象并返回</h3><pre><code> // 创建 computed 对象 computed = { __v_isRef: true, // 暴露 effect 对象以便计算属性可以停止计算 effect: runner, get value() {   // 计算属性的 getter   if (dirty) {     // 只有数据为脏的时候才会重新计算     value = runner()     dirty = false   }  // 依赖收集，收集运行访问该计算属性的 activeEffect   track(computed, "get" /* GET */, 'value')   return value }, set value(newValue) {   // 计算属性的 setter   setter(newValue) }   } //返回要需要为对象形式，如果不用对象的 get 方法的话我们就需要手动再调用一次 computed() return computed </code></pre><p>这个对象也拥有 getter 和 setter 函数。当 computed 对象被访问的时候会触发 getter，然后会判断是否 dirty，如果是就执行 runner，然后做依赖收集；</p><p>当我们直接设置 computed 对象时会触发 setter，即执行 computed 函数内部定义的 setter 函数。</p><h2 id="2、计算属性的运行机制"><a href="#2、计算属性的运行机制" class="headerlink" title="2、计算属性的运行机制"></a>2、计算属性的运行机制</h2><p>先说明其中两个重要变量：</p><ul><li>第一个 dirty 表示一个计算属性的值是否是“脏的”，用来判断需不需要重新计算</li><li>第二个 value 表示计算属性每次计算后的结果。</li></ul><p>举例说明：</p><pre><code>&lt;template&gt;       &lt;div&gt; {{ plusOne }}       &lt;/div&gt; &lt;button @click="plus"&gt;plus&lt;/button&gt; &lt;/template&gt; &lt;script&gt;  import { ref, computed } from 'vue'   export default {    setup() {   const count = ref(0)   const plusOne = computed(() =&gt; {     return count.value + 1   })    //传入getter函数，为区分称为 computed getter  function plus() {     count.value++   }   return {     plusOne,     plus   }     }   } &lt;/script&gt;</code></pre><h3 id="1-过程"><a href="#1-过程" class="headerlink" title="1.过程"></a>1.过程</h3><p>当组件渲染阶段会访问 plusOne，也就触发了 plusOne 对象的 <strong>getter 函数</strong> ：</p><pre><code>get value() {       // 计算属性的 getter       if (dirty) { // 只有数据为脏的时候才会重新计算 value = runner() dirty = false   }   // 依赖收集，收集运行访问该计算属性的 activeEffect   track(computed, "get" /* GET */, 'value')   return value }</code></pre><p>由于默认 dirty 是 true，表示<strong>重新计算</strong>，并执行runner函数，即执行上面的 computed getter，即count.value + 1，又因为访问了 count 的值，并且由于 count 也是一个响应式对象，所以就会触发</p><div style="color: red; font-size: 20px;margin-top: 10px;"> count 对象的依赖收集过程。</div><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="2-注意"><a href="#2-注意" class="headerlink" title="2.注意"></a>2.注意</h3><p>由于是在 runner 执行的时候访问 count，所以这个时候的 activeEffect 是 runner 函数。</p><p>runner 函数执行完毕，会把 dirty 设置为 false，并进一步执行 track（computed,”get”,’value’) 函数做依赖收集，这个时候 runner 已经执行完了，所以 <strong>activeEffect 是组件副作用渲染函数</strong>。</p><h4 id="即注意两个依赖收集过程："><a href="#即注意两个依赖收集过程：" class="headerlink" title="即注意两个依赖收集过程："></a>即注意两个依赖收集过程：</h4><ul><li>对于 plusOne 来说，它收集的依赖是组件副作用渲染函数；</li><li>对于 count 来说，它收集的依赖是 plusOne 内部的 runner 函数。</li></ul><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="3-执行"><a href="#3-执行" class="headerlink" title="3.执行"></a>3.执行</h3><p>然后当我们点击按钮的时候，会执行 plus 函数，函数内部通过 count.value++ 修改 count 的值，并<strong>自动派发通知set</strong>，通过对响应式的了解可知，这是指就是 trigger 函数的作用。</p><p>请注意，这里不是直接调用 runner 函数，而是把 runner 作为参数去执行 scheduler 函数，而computed API 内部创建副作用函数时，已经配置了 scheduler 函数，如下：</p><pre><code>scheduler: () =&gt; {       if (!dirty) {     dirty = true // 派发通知，通知运行访问该计算属性的 activeEffect trigger(computed, "set" /* SET */, 'value')   } }//关键在于通知执行 plusOne 依赖的组件渲染副作用函数，即触发组件的重新渲染。</code></pre><p>在组件重新渲染的时候，会再次访问 plusOne，我们发现这个时候 dirty 为 true（见上），然后会再次执行 computed getter（plusOne的getter），此时才会执行 count.value + 1 求得新值。</p><p>这就是虽然组件没有直接访问 count，但是当我们修改 count 的值的时候，组件仍然会重新渲染的原因。</p><p>文字绕来绕去，主要带着dirty（判断是否重新计算）与value（结果）变量去看，也结合图片理解：</p><p><a href="https://imgtu.com/i/RRF0w4"><img src="https://z3.ax1x.com/2021/07/03/RRF0w4.md.png" alt="RRF0w4.md.png"></a></p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>得出计算属性的两大特点</p><ul><li><p>1.延时计算，只有当我们访问计算属性的时候，它才会真正运行 computed getter 函数计算；</p></li><li><p>2，缓存，它的内部会缓存上次的计算结果 value，而且只有 <strong>dirty 为 true 时才会重新计算</strong>。如果访问计算属性时 dirty 为 false，那么直接返回这个 value。</p></li></ul><p>所以说单纯使用普通函数相比，</p><div style=" font-size: 20px;margin-top: 10px; background-color:pink">计算属性的优势是：只要依赖不变化，就可以使用缓存的 value 而不用每次在渲染组件的时候都执行函数去计算，这是典型的<strong>空间换时间的优化思想</strong>。</div><p></p><h2 id="3、嵌套计算属性"><a href="#3、嵌套计算属性" class="headerlink" title="3、嵌套计算属性"></a>3、嵌套计算属性</h2><p>主要表现为不在不在渲染函数中访问 plusOne，而在另一个计算属性中访问：</p><pre><code>const count = ref(0) const plusOne = computed(() =&gt; {       return count.value + 1 }) const plusTwo = computed(() =&gt; {      return plusOne.value + 1 }) console.log(plusTwo.value)</code></pre><p>这里需要好好理解就是：：–》我们访问 plusTwo 的时候，过程和前面都差不多，同样也是两个依赖收集的过程。</p><p>—》对于 plusOne 来说，它收集的依赖是 plusTwo 内部的 runner 函数；</p><p>—》对于 count 来说，它收集的依赖是 plusOne 内部的 runner 函数。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>当我们修改 count 的值时，它会派发通知，先运行 plusOne 内部的 scheduler 函数<strong>（设置dirty = true，触发组件的重新渲染）</strong>，把 plusOne 内部的 dirty 变为 true，然后执行 trigger 函数再次派发通知，接着运行 plusTwo 内部的 scheduler 函数，把 plusTwo 内部的 dirty 设置为 true。</p><p>然后当我们再次访问 plusTwo 的值时，发现 dirty 为 true，就会执行 plusTwo 的 computed getter 函数去执行 plusOne.value + 1，进而执行 plusOne 的 computed gette 即 count.value + 1 + 1，求得最终新值 2。</p><p>所以嵌套对于计算属性的使用无影响</p><h2 id="4、计算属性的执行顺序"><a href="#4、计算属性的执行顺序" class="headerlink" title="4、计算属性的执行顺序"></a>4、计算属性的执行顺序</h2><p>主要就是因为 effect 函数依赖了 plusOne 和 count，所以 plusOne 先计算会更合理，即computed runner 的执行优先于普通的 effect 函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;计算属性是vue一个常用的响应式API，它允许用户定义一个计算方法，然后根据一些依赖的响应式数据计算出新值并返回。依赖发生变化时，计算属性也</summary>
      
    
    
    
    <category term="vue3.0源码简析" scheme="https://useritem.github.io/categories/vue3-0%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    
    
    <category term="Composition" scheme="https://useritem.github.io/tags/Composition/"/>
    
  </entry>
  
  <entry>
    <title>vue3.0的优化</title>
    <link href="https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/vue3-0%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>https://useritem.github.io/2021/07/06/vue3.0%E6%BA%90%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/vue3-0%E7%9A%84%E4%BC%98%E5%8C%96/</id>
    <published>2021-07-06T14:15:43.000Z</published>
    <updated>2021-07-06T14:28:08.424Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言：vue发展历程"><a href="#前言：vue发展历程" class="headerlink" title="前言：vue发展历程"></a>前言：vue发展历程</h2><p>vue.js.1.x —-&gt; vue.js.2.x  最大的升级在于<strong>引用的虚拟DOM</strong>，为后期的服务端渲染与之后的跨端框架提供</p><p>了方便，但是也有一些问题：</p><p>1、源码自身的维护性</p><p>2、数据量大后嗲了的渲染与更新的性能问题</p><p>3、一些想舍弃但是为了兼容还保留的鸡肋API</p><p>之后vue.js.3.0的目的在于：</p><p>1、更好的编程体验</p><p>2、更好的TypeScript支持</p><p>3、更好的逻辑复用实践</p><p>于是vue.js.3.0出现了！</p><h1 id="vue3-0的优化"><a href="#vue3-0的优化" class="headerlink" title="vue3.0的优化"></a>vue3.0的优化</h1><h2 id="一、源码的优化"><a href="#一、源码的优化" class="headerlink" title="一、源码的优化"></a>一、源码的优化</h2><p>源码的优化，指小右对于vue.js框架本身开发的优化，目的在于让代码更易于开发与维护</p><h3 id="1、优化主要体现："><a href="#1、优化主要体现：" class="headerlink" title="1、优化主要体现："></a>1、优化主要体现：</h3><p>使用monorepo和typeScript管理与开发源码 — 提升自身代码可维护性</p><h4 id="更好的代码管理-monorepo"><a href="#更好的代码管理-monorepo" class="headerlink" title="更好的代码管理:monorepo"></a>更好的代码管理:monorepo</h4><p>之前的管理在src的目录下，各代码块拆分如下：</p><p><a href="https://imgtu.com/i/RV20HK"><img src="https://z3.ax1x.com/2021/06/22/RV20HK.png" alt="RV20HK.png"></a></p><p>vue3.0J进行维护的时候则使用了monorepo，通过不同的功能来拆分到packages下面的不同子目录中，大概结构如下：</p><p><a href="https://imgtu.com/i/RVRkK1"><img src="https://z3.ax1x.com/2021/06/22/RVRkK1.png" alt="RVRkK1.png"></a></p><p>相对于 Vue.js 2.x 的源码组织方式，monorepo 把这些模块拆分到不同的 package 中，每个 package 有<strong>各自</strong>的 API、类型定义和测试。</p><p>这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。</p><p>此外这些响应式库可以进行单独的使用，独立于vue.js，进行单独依赖，这是vue.js.2.x是做不到的</p><h4 id="TypeScript-–-有类型的JS"><a href="#TypeScript-–-有类型的JS" class="headerlink" title="TypeScript – 有类型的JS"></a>TypeScript – 有类型的JS</h4><p>开始 — Vue.js 1.x 版本的源码是没有用类型语言的，小右用 JavaScript 开发了整个框架</p><p>但对于复杂的框架项目开发，使用类型语言非常有利于代码的维护，作用</p><ul><li><p>1、可以在编码期间帮你做类型检查，避免一些因类型问题导致的错误；</p></li><li><p>2、可以利于它去定义接口的类型，利于 IDE 对变量类型的推导</p></li></ul><p>重构 2.0 的时候，小右选型了 Flow（Facebook出品），重构 2.0 的时候，小右选型了 Flow，虽然它以非常小的成本对已有的 JavaScript 代码迁入，非常灵活。</p><p>但是对于一些复杂场景类型的检查，支持得并不好，也出现了烂尾的现象，所以3.0的版本编采用的TypeScript</p><h2 id="二、性能优化"><a href="#二、性能优化" class="headerlink" title="二、性能优化"></a>二、性能优化</h2><h3 id="1、源码体积优化"><a href="#1、源码体积优化" class="headerlink" title="1、源码体积优化"></a>1、源码体积优化</h3><h4 id="因为-JavaScript-包体积越小，意味着网络传输时间越短，JavaScript-引擎解析包的速度也越快，所以进行源码压缩。"><a href="#因为-JavaScript-包体积越小，意味着网络传输时间越短，JavaScript-引擎解析包的速度也越快，所以进行源码压缩。" class="headerlink" title="因为 JavaScript 包体积越小，意味着网络传输时间越短，JavaScript 引擎解析包的速度也越快，所以进行源码压缩。"></a>因为 JavaScript 包体积越小，意味着网络传输时间越短，JavaScript 引擎解析包的速度也越快，所以进行源码压缩。</h4><p>优化方式</p><ul><li><p>1、移除一些冷门的 feature（比如 filter、inline-template 等）</p></li><li><p>2、引入 tree-shaking 的技术，减少打包体积</p></li></ul><p>tree-shaking的原理在于 – tree-shaking 依赖 ES2015 模块语法的静态结构（即 import 和 export），通过编译阶段的静态分析，找到没有引入的模块并打上标记。</p><p>简单来说就是不用的代码，进行标记，之后压缩阶段会利用例如 <strong>uglify-js、terser</strong> 等压缩工具，进行删除，不会出现在打包后的代码中。</p><h3 id="2、数据劫持优化"><a href="#2、数据劫持优化" class="headerlink" title="2、数据劫持优化"></a>2、数据劫持优化</h3><p>Vue.js 区别于 React 的一大特色是它的数据是响应式的，这个特性从 Vue.js 1.x 版本就一直伴随着，</p><p>DOM作为数据的映射，数据发生变化之后，<strong>自动更新</strong>DOM，所以用户只需专注于数据的修改即可。</p><p>所以vue.js如何进行内部实现的呢：</p><p>那就是必须劫持数据的访问和更新</p><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p>代表数据改变之后，<strong>自动执行</strong>一些代码去更新 DOM，为了让Vue.js 知道更新哪一片 DOM，</p><p>所以在渲染 DOM 的时候访问了数据，我们可以对它进行访问劫持，即建立了内部的依赖关系</p><h4 id="Vue-js-1-x-和-Vue-js-2-x-的方法："><a href="#Vue-js-1-x-和-Vue-js-2-x-的方法：" class="headerlink" title="Vue.js 1.x 和 Vue.js 2.x 的方法："></a>Vue.js 1.x 和 Vue.js 2.x 的方法：</h4><p>通过 Object.defineProperty 这个 API 去劫持数据的 getter 和 setter，具体为：</p><pre><code>Object.defineProperty(data, 'a',{      get(){        // track      },      set(){        // trigger      }})</code></pre><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>这个API缺陷在于，它必须预先知道要拦截的 key 是什么，所以它并不能检测对象属性的添加和删除。</p><p>尽管 Vue.js 为了解决这个问题提供了 $set 和 $delete 实例方法，但是对于用户来说，还是增加了一定的心智<br>负担。</p><p>并且当我们嵌套过深，定义的响应式数据过于复杂，这就会有相当大的性能负担。</p><h4 id="Vue-js-3-0-—-代理"><a href="#Vue-js-3-0-—-代理" class="headerlink" title="Vue.js 3.0 — 代理"></a>Vue.js 3.0 — 代理</h4><p>当使用了 Proxy API 做数据劫持，它的内部是这样的</p><pre><code>observed = new Proxy(data, {      get() {            // track      },    set() {            // trigger     }})</code></pre><p>由于它劫持的是<strong>整个对象</strong>，那么自然对于对象的属性的增加和删除都能检测到。</p><p>但要注意的是，Proxy API 并不能监听到内部深层次的对象变化，因此 Vue.js 3.0 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归，这样无疑也在很大程度上提升了性能.</p><h3 id="3、编译优化"><a href="#3、编译优化" class="headerlink" title="3、编译优化"></a>3、编译优化</h3><p>Vue.js 2.x 从 new Vue 开始渲染成 DOM 的流程如下：</p><p><a href="https://imgtu.com/i/RVTQBj"><img src="https://z3.ax1x.com/2021/06/22/RVTQBj.png" alt="RVTQBj.png"></a></p><p><strong>响应式过程</strong>就发生在图中的 init 阶段，另外 template compile to render function 的流程是可以借助 vue-loader 在 webpack 编译阶段离线完成，并非一定要在运行时完成。</p><p>所以想优化整个 Vue.js 的运行时，除了数据劫持部分的优化，我们可以在耗时相对较多的 patch 阶段想办法，Vue.js 3.0 也是这么做的，并且它通过在编译阶段优化编译的结果，来实现运行时 patch 过程的优化。</p><h2 id="三、语法-API-优化：Composition-API"><a href="#三、语法-API-优化：Composition-API" class="headerlink" title="三、语法 API 优化：Composition API"></a>三、语法 API 优化：Composition API</h2><h3 id="1、优化逻辑组织"><a href="#1、优化逻辑组织" class="headerlink" title="1、优化逻辑组织"></a>1、优化逻辑组织</h3><h4 id="Vue-js-1-x-和-2-x-–-Options-API"><a href="#Vue-js-1-x-和-2-x-–-Options-API" class="headerlink" title="Vue.js 1.x 和 2.x – Options API"></a>Vue.js 1.x 和 2.x – Options API</h4><p>在 Vue.js 1.x 和 2.x 版本中，编写组件本质就是在编写一个“包含了描述组件选项的对象”，我们把它称为 Options API，</p><p>Options API 的设计是按照 methods、computed、data、props 这些不同的选项分类，组件小时候，非常方便。</p><p>但是当组件大时，一个组件可能有多个逻辑关注点，当使用 Options API 的时候，每一个关注点都有自己的 Options，如果需要修改一个逻辑点关注点，就需要在单个文件中不断上下切换和寻找。</p><h4 id="vue3-0-–-Composition-API"><a href="#vue3-0-–-Composition-API" class="headerlink" title="vue3.0 – Composition API"></a>vue3.0 – Composition API</h4><p>它有一个很好的机制去解决这样的问题，就是将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去。</p><p>区分两者关键在于某个逻辑关注点，是否在<strong>一个函数</strong>或者说是否整合。</p><h3 id="2、优化逻辑复用"><a href="#2、优化逻辑复用" class="headerlink" title="2、优化逻辑复用"></a>2、优化逻辑复用</h3><p>当我们开发项目变得复杂的时候，免不了需要抽象出一些复用的逻辑。在 Vue.js 2.x 中，我们通常会用 mixins 去复用逻辑。</p><p>举一个鼠标位置侦听的例子：编写如下函数 mousePositionMixin：</p><pre><code>const mousePositionMixin = {  data() {    return {     x: 0,      y: 0    }  },mounted() {    window.addEventListener('mousemove', this.update)  },destroyed() {    window.removeEventListener('mousemove', this.update)  },methods: {    update(e) {      this.x = e.pageX      this.y = e.pageY}  }}export default mousePositionMixin</code></pre><p>然后在组件中使用：</p><pre><code>&lt;template&gt;  &lt;div&gt;        Mouse position: x {{ x }} / y {{ y }}  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import mousePositionMixin from './mouse'export default {  mixins: [mousePositionMixin]}&lt;/script&gt;</code></pre><p>使用单个 mixin 似乎问题不大，但是当我们一个组件混入大量不同的 mixins 的时候，会存在两个非常明显的问题：<strong>命名冲突和数据来源不清晰</strong>。</p><p>对于Vue.js 3.0 设计的 Composition API来说：例子如下：</p><pre><code>import { ref, onMounted, onUnmounted } from 'vue'export default function useMousePosition() {      const x = ref(0)      const y = ref(0)      const update = e =&gt; {    x.value = e.pageX    y.value = e.pageY  }  onMounted(() =&gt; {    window.addEventListener('mousemove', update)  })  onUnmounted(() =&gt; {    window.removeEventListener('mousemove', update)  })  return { x, y }}</code></pre><p>我们约定 useMousePosition 这个函数为 hook 函数，然后在组件中使用</p><pre><code>&lt;template&gt;  &lt;div&gt;    Mouse position: x {{ x }} / y {{ y }}  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;      import useMousePosition from './mouse'      export default {    setup() {          const { x, y } = useMousePosition()          return { x, y }    }  }&lt;/script&gt;</code></pre><p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题。</p><p>Composition API 除了在逻辑复用方面有优势，也会有更好的<strong>类型支持</strong>，因为它们都是一些函数，在调用函数时，自然所有的类型就被推导出来了，不像 Options API 所有的东西使用 this。另外，Composition API 对 tree-shaking 友好，代码也更容易压缩。</p><p>需要注意的是Composition API 属于 API 的增强，它并不是 Vue.js 3.0 组件开发的范式，如果你的组件足够简单，你还是可以使用 Options API。</p><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p>Vue.js 3.0 引入 RFC：来确保他的改动和设计都是经过讨论并确认的，<strong>使每个版本改动可控</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言：vue发展历程&quot;&gt;&lt;a href=&quot;#前言：vue发展历程&quot; class=&quot;headerlink&quot; title=&quot;前言：vue发展历程&quot;&gt;&lt;/a&gt;前言：vue发展历程&lt;/h2&gt;&lt;p&gt;vue.js.1.x —-&amp;gt; vue.js.2.x  最大的升级在于&lt;</summary>
      
    
    
    
    <category term="vue3.0源码简析" scheme="https://useritem.github.io/categories/vue3-0%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    
    
    <category term="vue3.0优化分析" scheme="https://useritem.github.io/tags/vue3-0%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>axios源码特殊功能深入</title>
    <link href="https://useritem.github.io/2021/06/19/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/axios%E6%BA%90%E7%A0%81%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD%E6%B7%B1%E5%85%A5/"/>
    <id>https://useritem.github.io/2021/06/19/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/axios%E6%BA%90%E7%A0%81%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD%E6%B7%B1%E5%85%A5/</id>
    <published>2021-06-19T03:38:21.000Z</published>
    <updated>2021-06-19T11:25:04.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="axios拦截器与请求取消的模拟实现"><a href="#axios拦截器与请求取消的模拟实现" class="headerlink" title="axios拦截器与请求取消的模拟实现"></a>axios拦截器与请求取消的模拟实现</h1><h2 id="一、axios拦截器"><a href="#一、axios拦截器" class="headerlink" title="一、axios拦截器"></a>一、axios拦截器</h2><h3 id="1、构造函数"><a href="#1、构造函数" class="headerlink" title="1、构造函数"></a>1、构造函数</h3><pre><code>    function Axios(config){        this.config = config;        this.interceptors = {            request: new InterceptorManager(),            response: new InterceptorManager(),        }    }</code></pre><h3 id="2、顺利执行拦截器"><a href="#2、顺利执行拦截器" class="headerlink" title="2、顺利执行拦截器"></a>2、顺利执行拦截器</h3><pre><code>         //发送请求  难点与重点        Axios.prototype.request = function(config){            //创建一个 promise 对象            let promise = Promise.resolve(config);            //创建一个数组            const chains = [dispatchRequest, undefined];            //处理拦截器            //请求拦截器 将请求拦截器的回调 压入到 chains 的前面  request.handles = []            this.interceptors.request.handlers.forEach(item =&gt; {                chains.unshift(item.fulfilled, item.rejected);            });            //响应拦截器            this.interceptors.response.handlers.forEach(item =&gt; {                chains.push(item.fulfilled, item.rejected);                //请求拦截器在前面，响应拦截器在后面            });            //遍历，弹完之后chains没有元素了，所以不可等于0            while(chains.length &gt; 0){                promise = promise.then(chains.shift(), chains.shift());            }            return promise;        }    //发送请求    function dispatchRequest(config){        //返回一个promise 队形        return new Promise((resolve, reject) =&gt; {            resolve({                status: 200,                statusText: 'OK'            });        });    }</code></pre><h3 id="3、拦截器管理构造函数"><a href="#3、拦截器管理构造函数" class="headerlink" title="3、拦截器管理构造函数"></a>3、拦截器管理构造函数</h3><pre><code>    function InterceptorManager(){        this.handlers = [];    }    InterceptorManager.prototype.use = function(fulfilled, rejected){        this.handlers.push({            fulfilled,            rejected        })    }</code></pre><p>原理在于当调用use函数时，就立即将函数fulfilled, rejected做成一个对象，并直接压入数组中</p><h3 id="4、创建axios，并进行属性的添加"><a href="#4、创建axios，并进行属性的添加" class="headerlink" title="4、创建axios，并进行属性的添加"></a>4、创建axios，并进行属性的添加</h3><pre><code>    //创建实例    let context = new Axios({});    //创建axios函数    let axios = Axios.prototype.request.bind(context); //保证this的指向没问题    //将 context 属性 config interceptors 添加至 axios 函数对象身上    Object.keys(context).forEach(key =&gt; {        axios[key] = context[key];    });</code></pre><h2 id="二、axios取消请求的模拟实现"><a href="#二、axios取消请求的模拟实现" class="headerlink" title="二、axios取消请求的模拟实现"></a>二、axios取消请求的模拟实现</h2><h3 id="1、构造函数-1"><a href="#1、构造函数-1" class="headerlink" title="1、构造函数"></a>1、构造函数</h3><pre><code>    function Axios(config){        this.config = config;    }</code></pre><h3 id="2、原型-request-方法"><a href="#2、原型-request-方法" class="headerlink" title="2、原型 request 方法"></a>2、原型 request 方法</h3><pre><code>    Axios.prototype.request = function(config){        return dispatchRequest(config);    }</code></pre><h3 id="3、dispatchRequest-函数"><a href="#3、dispatchRequest-函数" class="headerlink" title="3、dispatchRequest 函数"></a>3、dispatchRequest 函数</h3><pre><code>    function dispatchRequest(config){        return xhrAdapter(config);    }</code></pre><h3 id="4、xhrAdapter"><a href="#4、xhrAdapter" class="headerlink" title="4、xhrAdapter"></a>4、xhrAdapter</h3><pre><code>    function xhrAdapter(config){        //发送 AJAX 请求        return new Promise((resolve, reject) =&gt; {            //实例化对象            const xhr = new XMLHttpRequest();            //初始化            xhr.open(config.method, config.url);            //发送            xhr.send();            //处理结果            xhr.onreadystatechange = function(){                if(xhr.readyState === 4){                    //判断结果                    if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){                        //设置为成功的状态                        resolve({                            status: xhr.status,                            statusText: xhr.statusText                        });                    }else{                        reject(new Error('请求失败'));                    }                }            }            //关于取消请求的处理            if(config.cancelToken){                //对 cancelToken 对象身上的 promise 对象指定成功的回调                config.cancelToken.promise.then(value =&gt; {                    xhr.abort();                    //将整体结果设置为失败                    reject(new Error('请求已经被取消'))                });            }        })    }</code></pre><h3 id="5、创建-axios-函数"><a href="#5、创建-axios-函数" class="headerlink" title="5、创建 axios 函数"></a>5、创建 axios 函数</h3><pre><code>    const context = new Axios({});    const axios = Axios.prototype.request.bind(context);  //保证this指向没问题</code></pre><h3 id="6、CancelToken-构造函数"><a href="#6、CancelToken-构造函数" class="headerlink" title="6、CancelToken 构造函数"></a>6、CancelToken 构造函数</h3><pre><code>    function CancelToken(executor){        //声明一个变量        var resolvePromise;        //为实例对象添加属性        this.promise = new Promise((resolve) =&gt; {            //将 resolve 赋值给 resolvePromise            resolvePromise = resolve        });        //调用 executor 函数        executor(function(){            //执行 resolvePromise 函数            resolvePromise();        });    }</code></pre><p>原理：在cancelTaken身上维护了一个<strong>属性promise</strong>，并且之后吧可以改变其状态的变量resolvePromise变量暴露到了全局。</p><p>于是cancel就成了调用的接口，当它使用时，内部resolvePromise就会执行，进而resolve执行改变promise状态为成功</p><p>promise成功时，发送请求的回调就会执行，进而执行了abort函数</p><h2 id="三、重点问题分析"><a href="#三、重点问题分析" class="headerlink" title="三、重点问题分析"></a>三、重点问题分析</h2><h3 id="1、axios-与Axios的关系"><a href="#1、axios-与Axios的关系" class="headerlink" title="1、axios 与Axios的关系?"></a>1、axios 与Axios的关系?</h3><p>1.从语法上来说: axios不是Axios 的实例</p><p>2.从功能上来说: axios是Axios 的实例</p><p>3.axios 是Axios.prototype.request 函数 bind()返回的函数</p><p>4.axios 作为对象有Axios 原型对象上的所有方法，有Axios对象上所有属性</p><p>通俗就是首先从结构来看，axios并不是由Axios实例化，得来的<br>axios来源的关键在于createInstance函数得来的<br>但是从功能上面来说axios具有Axios实例所有的功能</p><h3 id="2、instance-与axios的区别"><a href="#2、instance-与axios的区别" class="headerlink" title="2、instance 与axios的区别?"></a>2、instance 与axios的区别?</h3><h4 id="1-相同"><a href="#1-相同" class="headerlink" title="1.相同:"></a>1.相同:</h4><p>(1)都是一个能发任意请求的函数: request(config)</p><p>(2）都有发特定请求的各种方法: get()/post()/put()/delete()</p><p>(3)都有默认配置和拦截器的属性: defaults/interceptors</p><h4 id="2-不同"><a href="#2-不同" class="headerlink" title="2.不同:"></a>2.不同:</h4><p>(1)默认配置很可能不一样</p><p>(2)instance没有axios后面添加的一些方法: create()/CancelToken()/all()</p><p>可以理解为：</p><p>两者开始是一样的,但是在用instance创建完axios之后,又对axios添加了一系列的属性与方法<br>而这些是instance不具有的,所以这是最大的不同</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;axios拦截器与请求取消的模拟实现&quot;&gt;&lt;a href=&quot;#axios拦截器与请求取消的模拟实现&quot; class=&quot;headerlink&quot; title=&quot;axios拦截器与请求取消的模拟实现&quot;&gt;&lt;/a&gt;axios拦截器与请求取消的模拟实现&lt;/h1&gt;&lt;h2 id=&quot;一</summary>
      
    
    
    
    <category term="js经典问题" scheme="https://useritem.github.io/categories/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="axios" scheme="https://useritem.github.io/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>axios源码基础功能深入</title>
    <link href="https://useritem.github.io/2021/06/19/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/axios%E6%BA%90%E7%A0%81%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B7%B1%E5%85%A5/"/>
    <id>https://useritem.github.io/2021/06/19/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/axios%E6%BA%90%E7%A0%81%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%B7%B1%E5%85%A5/</id>
    <published>2021-06-19T03:37:57.000Z</published>
    <updated>2021-06-19T11:25:02.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、axios源码分析"><a href="#一、axios源码分析" class="headerlink" title="一、axios源码分析"></a>一、axios源码分析</h1><h2 id="1、源码目录分析"><a href="#1、源码目录分析" class="headerlink" title="1、源码目录分析"></a>1、源码目录分析</h2><p>直接引入尚硅谷视频里的源码目录结构：</p><p><a href="https://imgtu.com/i/R9tHw4"><img src="https://z3.ax1x.com/2021/06/18/R9tHw4.png" alt="R9tHw4.png"></a></p><h3 id="重点文件在于："><a href="#重点文件在于：" class="headerlink" title="重点文件在于："></a>重点文件在于：</h3><p>Axios.js，即axios的构造文件，最终对Axios进行暴露，并用Axios进行“伪”实例化对象，也可以理解为构造函数的一个组成。</p><p>dispatchRequest.js文件主要对xhr.js与http.js的适配器的使用<strong>调用</strong>，由其来进行指令需求的调用</p><p>index.js为整个包的js文件，进而引出axios.js文件.</p><h2 id="2、axios的构造"><a href="#2、axios的构造" class="headerlink" title="2、axios的构造"></a>2、axios的构造</h2><p>重点在于先构造函数，再在函数上面进行方法的的添加，步骤</p><h3 id="1、定义构造函数"><a href="#1、定义构造函数" class="headerlink" title="1、定义构造函数"></a>1、定义构造函数</h3><pre><code>    function Axios(config){        //初始化        this.defaults = config;//为了创建 default 默认属性        this.intercepters = {        //实际为intercepters的实例，为了保证代码可观性，便写做这样            request: {},            response: {}        }    }</code></pre><h3 id="2、原型方法的添加"><a href="#2、原型方法的添加" class="headerlink" title="2、原型方法的添加"></a>2、原型方法的添加</h3><pre><code>    Axios.prototype.request = function(config){        console.log('发送 AJAX 请求 请求的类型为 '+ config.method);    }    Axios.prototype.get = function(config){        return this.request({method: 'GET'});        //return this.request(config);    因为便于区分，所以不回这样写    }    //其他方法能够顺利使用的关键在于调用了request方法</code></pre><h3 id="3、声明函数"><a href="#3、声明函数" class="headerlink" title="3、声明函数"></a>3、声明函数</h3><pre><code>    //声明函数    function createInstance(config){        //实例化一个对象        let context = new Axios(config);// context.get()  context.post()  但是不能当做函数使用 context() X        //创建请求函数        let instance = Axios.prototype.request.bind(context);         //bind方法进行函数的绑定对象，理解为f.bind(obj)，实际上可以理解为obj.f()，这时，f函数体内的this自然指向的是obj        // instance 是一个函数 并且可以 instance({})  此时 instance 不能 instance.get X        //将 Axios.prototype 对象中的方法添加到instance函数对象中        Object.keys(Axios.prototype).forEach(key =&gt; {            instance[key] = Axios.prototype[key].bind(context);            // 可直接用this.default  this.interceptors            //这样保证内部直接指向实例对象context        }); //此时它既可以是函数又可以是对象        //为 instance 函数对象添加属性 default 与 interceptors        Object.keys(context).forEach(key =&gt; {            instance[key] = context[key];        });        return instance;    }</code></pre><h3 id="4、使用axios"><a href="#4、使用axios" class="headerlink" title="4、使用axios"></a>4、使用axios</h3><pre><code>    let axios = createInstance();    //发送请求    // axios({method:'POST'});    axios.get({});    axios.post({});</code></pre><h2 id="2、请求的发送"><a href="#2、请求的发送" class="headerlink" title="2、请求的发送"></a>2、请求的发送</h2><p>1、声明构造函数</p><pre><code>function Axios(config){        this.config = config;    }    Axios.prototype.request = function(config){        //发送请求        //创建一个 promise 对象        let promise = Promise.resolve(config);        //声明一个数组        let chains = [dispatchRequest, undefined];// undefined 占位        //循环处理数组,调用 then 方法指定回调        let result = promise.then(chains[0], chains[1]);        //返回 promise 的结果        return result;    }</code></pre><p>2、dsipatchRequest函数</p><pre><code>        function dispatchRequest(config){        //调用适配器发送请求        return xhrAdapter(config).then(response =&gt; {            //响应的结果进行转换处理            //....            return response;        }, error =&gt; {            throw error;        });    }</code></pre><p>3、adapter适配器,这里就是实现发送，也就是xhr.js文件</p><pre><code>  function xhrAdapter(config){        console.log('xhrAdapter 函数执行');        return new Promise((resolve, reject) =&gt; {            //发送 AJAX 请求            let xhr = new XMLHttpRequest();            //初始化            xhr.open(config.method, config.url);            //发送            xhr.send();            //绑定事件            xhr.onreadystatechange = function(){                if(xhr.readyState === 4){                    //判断成功的条件                    if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){                        //成功的状态                        resolve({                            //配置对象                            config: config,                            //响应体                            data: xhr.response,                            //响应头                            headers: xhr.getAllResponseHeaders(), //字符串  parseHeaders                            // xhr 请求对象                            request: xhr,                            //响应状态码                            status: xhr.status,                            //响应状态字符串                            statusText: xhr.statusText                        });                    }else{                        //失败的状态                        reject(new Error('请求失败 失败的状态码为' + xhr.status));                    }                }            }        });    }</code></pre><p>4、创建axios函数</p><pre><code>  let axios = Axios.prototype.request.bind(null);    //不执行其他的实例对象了    axios({        method:'GET',        url:'http://localhost:3000/posts'    }).then(response =&gt; {        console.log(response);    });</code></pre><p>流程：实际是先对结果与dispatchRequest函数进行同步，即成功同成功，失败同失败，且dispatchRequest的成功结果</p><p>就是result的结果值，可以理解为dispatchRequest中的return response就是result，</p><p>之后return result直接返回给Axios的执行结果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、axios源码分析&quot;&gt;&lt;a href=&quot;#一、axios源码分析&quot; class=&quot;headerlink&quot; title=&quot;一、axios源码分析&quot;&gt;&lt;/a&gt;一、axios源码分析&lt;/h1&gt;&lt;h2 id=&quot;1、源码目录分析&quot;&gt;&lt;a href=&quot;#1、源码目录分析&quot;</summary>
      
    
    
    
    <category term="js经典问题" scheme="https://useritem.github.io/categories/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="axios" scheme="https://useritem.github.io/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>axios使用问题</title>
    <link href="https://useritem.github.io/2021/06/04/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/axios%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://useritem.github.io/2021/06/04/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/axios%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-04T14:05:46.000Z</published>
    <updated>2021-06-05T05:05:18.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、axios使用"><a href="#一、axios使用" class="headerlink" title="一、axios使用"></a>一、axios使用</h1><h2 id="1、axios介绍"><a href="#1、axios介绍" class="headerlink" title="1、axios介绍"></a>1、axios介绍</h2><p>axios是前端最流行的 ajax 请求库</p><p>且react/vue 官方都推荐使用 axios 发 ajax 请求，axios直接调用：</p><pre><code>  &lt;script src="https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js"&gt;&lt;/script&gt;</code></pre><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol><li>基于 xhr + promise 的异步 ajax 请求库</li><li>浏览器端/node 端都可以使用</li><li>支持请求／响应拦截器，即中间进行修改</li><li>支持请求取消</li><li>请求/响应数据转换</li><li>也可以批量发送多个请求</li></ol><h2 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h2><h3 id="（1）使用axios方法直接调用"><a href="#（1）使用axios方法直接调用" class="headerlink" title="（1）使用axios方法直接调用"></a>（1）使用axios方法直接调用</h3><pre><code> axios({            //请求类型            method: 'POST',            //URL            url: 'http://localhost:3000/posts',            //设置请求体            data: {                title: "今天天气不错, 还挺风和日丽的",                author: "张三"            }        }).then(response =&gt; {            console.log(response);        });</code></pre><p>注意axios.request(config): <strong>等同于</strong> axios(config)，</p><p>且config就是里面的对象{}</p><h3 id="（2）以请求类型进行调用（以post为例）"><a href="#（2）以请求类型进行调用（以post为例）" class="headerlink" title="（2）以请求类型进行调用（以post为例）"></a>（2）以请求类型进行调用（以post为例）</h3><pre><code>        axios.post(            'http://localhost:3000/comments',             {                "body": "喜大普奔",                "postId": 2            }).then(response =&gt; {                console.log(response);            })</code></pre><h2 id="3、默认配置设置"><a href="#3、默认配置设置" class="headerlink" title="3、默认配置设置"></a>3、默认配置设置</h2><p>即在axios的defaults属性上进行添加</p><pre><code>    axios.defaults.method = 'GET';//设置默认的请求类型为 GET    axios.defaults.baseURL = 'http://localhost:3000';//设置基础 URL    axios.defaults.params = {id:100};    axios.defaults.timeout = 3000;//    btns[0].onclick = function(){        axios({            url: '/posts'        }).then(response =&gt; {            console.log(response);        })    }</code></pre><p>axios其他默认属性详见：</p><p><a href="https://github.com/axios/axios#features">https://github.com/axios/axios#features</a></p><h2 id="4、axios实例对象的创建及使用"><a href="#4、axios实例对象的创建及使用" class="headerlink" title="4、axios实例对象的创建及使用"></a>4、axios实例对象的创建及使用</h2><p>axios通过create(config)进行实例对象的创建，并且用实例对象写请求</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>当接口服务，<strong>不仅仅一个服务器</strong>(即有部分接口需要的配置与另一部分接口需要的配置不太一<br>样)时，</p><p><strong>默认配置defaults</strong>仅会对一个好用，其他的不行，协议域名都需要加上</p><p>所以当创建创建 2 个新 axios, 每个都有自己特有的配置，可以借助多个对象发送，有效减少了代码量</p><p>例：</p><pre><code> //创建实例对象      const duanzi = axios.create({        baseURL: 'https://api.apiopen.top',        timeout: 2000    });    const onather = axios.create({        baseURL: 'https://b.com',        timeout: 2000    });    //使用：    duanzi.get('/getJoke').then(response =&gt; {        console.log(response.data)    })</code></pre><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><ol><li><p>根据指定配置创建一个新的 axios, 也就就每个新 axios 都有自己的配置</p></li><li><p>新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的</p></li></ol><h2 id="5、拦截器"><a href="#5、拦截器" class="headerlink" title="5、拦截器"></a>5、拦截器</h2><p>梗概：</p><p>请求拦截器nterceptors.request在发送请求之前，用函数对请求的参数进行处理与检测</p><p>响应拦截器interceptors.response，也是同样对结果进行检查，没问题才会给用户</p><p>特别的：</p><p>请求拦截器后进先执行，响应拦截器先进先执行，见下面例子</p><p>说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程</p><pre><code>    axios.interceptors.request.use(function (config) {        console.log('请求拦截器 成功 - 1号');        //修改 config 中的参数        config.params = {a:100};        return config;    }, function (error) {        console.log('请求拦截器 失败 - 1号');        return Promise.reject(error);    });    axios.interceptors.request.use(function (config) {        console.log('请求拦截器 成功 - 2号');        config.timeout = 2000;        return config;    }, function (error) {        console.log('请求拦截器 失败 - 2号');        return Promise.reject(error);    });    // 设置响应拦截器    axios.interceptors.response.use(function (response) {        console.log('响应拦截器 成功 1号');        return response.data;        // return response;    }, function (error) {        console.log('响应拦截器 失败 1号')        return Promise.reject(error);    });</code></pre><p>结果:</p><p>请求拦截器2 =&gt; 请求拦截器1 =&gt; 发ajax请求 =&gt; 响应拦截器1 =&gt; 响<br>应拦截器 2 =&gt; 请求的回调</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应<br>拦截器传递的是 response</p><h2 id="6、取消请求"><a href="#6、取消请求" class="headerlink" title="6、取消请求"></a>6、取消请求</h2><h3 id="（1）基本流程"><a href="#（1）基本流程" class="headerlink" title="（1）基本流程"></a>（1）基本流程</h3><p>1、配置 cancelToken 对象</p><p>2、缓存用于取消请求的 cancel 函数</p><p>3、在后面特定时机调用 cancel 函数取消请求</p><p>4、在错误回调中判断如果 error 是 cancel, 做相应处理</p><p>例子：二次点击时先取消之前的请求</p><pre><code>//2.声明全局变量    let cancel = null;    //发送请求    btns[0].onclick = function(){        //检测上一次的请求是否已经完成        if(cancel !== null){            //取消上一次的请求            cancel();        }        axios({            method: 'GET',            url: 'http://localhost:3000/posts',            //1. 添加配置对象的属性            cancelToken: new axios.CancelToken(function(c){                //3. 将 c 的值赋值给 cancel                cancel = c;            })        }).then(response =&gt; {            console.log(response);            //将 cancel 的值初始化            cancel = null;        })    }</code></pre><p>当然了自己测试时，如果使用的时json-server的话可以让其延缓执行，码：</p><pre><code>json-server --watch db.json -d 3000   </code></pre><p>延迟3s出结果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、axios使用&quot;&gt;&lt;a href=&quot;#一、axios使用&quot; class=&quot;headerlink&quot; title=&quot;一、axios使用&quot;&gt;&lt;/a&gt;一、axios使用&lt;/h1&gt;&lt;h2 id=&quot;1、axios介绍&quot;&gt;&lt;a href=&quot;#1、axios介绍&quot; class</summary>
      
    
    
    
    <category term="js经典问题" scheme="https://useritem.github.io/categories/js%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="axios" scheme="https://useritem.github.io/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>jq4 -- 事件与属性</title>
    <link href="https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq4-%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%B1%9E%E6%80%A7/"/>
    <id>https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq4-%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%B1%9E%E6%80%A7/</id>
    <published>2021-05-25T12:49:10.000Z</published>
    <updated>2021-05-25T12:52:05.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、属性控制"><a href="#一、属性控制" class="headerlink" title="一、属性控制"></a>一、属性控制</h1><h2 id="1、属性的设置与获取"><a href="#1、属性的设置与获取" class="headerlink" title="1、属性的设置与获取"></a>1、属性的设置与获取</h2><h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><p>进行单个元素属性：</p><pre><code>    $('img').attr('src','./src/图片2.gif')   //以前有src属性，所以对其进行修改    $('img').attr('aaa','hahaha')  //也可以对已有的自定义属性，进行修改     $('img').attr('bbb','hahaha')   --- 对没有的属性，会进行添加</code></pre><p>进行多个元素属性设置 — 对象</p><pre><code>    $('img').attr({        'src':'./src/图片2.gif',        'aaa':'hahaha',         bb:'hahaha'    })</code></pre><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><p>获取属性attr，没有第二个参数</p><pre><code>$('.btn2').click(function(){    alert($('img').attr('src'))    // 如果没有这个属性，那么就返回undefined，当然了自己设置的属性也可以获得})</code></pre><h2 id="2、属性移除-removeAttr"><a href="#2、属性移除-removeAttr" class="headerlink" title="2、属性移除 removeAttr()"></a>2、属性移除 removeAttr()</h2><pre><code>$('.btn3').click(function(){    // console.log($('img').removeAttr('src'))    // 注意这个返回值是$('img')本身    // var a = $('img').removeAttr('src')    // a.attr('bbb','hahaha')         //移除多个属性     $('img').removeAttr('src','aaa')    // $('img').removeAttr()    // 但是不加参数就没用了，不是全部删除})</code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>属性设置时，在jq1.6之后,对于checked,selected,disabled这类”boolean” 类型的值来说,不能使用attr方法,<strong>–只能使用prop方法–</strong>-</p><p>例：多选框</p><pre><code> &lt;input type="checkbox" id="box1"&gt;</code></pre><p>首先说明，多选框属性：checked在元素上面，就表示选中，没有写在元素上，则代表未选中<br>    // 这类属性，用原生js时：设置true，false也得到true或者false<br>    // $(‘#box2’).click(function(){<br>    //     document.getElementById(‘box1’).checked = true<br>    //     // 直接对属性进行控制<br>    // })</p><p>对于jq来说不能使用attr来控制boolean类型的属性</p><pre><code>$('#box2').click(function(){    console.log($('#box1').prop('checked'))  //得到undefined    // 当然了,如果选中就是true,未中就是flase    //  $('input').prop('checked',true)    // 注意赋值时,也需要使用prop })</code></pre><h1 id="二、元素位置控制与获取"><a href="#二、元素位置控制与获取" class="headerlink" title="二、元素位置控制与获取"></a>二、元素位置控制与获取</h1><h2 id="1、原始css方法"><a href="#1、原始css方法" class="headerlink" title="1、原始css方法"></a>1、原始css方法</h2><p>以div属性如下：</p><pre><code>    .div{        background-color: aqua;        width: 200px;        height: 200px;        padding: 20px;        border: 10px solid;        margin: 20px;    }</code></pre><p>当通过css属性进行获取时：</p><p>获取div宽高：之前可以用css方法 </p><pre><code>$('div').css('height')  --得到‘200px’// 需要直接得到数值时：height,width  --- 直接获取宽高，不包括内外边距，边框</code></pre><p>所以需要其他的方式</p><h2 id="2、属性获取宽高"><a href="#2、属性获取宽高" class="headerlink" title="2、属性获取宽高"></a>2、属性获取宽高</h2><h3 id="（1）只获取宽高height-width"><a href="#（1）只获取宽高height-width" class="headerlink" title="（1）只获取宽高height,width"></a>（1）只获取宽高height,width</h3><pre><code>    console.log($('div').width())   //200</code></pre><p>注意加了参数可以进行设置 — 加上数值参数,可以写300 “200”，’200px’，例如：</p><pre><code>$('button').click(function(){    $('div').width('300px')})</code></pre><h3 id="（2）包括内边距时-–-innerWidth-innerHeight"><a href="#（2）包括内边距时-–-innerWidth-innerHeight" class="headerlink" title="（2）包括内边距时 – innerWidth()/innerHeight()"></a>（2）包括内边距时 – innerWidth()/innerHeight()</h3><pre><code> console.log($('div').innerWidth())  //240 = 200+20+20</code></pre><h3 id="（3）内外边距与边框时-–-outerWidth-outerHeight"><a href="#（3）内外边距与边框时-–-outerWidth-outerHeight" class="headerlink" title="（3）内外边距与边框时  – outerWidth,outerHeight"></a>（3）内外边距与边框时  – outerWidth,outerHeight</h3><h4 id="当没有参数时或者参数为false-—-内边距与边框"><a href="#当没有参数时或者参数为false-—-内边距与边框" class="headerlink" title="当没有参数时或者参数为false — 内边距与边框"></a>当没有参数时或者参数为false — 内边距与边框</h4><pre><code>  console.log($('div').outerWidth()) // 260 = 240 +10+10</code></pre><h4 id="当有参数为true—-外内边距与边框"><a href="#当有参数为true—-外内边距与边框" class="headerlink" title="当有参数为true— 外内边距与边框"></a>当有参数为true— 外内边距与边框</h4><pre><code>console.log($('div').outerWidth(true))// 300 = 260 +20+20</code></pre><h3 id="（4）获取网页的可视区域宽高"><a href="#（4）获取网页的可视区域宽高" class="headerlink" title="（4）获取网页的可视区域宽高"></a>（4）获取网页的可视区域宽高</h3><pre><code> console.log($(window).width())    console.log($(window).height())</code></pre><h2 id="3、属性获取位置"><a href="#3、属性获取位置" class="headerlink" title="3、属性获取位置"></a>3、属性获取位置</h2><h3 id="（1）获取元素距离document的位置offset"><a href="#（1）获取元素距离document的位置offset" class="headerlink" title="（1）获取元素距离document的位置offset()"></a>（1）获取元素距离document的位置offset()</h3><pre><code>$('.1btn').click(function(){    // 1、offset()  --- 获得一个对象，包含了letf与top的值，代表了元素距离document的位置    console.log($('.son').offset())})</code></pre><h3 id="（2）获取元素距离有定位的父级元的位置position"><a href="#（2）获取元素距离有定位的父级元的位置position" class="headerlink" title="（2）获取元素距离有定位的父级元的位置position()"></a>（2）获取元素距离有定位的父级元的位置position()</h3><pre><code>$('.2btn').click(function(){    console.log($('.son').position())})</code></pre><h3 id="（3）获取滚动条的位置-scrollLeft-scrollTop"><a href="#（3）获取滚动条的位置-scrollLeft-scrollTop" class="headerlink" title="（3）获取滚动条的位置 scrollLeft(),scrollTop()"></a>（3）获取滚动条的位置 scrollLeft(),scrollTop()</h3><p>获取：</p><pre><code>// 两者分别表示为元素内容被卷曲出去的宽度与高度！！即 = 元素总高度 - 展示的高度$('.btn').click(function(){    console.log($('.img1').scrollLeft()+'高度'+$('.img1').scrollTop())})</code></pre><p>设置</p><pre><code>// 参数加上值，代表元素被卷出去的距离,此时“100px”不行了$('.img1').scrollLeft('100')// 设置页面被卷曲的宽高,获取：// 当然了还要求window宽高大于可视区才会生效$(window).scrollLeft('100')$(window).scrollTop('410')</code></pre><h1 id="三、事件问题"><a href="#三、事件问题" class="headerlink" title="三、事件问题"></a>三、事件问题</h1><h2 id="1、on的事件委托注册"><a href="#1、on的事件委托注册" class="headerlink" title="1、on的事件委托注册"></a>1、on的事件委托注册</h2><p>jq 1.7之后，jq使用了on统一了所有事件的注册方式</p><p>但是on是简单注册事件，不支持动态注册，指的是新建一个div之后，不会有这个事件</p><pre><code> $('.div1').on('click',function(){     console.log('绑定了事件') })</code></pre><p>on进行事件委托注册  — 通过父元素进行0n函数，目标元素在div内</p><pre><code>// 支持动态注册，即添加的div也有有这个事件// 并且支持多个委托：//  $('body').on('click','div,span',function(){})$('body').on('click','div',function(){    console.log('绑定了事件')})</code></pre><p><a href="https://www.cnblogs.com/yueyuecoding/articles/13431551.html">on的详解</a></p><h2 id="2、off事件解绑"><a href="#2、off事件解绑" class="headerlink" title="2、off事件解绑"></a>2、off事件解绑</h2><pre><code>没有参数时，表示解绑所有的事件：$('.div1').off()解绑匹配元素的所有的click事件：$('.div1').off('click')</code></pre><h3 id="事件手动触发trigger-‘事件’"><a href="#事件手动触发trigger-‘事件’" class="headerlink" title="事件手动触发trigger(‘事件’)"></a>事件手动触发trigger(‘事件’)</h3><p>作用：</p><ul><li>用代码的方式触发事件：</li><li>并且触发自定义事件</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><pre><code>$('.btn1').click(function(){    $(".div2").trigger('click')    $(".div2").trigger('mouseenter')})</code></pre><p>自定义事件：</p><pre><code> // 这种触发器可以让一些没法触发的事件运行，比如$('.div1').on('linge',function(){    alert('我居然被触发了11')})$('.div1').on('aaa',function(){    alert('我是自己定义的事件')})// 当然了，如果元素本身不具有这个事件也是无法触发的// 其他的就算是自己定义的事件，也可以通过trigger进行触发$('.btn2').click(function(){    $(".div2").trigger('linge')    $(".div2").trigger('aaa')})</code></pre><h2 id="3、事件对象"><a href="#3、事件对象" class="headerlink" title="3、事件对象"></a>3、事件对象</h2><h3 id="（1）事件对象意义"><a href="#（1）事件对象意义" class="headerlink" title="（1）事件对象意义"></a>（1）事件对象意义</h3><p>注册一个事件，系统帮我们生成一个对象，记录这个事件触发时的一些信息，</p><p>比如触发事件的坐标信息，或者比如有没有按住什么键</p><p>jq中通过函数中的参数e（写别的也可以）获取</p><p>jq的事件对象，是对原生js事件对象的一个封装，帮你处理好了–兼容性</p><pre><code>$('.div1').click(function(e){    console.log(e)})</code></pre><h3 id="2-事件对象中的常用的坐标"><a href="#2-事件对象中的常用的坐标" class="headerlink" title="(2)事件对象中的常用的坐标"></a>(2)事件对象中的常用的坐标</h3><pre><code>$('.div1').click(function(e){    console.log(e)    console.log('screnX :'+ e.screenX+ '  clientX  '+e.clientX)})</code></pre><p>和你的点击位置也是有关的</p><p>screenX和screenY    触发事件那个点！！！对应屏幕最左上角的值    —这个是全部页面（屏幕），连上面导航都算</p><p>clientX和clientY    触发事件那个点！！！离页面左上角的位置（忽视滚动条）</p><p>pageX和pageY    距离页面最顶部的左上角的位置（会计算滚动条的距离）</p><h3 id="3-阻止行为"><a href="#3-阻止行为" class="headerlink" title="(3)阻止行为"></a>(3)阻止行为</h3><pre><code>event.stopPropagation()    阻止事件冒泡行为</code></pre><p>进行阻止冒泡：</p><pre><code>$('.btn1').click(function(e){    alert('s')e.stopPropagation()  //阻止之后，button的父元素div就不会因此被触发了})</code></pre><p>阻止默认行为</p><pre><code>event.preventDefault()    阻止浏览器默认行为,b比如阻止a的点击跳转</code></pre><p>   $(‘a’).click(function(e){<br>        alert(“能到百度吗”)<br>      //  return false:既能阻止事件冒泡，又能阻止浏览器默认行为。<br>     // return false  //相当于上面的两部<br>    })</p><h3 id="（4）return-false既能阻止事件冒泡，又能阻止浏览器默认行为。"><a href="#（4）return-false既能阻止事件冒泡，又能阻止浏览器默认行为。" class="headerlink" title="（4）return false既能阻止事件冒泡，又能阻止浏览器默认行为。"></a>（4）return false既能阻止事件冒泡，又能阻止浏览器默认行为。</h3><ul><li><p>event.keyCode    按下的键盘代码</p></li><li><p>event.data    存储绑定事件时传递的附加数据</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>  $(document).on(‘keydown’,function(e){</p><pre><code>  // e.keyCode获取按3的是那个键  alert(e.keyCode)</code></pre><p>  })</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、属性控制&quot;&gt;&lt;a href=&quot;#一、属性控制&quot; class=&quot;headerlink&quot; title=&quot;一、属性控制&quot;&gt;&lt;/a&gt;一、属性控制&lt;/h1&gt;&lt;h2 id=&quot;1、属性的设置与获取&quot;&gt;&lt;a href=&quot;#1、属性的设置与获取&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="jQuery" scheme="https://useritem.github.io/categories/jQuery/"/>
    
    
  </entry>
  
  <entry>
    <title>jq3 -- 选择器，css类与动画</title>
    <link href="https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq3-%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%8Ccss%E7%B1%BB%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
    <id>https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq3-%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%8Ccss%E7%B1%BB%E4%B8%8E%E5%8A%A8%E7%94%BB/</id>
    <published>2021-05-25T12:48:43.000Z</published>
    <updated>2021-05-25T12:52:05.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、节点的操作"><a href="#一、节点的操作" class="headerlink" title="一、节点的操作"></a>一、节点的操作</h1><h2 id="1、节点的创建"><a href="#1、节点的创建" class="headerlink" title="1、节点的创建"></a>1、节点的创建</h2><h3 id="原生js的方法："><a href="#原生js的方法：" class="headerlink" title="原生js的方法："></a>原生js的方法：</h3><ul><li>document.write(‘’); 可以解析标签，但是可能覆盖掉页面</li><li>innerHTML =””   也会进行覆盖</li><li>document.createElement(); — 只存在于内存的标签，需要追加元素：appendChild</li></ul><h3 id="（1）html"><a href="#（1）html" class="headerlink" title="（1）html()"></a>（1）html()</h3><p>可以用于设置或者获取内容的</p><h4 id="1-1、当html不给参数表示获取类"><a href="#1-1、当html不给参数表示获取类" class="headerlink" title="1.1、当html不给参数表示获取类"></a>1.1、当html不给参数表示获取类</h4><pre><code> console.log($('div').html())</code></pre><h4 id="1-2、当html给参数，会进行标签解析和之前的“覆盖”"><a href="#1-2、当html给参数，会进行标签解析和之前的“覆盖”" class="headerlink" title="1.2、当html给参数，会进行标签解析和之前的“覆盖”"></a>1.2、当html给参数，会进行标签解析和之前的“覆盖”</h4><pre><code>$('div').html('我会&lt;h1&gt;覆盖&lt;/h1&gt;')</code></pre><h3 id="2"><a href="#2" class="headerlink" title="(2)$()"></a>(2)$()</h3><p>需要注意的是：</p><p>$()方法，只是<strong>在内容中设置</strong>，不会自动解析到页面上</p><p>如果后面需要进行添加的话，需要手动放置，比如append等（见后）</p><pre><code>let link = $('&lt;div&gt;&lt;12345/div&gt;')</code></pre><h2 id="2、节点操作："><a href="#2、节点操作：" class="headerlink" title="2、节点操作："></a>2、节点操作：</h2><h3 id="（1）节点的添加-A-某-B"><a href="#（1）节点的添加-A-某-B" class="headerlink" title="（1）节点的添加 A.某.B"></a>（1）节点的添加 A.某.B</h3><p>规律：</p><ul><li><p>1、对于新建元素 —  直接进行添加</p></li><li><p>2、把A本身已有的标签添加到ul中，代表<strong>剪切</strong>，之后进行添加</p></li><li><p>3、把其他地方的元素进行添加，那么相当于<strong>从其他地方剪切到该位置</strong></p></li></ul><h4 id="1、append方法（A-B建立完后为父子关系）"><a href="#1、append方法（A-B建立完后为父子关系）" class="headerlink" title="1、append方法（A,B建立完后为父子关系）"></a>1、append方法（A,B建立完后为父子关系）</h4><p>作为最后一个子元素进行添加，以上面三种规律为例：</p><p>1：新建元素—  作为最后一个子元素进行添加</p><pre><code>$('.btn1').click(function(){    var news = $('&lt;li&gt;xinjian&lt;/li&gt;')    $('.ul1').append(news)}</code></pre><p>2 把b本身已有的标签添加到ul中，代表剪切作为最后一个元素添加</p><pre><code>    var li3 = $('#li3')    $('.ul1').append(li3)</code></pre><p>3.吧ul2中的元素添加到ul1中去 — 直接将ul2中进行剪切后对齐添加</p><pre><code>    var li2 = $('#li2')    $('.ul1').append(li2)})</code></pre><h4 id="2、prepend方法（A-B建立完后为父子关系）"><a href="#2、prepend方法（A-B建立完后为父子关系）" class="headerlink" title="2、prepend方法（A,B建立完后为父子关系）"></a>2、prepend方法（A,B建立完后为父子关系）</h4><p>作为第一个元素添加,其他道理是一样的：</p><pre><code>$('.btn2').click(function(){    var news = $('&lt;li&gt;xinjian&lt;/li&gt;')    $('.ul1').prepend(news)})</code></pre><h4 id="3、before-（A-B-兄弟关系）"><a href="#3、before-（A-B-兄弟关系）" class="headerlink" title="3、before()（A B 兄弟关系）"></a>3、before()（A B 兄弟关系）</h4><p>before()  添加的方法—  添加到前面；</p><p>如果是 A.before（元素B）; //将元素B添加到元素A的前面，作为兄弟（之前作为的是子元素）</p><p>其他的道理一样，比如剪切什么的</p><pre><code>$('.btn3').click(function(){    var news = $('&lt;li&gt;xinjian&lt;/li&gt;')    $('.ul1').before(news)}）</code></pre><h4 id="4、after-（A-B-兄弟关系）"><a href="#4、after-（A-B-兄弟关系）" class="headerlink" title="4、after()（A B 兄弟关系）"></a>4、after()（A B 兄弟关系）</h4><p>after()  添加的方法—  添加到后面；</p><pre><code>    $('.btn4').click(function(){    var news = $('&lt;li&gt;xinjian&lt;/li&gt;')    $('.ul1').after(news)})</code></pre><h4 id="5、子元素-appendTo-父元素"><a href="#5、子元素-appendTo-父元素" class="headerlink" title="5、子元素.appendTo(父元素)"></a>5、子元素.appendTo(父元素)</h4><p>这是通过子元素点出来的！</p><p>把子元素作为父元素最后一个元素添加，—–和append效果一样，但是就是看谁给的方法</p><pre><code>$('.btn5').click(function(){    var news = $('&lt;li&gt;xinjian&lt;/li&gt;')    news.appendTo($('.ul1'))})</code></pre><div style="border-top: 5px solid #008c8c; margin:20px 0  "></div>  <h2 id="3、元素删除"><a href="#3、元素删除" class="headerlink" title="3、元素删除"></a>3、元素删除</h2><h3 id="1、元素完全清空-—-empty"><a href="#1、元素完全清空-—-empty" class="headerlink" title="1、元素完全清空 — empty()"></a>1、元素完全清空 — empty()</h3><p>实际上：htm(“”)方法也可以进行完全删除</p><pre><code>$('.ul1').html('') </code></pre><p>但是： 会清空里面了展示内容，但是实际还在，比如事件啥的，所以不安全，会造成内存泄漏</p><p>而对于empty()方法来说</p><p>他的实质是对每个元素实现了remove操作，并且对函数也进行了清除！，clearfix，但是此时内容中还有ul</p><p>所以完全清除推荐使用empty()</p><h3 id="2、移除一个元素-remove"><a href="#2、移除一个元素-remove" class="headerlink" title="2、移除一个元素 remove()"></a>2、移除一个元素 remove()</h3><pre><code>$('.btnn2').click(function(){    $('#li3').remove();  //自杀    // 但是注意remove之后，内容直接就不在了    $('#li2').parent().remove() //移除父元素})</code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>删除操作时：A.删除()，代表删除其本身全部，所以可以理解为<strong>自杀</strong></p><h2 id="4、节点克隆clone"><a href="#4、节点克隆clone" class="headerlink" title="4、节点克隆clone()"></a>4、节点克隆clone()</h2><p> jq中的克隆节点，仅仅存在于内存中，如果需要在页面中显示，需要追加到页面上！！</p><p>其次克隆方法的参数，无论是true还是false，都会clone到后代节点,（就是后面的子节点也会被clone上）</p><p>参数控制：方法是否克隆：</p><ul><li><p>true: 被克隆的事件也会被克隆上去</p></li><li><p>false：事件不会被克隆上去</p></li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4><pre><code>$('.clone').click(function(){    var clone  = $('.div1').clone(true)    // 把克隆节点进行追加    $('.div1').parent().append(clone)})</code></pre><h2 id="2、获取表单的方法val-："><a href="#2、获取表单的方法val-：" class="headerlink" title="2、获取表单的方法val()："></a>2、获取表单的方法val()：</h2><p>原生的js通过value值，来实现对input值的获取</p><p>jq通过  —-  val() 来获取表单元素的值</p><pre><code>&lt;input type="button" id="input1" value="naniu"&gt;&lt;input type="text" id="input2"&gt;    $('#input1').click(function(){    // 1、获取  val()方法不给参数，就是代表获取    alert($('#input2').val())    // 2、设置  对val给了参数，就表示了设置表单元素的值    $('#input2').val('hahaha')})</code></pre><p>原生js的value实现：</p><pre><code>    let inputs = document.getElementsByTagName('input')[2]    alert(inputs.value)    inputs.value = 'hehe' 也可以进行赋值    </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、节点的操作&quot;&gt;&lt;a href=&quot;#一、节点的操作&quot; class=&quot;headerlink&quot; title=&quot;一、节点的操作&quot;&gt;&lt;/a&gt;一、节点的操作&lt;/h1&gt;&lt;h2 id=&quot;1、节点的创建&quot;&gt;&lt;a href=&quot;#1、节点的创建&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="jQuery" scheme="https://useritem.github.io/categories/jQuery/"/>
    
    
  </entry>
  
  <entry>
    <title>jq2 -- class绑定与动画</title>
    <link href="https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq2-class%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
    <id>https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq2-class%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8A%A8%E7%94%BB/</id>
    <published>2021-05-25T12:48:06.000Z</published>
    <updated>2021-05-25T12:52:05.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、选择器"><a href="#一、选择器" class="headerlink" title="一、选择器"></a>一、选择器</h1><p>注意jq的基本选择器与层级选择器吗，与css的选择器类似，所以有些将不在赘述。</p><h2 id="1、基本选择器："><a href="#1、基本选择器：" class="headerlink" title="1、基本选择器："></a>1、基本选择器：</h2><h3 id="（1）并集选择器-—-逗号"><a href="#（1）并集选择器-—-逗号" class="headerlink" title="（1）并集选择器 —- 逗号"></a>（1）并集选择器 —- 逗号</h3><pre><code>$('#btn1','#btn2')</code></pre><h3 id="（2）交集选择器-—-空格"><a href="#（2）交集选择器-—-空格" class="headerlink" title="（2）交集选择器 —- 空格"></a>（2）交集选择器 —- 空格</h3><pre><code>$('.div span')</code></pre><h2 id="2、层级选择器："><a href="#2、层级选择器：" class="headerlink" title="2、层级选择器："></a>2、层级选择器：</h2><h3 id="（1）子代选择器-—-gt"><a href="#（1）子代选择器-—-gt" class="headerlink" title="（1）子代选择器 — >"></a>（1）子代选择器 — &gt;</h3><pre><code>  $('.div1&gt;span')</code></pre><h3 id="（1）后代选择器-—-gt-空格"><a href="#（1）后代选择器-—-gt-空格" class="headerlink" title="（1）后代选择器 — > 空格"></a>（1）后代选择器 — &gt; 空格</h3><pre><code>$('div1 span')</code></pre><p>底下的全部span元素，而不是全部的子元素</p><h2 id="3、过滤选择器"><a href="#3、过滤选择器" class="headerlink" title="3、过滤选择器"></a>3、过滤选择器</h2><p>首先注意，这类的选择器后面都带有”:”<strong>冒号</strong></p><pre><code>:eq(index)   ---找到类数组中索引为index的元素    $('ul:eq(3)'):odd         ---选择类数组中的》奇数元素         $('ul:odd')   ul元素中的奇数元素:even        ----             偶数元素         $('ul:even')</code></pre><h2 id="4、筛选选择器"><a href="#4、筛选选择器" class="headerlink" title="4、筛选选择器"></a>4、筛选选择器</h2><p>筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是<strong>方法</strong>。</p><p>主要选择器后面会加上<strong>选择</strong></p><p><a href="https://imgtu.com/i/g0XRhD"><img src="https://z3.ax1x.com/2021/05/13/g0XRhD.png" alt="g0XRhD.png"></a></p><h1 id="二、对css类的操作"><a href="#二、对css类的操作" class="headerlink" title="二、对css类的操作"></a>二、对css类的操作</h1><h2 id="1、添加一个类：addClass-方法"><a href="#1、添加一个类：addClass-方法" class="headerlink" title="1、添加一个类：addClass()方法"></a>1、添加一个类：addClass()方法</h2><pre><code> $('#div1').addClass('div2')</code></pre><p>当然了也可以直接添加多个class类：</p><pre><code>addClass('div2 div3')</code></pre><p>注意这里直接是添加css，所以不用加**”.”**</p><h2 id="2、类的移除removeClass-类名"><a href="#2、类的移除removeClass-类名" class="headerlink" title="2、类的移除removeClass(类名)"></a>2、类的移除removeClass(类名)</h2><pre><code>$('#div1').removeClass('div2')</code></pre><p>注意当没有这个div2的类时，系统也不会报错</p><p>当然了当没有参数时，则<strong>会删除全部的class类</strong></p><pre><code>$('#div1').removeClass()</code></pre><h2 id="3、判断是否存在这个类-hasClass-类名"><a href="#3、判断是否存在这个类-hasClass-类名" class="headerlink" title="3、判断是否存在这个类 hasClass(类名)"></a>3、判断是否存在这个类 hasClass(类名)</h2><pre><code>$('#div1').hasClass('div2')</code></pre><p>后面会返回一个boolean值</p><h2 id="4、对某个类的切换：toggle-‘类名’"><a href="#4、对某个类的切换：toggle-‘类名’" class="headerlink" title="4、对某个类的切换：toggle(‘类名’)"></a>4、对某个类的切换：toggle(‘类名’)</h2><pre><code>$('#div1').toggleClass('div2')</code></pre><p>如果元素有某个类，就进行移除，如果没有就进行添加</p><h1 id="三、动画"><a href="#三、动画" class="headerlink" title="三、动画"></a>三、动画</h1><h2 id="1、jq的基本动画"><a href="#1、jq的基本动画" class="headerlink" title="1、jq的基本动画"></a>1、jq的基本动画</h2><p>注意基本动画一般都有两个参数：</p><ul><li><p>一个参数表示执行时间，数字的话表示毫秒数，字符串可以是代表时长的字符串 fast(200ms) normal(400ms) slow(600ms)<br>当字符串写错了，就相当于写了一个normal</p></li><li><p>另一个表示事件执行完毕之后的函数</p><h3 id="（1）显示与隐藏动画"><a href="#（1）显示与隐藏动画" class="headerlink" title="（1）显示与隐藏动画"></a>（1）显示与隐藏动画</h3></li></ul><h4 id="1、显示动画show"><a href="#1、显示动画show" class="headerlink" title="1、显示动画show()"></a>1、显示动画show()</h4><pre><code>$('#div1').show(2000,function(){        // 当然了这两个参数也可以不写        console.log('ok')    })</code></pre><h4 id="2、隐藏动画hide"><a href="#2、隐藏动画hide" class="headerlink" title="2、隐藏动画hide"></a>2、隐藏动画hide</h4><pre><code>$('#div1').hide(3000)</code></pre><h4 id="3、切换动画toggle-–隐藏变显示，显示变隐藏"><a href="#3、切换动画toggle-–隐藏变显示，显示变隐藏" class="headerlink" title="3、切换动画toggle –隐藏变显示，显示变隐藏"></a>3、切换动画toggle –隐藏变显示，显示变隐藏</h4><pre><code> $('#div1').toggle(1000)</code></pre><div style="border-top: 5px solid #008c8c; margin:20px 0  "></div><h3 id="（2）滑动动画"><a href="#（2）滑动动画" class="headerlink" title="（2）滑动动画"></a>（2）滑动动画</h3><h4 id="1、划入动画slideDown"><a href="#1、划入动画slideDown" class="headerlink" title="1、划入动画slideDown"></a>1、划入动画slideDown</h4><p>– 不加参数也有动画效果,—默认参数normal（400ms）</p><pre><code> $('.btn4').click(function(){    $('#div2').slideDown(2000)  })</code></pre><h4 id="2、划出动画slideUp"><a href="#2、划出动画slideUp" class="headerlink" title="2、划出动画slideUp"></a>2、划出动画slideUp</h4><pre><code>$('#div2').slideUp(2000)  </code></pre><h4 id="3、slideToggle"><a href="#3、slideToggle" class="headerlink" title="3、slideToggle"></a>3、slideToggle</h4><pre><code>$('#div2').slideToggle(6000)</code></pre><div style="border-top: 5px solid #008c8c; margin:20px 0  "></div>  <h3 id="（3）淡入淡出动画"><a href="#（3）淡入淡出动画" class="headerlink" title="（3）淡入淡出动画"></a>（3）淡入淡出动画</h3><h4 id="1、淡入动画fadeIn-—-不给参数相当于给了默认时长normal、"><a href="#1、淡入动画fadeIn-—-不给参数相当于给了默认时长normal、" class="headerlink" title="1、淡入动画fadeIn  — 不给参数相当于给了默认时长normal、"></a>1、淡入动画fadeIn  — 不给参数相当于给了默认时长normal、</h4><pre><code>$('.btn1').click(function(){    $('.div1').fadeIn(2000)})</code></pre><h4 id="2、淡出fadeOut"><a href="#2、淡出fadeOut" class="headerlink" title="2、淡出fadeOut"></a>2、淡出fadeOut</h4><pre><code>$('.div1').fadeOut(2000)</code></pre><h4 id="3、切换fadeToggle"><a href="#3、切换fadeToggle" class="headerlink" title="3、切换fadeToggle"></a>3、切换fadeToggle</h4><pre><code>$('.div1').fadeToggle(2000)</code></pre><h2 id="2、jq的自定义动画animate"><a href="#2、jq的自定义动画animate" class="headerlink" title="2、jq的自定义动画animate()"></a>2、jq的自定义动画animate()</h2><h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul><li>参数1  必选的对象，表示需要做动画的属性</li><li>参数2，可选的，表示时长</li><li>参数3，可选的，easing代表缓动的还是匀速的 linear(匀速) swing（加速） ，默认不写为swing</li><li>参数4，动画执行完毕后的回调函数</li></ul><p>动画设置：</p><pre><code> $('.btn4').click(function(){    console.log('asd')    $('.div2').animate({        // 注意动left需要设置position为absolute        left:800,        width:'200px',        height:200,        opacity:0.5,        backgroundColor:'red' //这是无效的    },3000,'swing',function(){        // 由于这里是一个函数，可以让div干任何事情，所以可以在这里再次执行动画，所以可以实现连续的动画        $('.div2').animate({            left:400,            width:300,            height:300,            top:300,            'background-color':'red'        },3000,'swing',function(){            $('.div2').css("background-color", "red")        })    })})</code></pre><p>注意回调函数的特殊用法,可以通过回调函数,实现连续动画的实现</p><h2 id="3、动画停止stop（）"><a href="#3、动画停止stop（）" class="headerlink" title="3、动画停止stop（）"></a>3、动画停止stop（）</h2><h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul><li>第一个表示是否 清除队列</li><li>第二个表示是否 跳转到最终结果(false表示停止到当前状态)</li></ul><p>实例：</p><pre><code>//动画开启：$('.btn1').click(function(){    $('div').slideDown(3000).slideUp(3000)})//动画停止$('.btn2').click(function(){    $('div').stop(false,false)    // 第一个为false表示停止这一部分，即理解为停止slidedown部分})</code></pre><p>当没有参数时，则表示全为false：</p><pre><code>$('div').stop(false,false)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、选择器&quot;&gt;&lt;a href=&quot;#一、选择器&quot; class=&quot;headerlink&quot; title=&quot;一、选择器&quot;&gt;&lt;/a&gt;一、选择器&lt;/h1&gt;&lt;p&gt;注意jq的基本选择器与层级选择器吗，与css的选择器类似，所以有些将不在赘述。&lt;/p&gt;
&lt;h2 id=&quot;1、基本选择</summary>
      
    
    
    
    <category term="jQuery" scheme="https://useritem.github.io/categories/jQuery/"/>
    
    
  </entry>
  
  <entry>
    <title>jq1 -- 走进jquery</title>
    <link href="https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq1-%E8%B5%B0%E8%BF%9Bjquery/"/>
    <id>https://useritem.github.io/2021/05/25/jquery%E5%AD%A6%E4%B9%A0/jq1-%E8%B5%B0%E8%BF%9Bjquery/</id>
    <published>2021-05-25T12:47:22.000Z</published>
    <updated>2021-05-25T12:52:05.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言对比"><a href="#一、前言对比" class="headerlink" title="一、前言对比"></a>一、前言对比</h1><h2 id="1、例子：实现点击为元素添加文本与边框"><a href="#1、例子：实现点击为元素添加文本与边框" class="headerlink" title="1、例子：实现点击为元素添加文本与边框"></a>1、例子：实现点击为元素添加文本与边框</h2><p>html：</p><pre><code>&lt;button class="btn1"&gt;添加边框&lt;/button&gt;&lt;button class="btn2"&gt;添加文本&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;</code></pre><p>js实现：</p><pre><code>let btn = document.getElementsByClassName('btn1')[0]let btn2 = document.getElementsByClassName('btn2')[0]let div = document.getElementsByTagName('div')btn.onclick = function(){    for(let i = 0;i&lt;div.length;i++){        div[i].style.border = '3px solid red'    }}btn2.onclick = function(){    for(let i = 0;i&lt;div.length;i++){        div[i].innerHTML = '我是添加的元素'+i    }}</code></pre><p>jq实现:</p><pre><code>&lt;script src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt;let btn = $('.btn1')// 只能全部,上面的$('.btn1:eq(0)').click(function (){    $('div').css('border','3px solid red')})$('#btn2').click(function(){    $('div').text('我是设置的文本')})</code></pre><h2 id="2、差异："><a href="#2、差异：" class="headerlink" title="2、差异："></a>2、差异：</h2><h3 id="js缺点："><a href="#js缺点：" class="headerlink" title="js缺点："></a>js缺点：</h3><ul><li>   1、js的api太难记</li><li>   2、出现代码冗余</li><li>3、有些属性或者方法会有兼容问题</li><li>4、注意入口文件：window.onload只能写一个，（相当于为其添加属性）</li><li>5、原生js代码容错率较低，前面错误后面报废</li></ul><h3 id="jq优点："><a href="#jq优点：" class="headerlink" title="jq优点："></a>jq优点：</h3><ul><li>1、jq可以设置多个入口函数</li><li>2、jq会解决浏览器的兼容问题</li><li>3、jq前面的代码出现问题，不会影响后面的代码</li></ul><h1 id="二、jq简述"><a href="#二、jq简述" class="headerlink" title="二、jq简述"></a>二、jq简述</h1><h2 id="1、jq的链式编程"><a href="#1、jq的链式编程" class="headerlink" title="1、jq的链式编程"></a>1、jq的链式编程</h2><p>例子：</p><pre><code>$(document).ready(function(){   $('div').width(100).height(100).css('backgroundColor','red').text('haha')})</code></pre><h2 id="2、jq的版本问题："><a href="#2、jq的版本问题：" class="headerlink" title="2、jq的版本问题："></a>2、jq的版本问题：</h2><p>下载地址：  <a href="https://code.jquery.com/jquery/#jquery-all-1.x">https://code.jquery.com/jquery/#jquery-all-1.x</a></p><p>各个版本的特点</p><ul><li>1.x  –支持老浏览器比如ie678， 停止更新</li><li>2.x  –不支持老浏览器          停止更新</li><li>3.x  —不支持                还在更新</li></ul><p>当然了，也可以直接src引入：</p><pre><code>&lt;script src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt;</code></pre><h2 id="3、jq的入口函数"><a href="#3、jq的入口函数" class="headerlink" title="3、jq的入口函数"></a>3、jq的入口函数</h2><pre><code>$(function(){    alert('jq') })</code></pre><p>或者</p><pre><code>$(document).ready(function(){});</code></pre><h2 id="4、-的用法"><a href="#4、-的用法" class="headerlink" title="4、$的用法"></a>4、$的用法</h2><h3 id="（1）-的由来："><a href="#（1）-的由来：" class="headerlink" title="（1）$的由来："></a>（1）$的由来：</h3><pre><code>(function(){window.jQuery = window.$ = jQuery //将两者赋值为一个jQuery函数})</code></pre><p>所以说$的实际是一个函数，</p><pre><code> console.log(Object.prototype.toString.call('$'))// [object Function]这代表了jquery与$是等价的:window.jQuery = window.$   //true</code></pre><h3 id="（2）参数"><a href="#（2）参数" class="headerlink" title="（2）参数"></a>（2）参数</h3><h4 id="a-当参数为字符串—-代表为选择器，或者再创建一个标签"><a href="#a-当参数为字符串—-代表为选择器，或者再创建一个标签" class="headerlink" title="a.当参数为字符串—-代表为选择器，或者再创建一个标签"></a>a.当参数为字符串—-代表为选择器，或者再创建一个标签</h4><pre><code>$('one')$('&lt;div&gt;lalala&lt;/div&gt;')</code></pre><h4 id="b-当参数为匿名函数-—入口函数"><a href="#b-当参数为匿名函数-—入口函数" class="headerlink" title="b.当参数为匿名函数  —入口函数"></a>b.当参数为匿名函数  —入口函数</h4><pre><code>$(function(){})</code></pre><h4 id="c-当参数为一个dom对象-那么会转化为一个jQuery对象"><a href="#c-当参数为一个dom对象-那么会转化为一个jQuery对象" class="headerlink" title="c.当参数为一个dom对象,那么会转化为一个jQuery对象"></a>c.当参数为一个dom对象,那么会转化为一个jQuery对象</h4><pre><code>let div = document.getElementById('text')$(div)</code></pre><h2 id="5、dom对象与jq对象的转换"><a href="#5、dom对象与jq对象的转换" class="headerlink" title="5、dom对象与jq对象的转换"></a>5、dom对象与jq对象的转换</h2><p>例：</p><pre><code>let div = document.getElementById('text')</code></pre><p> 这个div表示dom对象，他只能使用dom方法，不能使用jq方法：</p><pre><code> 无效：div.css('backgroundColor','green')</code></pre><p>当然了jq对象也只能使用jq的方法以及属性</p><pre><code>var $div = $('.gus')$div.style.backgroundColor = 'red'</code></pre><h3 id="（1）dom对象与jq对象的转换：加"><a href="#（1）dom对象与jq对象的转换：加" class="headerlink" title="（1）dom对象与jq对象的转换：加$"></a>（1）dom对象与jq对象的转换：加$</h3><pre><code>$(div).width('100px').height('100px').css('backgroundColor','red')// 成功</code></pre><h3 id="2-jq—-gt-dom转换"><a href="#2-jq—-gt-dom转换" class="headerlink" title="(2) jq—>dom转换"></a>(2) jq—&gt;dom转换</h3><h4 id="1、通过下标取出来"><a href="#1、通过下标取出来" class="headerlink" title="1、通过下标取出来"></a>1、通过下标取出来</h4><pre><code>var div1  = $div[0]div1.style.backgroundColor = 'blue' //成功</code></pre><h4 id="2、使用get方法"><a href="#2、使用get方法" class="headerlink" title="2、使用get方法"></a>2、使用get方法</h4><pre><code>var div2 = $div.get(1)div2.style.backgroundColor = 'green' //成功</code></pre><h2 id="6、text（）方法："><a href="#6、text（）方法：" class="headerlink" title="6、text（）方法："></a>6、text（）方法：</h2><p> 获取文本元素：text（）方法：</p><pre><code> 如果方法里面没有参数，表示对元素文本的获取 如果有内容会对 之前内容进行覆盖，且注意里面的内容，不会进行解析</code></pre><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p><strong>jq对象是一个伪数组，jq对象实际是一个dom对象的包装集</strong></p><p>要求：取div中的第二个元素进行操作时，使用: <span style="color: red;font-size: 28px;">eq(n)</span></p><p>选择器后面介绍</p><pre><code>$('div:eq(1)').text('asdas')</code></pre><p>其中的 $(“.demo:eq(n)”)就是获得同样class的第N个元素。</p><p>当然了对于其他的选择器也可以这样取一个元素出来，但是<strong>不能以数组的中括号形式</strong>(因为是伪数组)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言对比&quot;&gt;&lt;a href=&quot;#一、前言对比&quot; class=&quot;headerlink&quot; title=&quot;一、前言对比&quot;&gt;&lt;/a&gt;一、前言对比&lt;/h1&gt;&lt;h2 id=&quot;1、例子：实现点击为元素添加文本与边框&quot;&gt;&lt;a href=&quot;#1、例子：实现点击为元素添加文本与边</summary>
      
    
    
    
    <category term="jQuery" scheme="https://useritem.github.io/categories/jQuery/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack下载问题</title>
    <link href="https://useritem.github.io/2021/05/10/%E9%9B%B6%E6%95%A3%E9%97%AE%E9%A2%98/webpack%E4%B8%8B%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    <id>https://useritem.github.io/2021/05/10/%E9%9B%B6%E6%95%A3%E9%97%AE%E9%A2%98/webpack%E4%B8%8B%E8%BD%BD%E9%97%AE%E9%A2%98/</id>
    <published>2021-05-10T14:37:32.000Z</published>
    <updated>2021-05-10T14:37:55.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack下载问题"><a href="#webpack下载问题" class="headerlink" title="webpack下载问题"></a>webpack下载问题</h1><p>在webpack下载时，会出现本来下载成功，结果出现</p><p><a href="https://imgtu.com/i/cRK4q1"><img src="https://z3.ax1x.com/2021/04/15/cRK4q1.md.png" alt="cRK4q1.md.png"></a></p><p>或者干脆直接找不到webpack，此时</p><p>应该直接用管理员权限进行下载！！！</p><p><a href="https://imgtu.com/i/cRKqRe"><img src="https://z3.ax1x.com/2021/04/15/cRKqRe.png" alt="cRKqRe.png"></a></p><p>之后如果先本地下载的话，可以进行cd调转</p><h2 id="此时我的电脑vscode又出来问题：权限不足"><a href="#此时我的电脑vscode又出来问题：权限不足" class="headerlink" title="此时我的电脑vscode又出来问题：权限不足"></a>此时我的电脑vscode又出来问题：权限不足</h2><p>直接进行如下操作：右键进行属性修改：</p><h3 id="一：以管理员运行"><a href="#一：以管理员运行" class="headerlink" title="一：以管理员运行"></a>一：以管理员运行</h3><p><a href="https://imgtu.com/i/cRMlz4"><img src="https://z3.ax1x.com/2021/04/15/cRMlz4.png" alt="cRMlz4.png"></a></p><h3 id="二、更改所有用户设置"><a href="#二、更改所有用户设置" class="headerlink" title="二、更改所有用户设置"></a>二、更改所有用户设置</h3><p><a href="https://imgtu.com/i/cRM6eI"><img src="https://z3.ax1x.com/2021/04/15/cRM6eI.png" alt="cRM6eI.png"></a></p><p>之后才算真正解决了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;webpack下载问题&quot;&gt;&lt;a href=&quot;#webpack下载问题&quot; class=&quot;headerlink&quot; title=&quot;webpack下载问题&quot;&gt;&lt;/a&gt;webpack下载问题&lt;/h1&gt;&lt;p&gt;在webpack下载时，会出现本来下载成功，结果出现&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="其他问题" scheme="https://useritem.github.io/categories/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>flex与grid布局</title>
    <link href="https://useritem.github.io/2021/05/10/%E9%9B%B6%E6%95%A3%E9%97%AE%E9%A2%98/flex%E4%B8%8Egrid%E5%B8%83%E5%B1%80/"/>
    <id>https://useritem.github.io/2021/05/10/%E9%9B%B6%E6%95%A3%E9%97%AE%E9%A2%98/flex%E4%B8%8Egrid%E5%B8%83%E5%B1%80/</id>
    <published>2021-05-10T14:36:20.000Z</published>
    <updated>2021-05-10T14:37:55.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、flex布局"><a href="#一、flex布局" class="headerlink" title="一、flex布局"></a>一、flex布局</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Flex（Flexible Box）布局为弹性布局，且<strong>任何容器都可以</strong>使用其布局</p><p><strong>注意针对的是轴线的位置，可以理解为一维布局</strong></p>  <div style="color: red; font-size: 20px;">而且注意这是对盒子的要求，需要放在外面！！</div><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</p><h2 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h2><h3 id="写法："><a href="#写法：" class="headerlink" title="写法："></a>写法：</h3><pre><code>.box{  display: -webkit-flex; /* Safari */Webkit内核的浏览器，必须加上-webkit前缀。  display: flex;}</code></pre><h3 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h3><p><a href="https://imgtu.com/i/gNdocD"><img src="https://z3.ax1x.com/2021/05/10/gNdocD.png" alt="gNdocD.png"></a></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h2 id="3、属性"><a href="#3、属性" class="headerlink" title="3、属性"></a>3、属性</h2><h3 id="（1）对于父元素容器的属性限定："><a href="#（1）对于父元素容器的属性限定：" class="headerlink" title="（1）对于父元素容器的属性限定："></a>（1）对于父元素容器的属性限定：</h3><p>1、flex-direction（主轴排列方向，及里面子元素的排序，默认为row横向）</p><p>2、flex-wrap    （横向排列时的换行情况，，默认nowrap不换行）</p><p>3、flex-flow （为前两项的简写总：）</p><pre><code>  flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;</code></pre><p>4、justify-content（主轴的对齐方式，默认：flex-start左侧对齐）</p> <div style="background-color: silver;"><h3>特别注意的是：</h3><div style="margin-top: 15px;">一旦前面设为纵向排列： flex-direction:column; **主轴方向变化为纵向**</div><div style="margin-top: 15px;">那么由于当盒子的大小没有具体数字的时候，这是高度和子元素有关，</div><div style="margin-top: 15px;">所以此时的justify-content设置之后外观不变！！！</div><div style="margin-top: 15px;">当然了如果设置了具体的px高度值，那么会生效的</div></div><p>5、align-items（与交叉轴（cross axis）对齐的方式：）</p><p><strong>这个对齐可以理解为与上面的justify-content相反的对齐，justify-content对齐是与主轴的方向相同，而align-item确实相反</strong></p><p>6、align-content（定义了多根轴线的对齐方式，通俗来说就是</p><p>如果flex-direction为row时，有多行，那么就有几个轴线）</p><p><strong>只有一根轴线不起作用</strong></p><div style="border-top: solid #ACC0D8 3px;margin:30px"></div><h3 id="（2）对于子元素的属性限定"><a href="#（2）对于子元素的属性限定" class="headerlink" title="（2）对于子元素的属性限定"></a>（2）对于子元素的属性限定</h3><p>1、order：定义项目元素的排列顺序。<strong>数值越小越靠前</strong>，可以理解为z-index的反义。</p><p>2、flex-grow （定义项目的放大比例，默认为0）</p><p>注意这个是填满，有剩余空间下的，如果只有一个元素有flex-grow值，那么就对一个限制，如果有多个，就</p><p><strong>通过flex-grow的值进行平分</strong></p><p>3、flex-shrink：项目缩小比例，<strong>如果空间不足</strong>会进行缩小</p><p>4、flex-basis：项目占据的主轴空间</p><p>5、flex：是flex-grow, flex-shrink 和 flex-basis的简写</p><p>6、align-self：允许单个项目有与其他项目不一样的对齐方式，可<strong>覆盖align-items</strong>属性</p><h3 id="具体解释详见："><a href="#具体解释详见：" class="headerlink" title="具体解释详见："></a>具体解释详见：</h3><p><a href="https://www.runoob.com/w3cnote/flex-grammar.html">Flex语法布局</a></p><h1 id="二、Grid-网格布局"><a href="#二、Grid-网格布局" class="headerlink" title="二、Grid 网格布局"></a>二、Grid 网格布局</h1><h2 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>主要是将容器进行划分为行与列，通过<strong>单元格</strong>进行划分，可以理解为二维</p><h2 id="2、书写："><a href="#2、书写：" class="headerlink" title="2、书写："></a>2、书写：</h2><pre><code>div {  display: grid;/*默认为块级，当然了也可以写为行内元素：*//* display: inline-grid;*/}</code></pre><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</p><h2 id="3、父容器属性"><a href="#3、父容器属性" class="headerlink" title="3、父容器属性"></a>3、父容器属性</h2><h3 id="（1）grid-template-columns-属性，grid-template-rows-属性"><a href="#（1）grid-template-columns-属性，grid-template-rows-属性" class="headerlink" title="（1）grid-template-columns 属性，grid-template-rows 属性"></a>（1）grid-template-columns 属性，grid-template-rows 属性</h3><p>分别定义了宽高：</p><pre><code>.container {  display: grid;  grid-template-columns: 100px 100px 100px;（横）  grid-template-rows: 100px 100px 100px;（也可以写为百分比）}</code></pre><p>上面代码指定了一个三行三列的网格，列宽和行高都是100px。</p><p><a href="https://imgtu.com/i/gNgpvt"><img src="https://z3.ax1x.com/2021/05/10/gNgpvt.png" alt="gNgpvt.png"></a></p><p>grid-template-columns对于两栏布局十分简单：</p><pre><code>.wrapper {  display: grid;  grid-template-columns: 70% 30%;左边栏设为70%，右边栏设为30%。}</code></pre><p>当然了三栏也可以</p><p><strong>注意当百分比之和超过100%，会有溢出</strong></p><h3 id="（2）repeat—简化重复值"><a href="#（2）repeat—简化重复值" class="headerlink" title="（2）repeat—简化重复值"></a>（2）repeat—简化重复值</h3><p>上面的例子：</p><pre><code>.container {  display: grid;  grid-template-columns: repeat(3, 33.33%);（第一个表示重复次数，第二个表示重复的值）  grid-template-rows: repeat(3, 33.33%);}</code></pre><h3 id="（3）auto-fill—-表示自动填充"><a href="#（3）auto-fill—-表示自动填充" class="headerlink" title="（3）auto-fill—-表示自动填充"></a>（3）auto-fill—-表示自动填充</h3><pre><code>grid-template-columns: repeat(auto-fill, 100px);</code></pre><p>横向自动填充</p><h3 id="（4）fr-关键字-—-表示比例关系"><a href="#（4）fr-关键字-—-表示比例关系" class="headerlink" title="（4）fr 关键字 — 表示比例关系"></a>（4）fr 关键字 — 表示比例关系</h3><pre><code>grid-template-columns: 1fr 2fr; //表示后面是前一个两倍</code></pre><p>当然了，也可以与绝对长度进行<strong>综合使用：</strong></p><pre><code>grid-template-columns: 150px 1fr 2fr;第一列的宽度为150像素，第二列的宽度是第三列的一半。</code></pre><h3 id="（5）间距"><a href="#（5）间距" class="headerlink" title="（5）间距"></a>（5）间距</h3><p>grid-row-gap 属性 — 行与行的间隔（行间距）</p><p>grid-column-gap 属性 —— 属性设置列与列的间隔（列间距）</p><p>grid-gap 属性 — 上面的合并简洁形式：</p><pre><code>grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;grid-gap: 20px 20px;</code></pre><p>注意这个前面的grid也可以省略</p><h3 id="（6）grid-template-areas区域划分："><a href="#（6）grid-template-areas区域划分：" class="headerlink" title="（6）grid-template-areas区域划分："></a>（6）grid-template-areas区域划分：</h3><pre><code>grid-template-areas: 'a . c'                     'd . f'                     'g . i';</code></pre><p>这个“.”表示区域不用利用</p><h3 id="（7）grid-auto-flow-—放置顺序"><a href="#（7）grid-auto-flow-—放置顺序" class="headerlink" title="（7）grid-auto-flow —放置顺序"></a>（7）grid-auto-flow —放置顺序</h3><pre><code>grid-auto-flow: column; </code></pre><p>这个表示<strong>先列后行</strong>，默认值为row，表示先行后列</p><p>column的结果：</p><p><a href="https://imgtu.com/i/gNhyv9"><img src="https://z3.ax1x.com/2021/05/10/gNhyv9.png" alt="gNhyv9.png"></a></p><p>后面也可以加上dense表示<strong>尽量紧密填满</strong></p><pre><code>grid-auto-flow: row dense;</code></pre><h3 id="（8）单元格位置确定"><a href="#（8）单元格位置确定" class="headerlink" title="（8）单元格位置确定"></a>（8）单元格位置确定</h3><p>justify-items 属性—设置单元格内容的水平位置（左中右）</p><p>align-items 属性 —- 单元格内容的垂直位置（上中下）</p><p>place-items 属性 —合并简写形式</p><pre><code>place-items: start end;</code></pre><h3 id="（9）整个内容位置确定"><a href="#（9）整个内容位置确定" class="headerlink" title="（9）整个内容位置确定"></a>（9）整个内容位置确定</h3><p>justify-content 属性   </p><p>align-content 属性，</p><p>place-content 属性</p><p>其位置同于items单元格位置，注意stretch值</p><ul><li>项目大小没有指定时，拉伸占据整个网格容器。</li></ul><h3 id="（10）当元素数超过开始设定的个数："><a href="#（10）当元素数超过开始设定的个数：" class="headerlink" title="（10）当元素数超过开始设定的个数："></a>（10）当元素数超过开始设定的个数：</h3><ul><li><p>grid-auto-columns 属性，</p></li><li><p>grid-auto-rows 属性</p></li></ul><p>按照这两个属性动生成区域，以便放置项目。</p><h2 id="4、子项目属性"><a href="#4、子项目属性" class="headerlink" title="4、子项目属性"></a>4、子项目属性</h2><h3 id="（1）项目位置确定-—根据网格线"><a href="#（1）项目位置确定-—根据网格线" class="headerlink" title="（1）项目位置确定 —根据网格线"></a>（1）项目位置确定 —根据网格线</h3><ul><li><p>grid-column-start属性：左边框所在的垂直网格线</p></li><li><p>grid-column-end属性：右边框所在的垂直网格线</p></li><li><p>grid-row-start属性：上边框所在的水平网格线</p></li><li><p>grid-row-end属性：下边框所在的水平网格线</p><p>  .item-1 {</p><pre><code>grid-column-start: 2;grid-column-end: 4;</code></pre><p>  }</p></li></ul><p><a href="https://imgtu.com/i/gN5KfS"><img src="https://z3.ax1x.com/2021/05/10/gN5KfS.png" alt="gN5KfS.png"></a></p><p>从第二根线到第四根线，</p><h4 id="注意：线的确定"><a href="#注意：线的确定" class="headerlink" title="注意：线的确定"></a>注意：线的确定</h4><p>这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p><pre><code>.item-1 {  grid-column-start: span 2;}</code></pre><p>表示从左到右跨过了多少网格</p><p>grid-column 属性 — grid-column-start和grid-column-end的合并简写形式</p><p>grid-row 属性 — grid-row-start属性和grid-row-end的合并简写形式。</p><pre><code>.item-1 {  background: #b03532;  grid-column: 1 / 3;  grid-row: 1 / 3;}/* 等同于 */.item-1 {  background: #b03532;  grid-column: 1 / span 2;  grid-row: 1 / span 2;}</code></pre><p><a href="https://imgtu.com/i/gNIJjH"><img src="https://z3.ax1x.com/2021/05/10/gNIJjH.png" alt="gNIJjH.png"></a></p><h3 id="（2）指定项目的区域"><a href="#（2）指定项目的区域" class="headerlink" title="（2）指定项目的区域"></a>（2）指定项目的区域</h3><p>grid-area属性指定项目放在哪一个区域。</p><pre><code>.item-1 {  grid-area: e;}</code></pre><p>与上面的grid-template-areas区域划分相对应</p><h3 id="（3）项目的单独位置"><a href="#（3）项目的单独位置" class="headerlink" title="（3）项目的单独位置"></a>（3）项目的单独位置</h3><p>和flex布局一样，一旦写了项目的单独布局，之前的就不会生效</p><p>justify-self —- 设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。</p><p>align-self 属性</p><p>place-self 属性</p><pre><code>place-self: center center;</code></pre><p>详细请见：</p><p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">grid语法布局</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、flex布局&quot;&gt;&lt;a href=&quot;#一、flex布局&quot; class=&quot;headerlink&quot; title=&quot;一、flex布局&quot;&gt;&lt;/a&gt;一、flex布局&lt;/h1&gt;&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="其他问题" scheme="https://useritem.github.io/categories/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack详细配置</title>
    <link href="https://useritem.github.io/2021/04/26/webpack%E5%AD%A6%E4%B9%A0/webpack%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/"/>
    <id>https://useritem.github.io/2021/04/26/webpack%E5%AD%A6%E4%B9%A0/webpack%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/</id>
    <published>2021-04-26T09:00:06.000Z</published>
    <updated>2021-04-26T09:01:34.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、entry"><a href="#1、entry" class="headerlink" title="1、entry"></a>1、entry</h1><p>可以有单入口（string），array（多入口），object</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="string（单入口）-–-gt-最长使用的方式，以一个值作为入口"><a href="#string（单入口）-–-gt-最长使用的方式，以一个值作为入口" class="headerlink" title="string（单入口）   –> 最长使用的方式，以一个值作为入口"></a>string（单入口）   –&gt; 最长使用的方式，以一个值作为入口</h3><p>比如：’./src/index.js‘</p><p>特点：打包形成一个chunk，输出一个bundle文件</p><p>此时：chunk默认为main</p><h3 id="2、array-（多入口）"><a href="#2、array-（多入口）" class="headerlink" title="2、array:（多入口）"></a>2、array:（多入口）</h3><p>传入一个数组，所有一个入口文件只有一个chunk，输出仅有一个bundle</p><p>数组中元素，都会被打包到第一个元素中去，且名字还见output</p><p>作用：一般来说只是在HMR功能中使热更新生效</p><h3 id="3、object"><a href="#3、object" class="headerlink" title="3、object"></a>3、object</h3><p>多入口，以键值对的方式，</p><p>有几个入口文件，就说几个chunk，输出就说几个bundle</p><p>chunk的名称就是前面的key值，</p><p>也可以进行混合：</p><pre><code>entry:{    // 所有入口形成一个chunk，输出仅有一个bundle    // 这样可以让多个库打包成一个chunk    index:['./src/index.js','./src/count.js'],    add:'./src/add.js'},</code></pre><h1 id="2、output："><a href="#2、output：" class="headerlink" title="2、output："></a>2、output：</h1><p>直接上例子：</p><pre><code>output: {    // filename可以指定目录，与名称    filename: '[name].js',    // path只能指定目录，且为所有资源的公共目录    path: resolve(__dirname, 'build'),    // 所有输出路径的公共路径来补充到路径之前：    //  'imgs/a/jpg'(不加/表示当前路径)  ---&gt;'/imgs/a.jpg'（加了/会以当前服务器地址补充，去服务器根目录找imgs，再找a.jpg）  //  publicPath:'/', //确定加不加/,一般用于生产环境    chunkFilename:'[name]_chunk.js',    // 非入口chunk名称,如果不加都会走filename    // 让打包的东西暴露出去使，外面也可以使用    library:'[name]',    // 对暴露的进行指定    libraryTarget: 'commonjs' //commonjs    // libraryTarget:'window'  变量名添加到那个node},</code></pre><h1 id="3、resolve"><a href="#3、resolve" class="headerlink" title="3、resolve"></a>3、resolve</h1><p>配置进行模块路径别名,解决import那个../与./的问题，但是写路径没有提示了</p><p>当然了也防止弄混了</p><pre><code>resolve:{    // 配置进行模块路径别名,解决import那个../与./的问题，但是写路径没有提示了    // 路径别名的方式：无提示    alias:{        $css:resolve(__dirname,'src/css')    },    // 配置省略路径的后缀名    // 省略的是index，js中引用处的后缀名    extensions:['.js','.json','.css','.jsx'],    // 注意这样文件名不要一样！！！    // 告诉webpack解析模块时，解析那个目录    // 这样写清楚绝对路径之后，找起来更快y一点点点    modules:[ resolve(__dirname,'../../node_modules'),'node_modules'    ]}</code></pre><p>这样在入口文件下引入就可以：</p><pre><code>import '$css/a'</code></pre><h1 id="4、devserver"><a href="#4、devserver" class="headerlink" title="4、devserver"></a>4、devserver</h1><p>使用npx webpack-dev-server运行之后会自动进行更新修改</p><pre><code>devServer:{    // 运行代码的目录    contBase:resolve(__dirname,'build'),    watchContentBase:true,    //监视contbase目录，一旦文件变化就会reload重载    watchOptions:{        // 忽略文件        ignored:/node_modules/    },    //启动gzip压缩    compress:true,    port:3000,  //端口号    //域名    host:'localhost',    // 自动打开浏览器    open:true,    // 开启HMR功能    hot:true,    // 不需要显示启动服务器日志信息    clientLogLevel:true,    // 除了一些基本启迪以外，其他内容都不要显示     quiet:true,    // 如果出现错误不要全屏提示    overlay:false,    // 服务器代理-----解决开发环境的跨域问题    proxy:{        // 一旦devserver（3000）服务器，接收到/api/xxx请求        // 就会把请求转发到另一个服务器:5000        '/api':{            target:'http://localhost:5000',            pathRewrite:{                // 发送请求时,请求路径重写               // 将/api/xxx改为/xxx(去掉/api)                '^/api':''            }        }    }}</code></pre><h1 id="5、optimization"><a href="#5、optimization" class="headerlink" title="5、optimization"></a>5、optimization</h1><p>optimization主要用于生产环境的代码分割</p><pre><code>optimization:{        splitChunks:{            chunks:'all',            //以下都是默认值，可以不写，直接写上面一句就行             // minSize:30*1024,  //分割的chunk最小为30kb            // maxSize:0,  //最大无限，有多大都可以分割            // minChunks:1,  //要被提取的chunks最少被引用一次            // maxAsyncRequest:5, //按需1加载时，并行加载的文件的最大数目为5            // maxInitialRequest:3,  //引入js文件最大并行请求数目            // automaticNameDelimiter:'~',  //名称连接符            // name:true,   //可以使用命名规则            // cacheGroups:{   //分割的chunk组,一组表示一种规则            //     // node_modules文件会被打包到vendor组的chunk中，  --》vendors ~ xxx.js            //     // node_modules还要满足上面的规则，如大小要超过30kb            //     vendors:{            //         test:/[\\/]node_modules[\\/]/,            //         // 优先级            //         priority:-10            //     },            //     default:{            //         // 要被提取的chunk最少要被引用两次            //         minChunks:2,            //         priority:-100,            //         // 实现代码的复用:            //         // 如果当前要打包的模块，和之前被提取的模块是同一个，就会复用，而不是重新打包            //         reuseExistingChunk:true            //     }            // }        },        // 将当前模块的记录其他模块的hash单独打包为一个文件runtime        // 如果不加这个会导致hash值储存在js文件（main）中,写了这个代码会使main.js中的代码少很多        //注意存储于js文件的原因是        runtimeChunk:{            name:entrypoint =&gt; `runtime-${entrypoint.name}`        },        // 上面解决的问题：修改a文件导致b文件的hash值变化，        minimizer:[            // 配置生产环境的压缩方案：js与css            new terserWebpackPlugin({                // 开启缓存                cache:true,                // 开启多进程打包                parallel:true,                // 启用source-map，否则被压缩掉                sourceMap:true,            })        ]}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、entry&quot;&gt;&lt;a href=&quot;#1、entry&quot; class=&quot;headerlink&quot; title=&quot;1、entry&quot;&gt;&lt;/a&gt;1、entry&lt;/h1&gt;&lt;p&gt;可以有单入口（string），array（多入口），object&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="webpack学习" scheme="https://useritem.github.io/categories/webpack%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack环境优化</title>
    <link href="https://useritem.github.io/2021/04/26/webpack%E5%AD%A6%E4%B9%A0/webpack%E7%8E%AF%E5%A2%83%E4%BC%98%E5%8C%96/"/>
    <id>https://useritem.github.io/2021/04/26/webpack%E5%AD%A6%E4%B9%A0/webpack%E7%8E%AF%E5%A2%83%E4%BC%98%E5%8C%96/</id>
    <published>2021-04-26T08:15:57.000Z</published>
    <updated>2021-04-28T03:54:15.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、HMR：模块热替换"><a href="#1、HMR：模块热替换" class="headerlink" title="1、HMR：模块热替换"></a>1、HMR：模块热替换</h1><p>当一个模块发生改变时，需要全部进行重新打包，所以使用HMR模块，提高其效率</p><p>样式文件:可以使用HMR功能,因为style-loader自动实习了—–&gt;这就是为啥开发时用style-loader</p><p>js文件:默认没有使用HMR功能–&gt;要修改js代码,添加支持HMR的代码<br>     注意:HMR功能对于js处理,只能处理非入口文件</p><p>html:默认不能使用HMR功能,同时html文件不能热更新，解决:修改entry入口,将html文件引入(它不需要做HMR功能)，不止在plugins中引入：</p><pre><code> entry:['./src/index.js','./src/index.html'],</code></pre><h2 id="js处理（index-js文件下的）："><a href="#js处理（index-js文件下的）：" class="headerlink" title="js处理（index.js文件下的）："></a>js处理（index.js文件下的）：</h2><pre><code>// 一旦module.hot为true,说明开启了HMR功能，这时对某个js文件进行监听module.hot.accept('./print.js',function(){    //方法会监听print.js文件变化,一旦发生变换,其他默认不会打包构建    // 会执行后面的回调函数    print()})}</code></pre><h1 id="2、source-map-–一种映射"><a href="#2、source-map-–一种映射" class="headerlink" title="2、source map   –一种映射"></a>2、source map   –一种映射</h1><h2 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h2><p>source-map:一种提供源代码到构建代码的映射技术(如果构建后代码错误,通过映射可以追踪源代码错误)(外部)</p><h2 id="2、参数（进行组合）"><a href="#2、参数（进行组合）" class="headerlink" title="2、参数（进行组合）"></a>2、参数（进行组合）</h2><pre><code>[inline-|hidden-|eval][nosources][cheap-[module-]] source-map</code></pre><p><strong>注意参数结合顺序</strong></p><pre><code>source-map --&gt;外部</code></pre><p>错误代码的准确信息以及”源代码”的错误位置(从f12中的soucer中看)</p><pre><code> inline-source-map  ---&gt;内联source-map文件</code></pre><p>1.只是一个内联的source-map</p><p>2.错误代码的准确信息以及源代码的错误位置(从f12中的soucer中看) 类似于上</p><pre><code>hidden-source-map --&gt;外部</code></pre><p>提供错误代码的错误原因,没有错误位置,不能指到源代码错误,只能指示到构键后的位置</p><pre><code>eval-source-map   --&gt;   内联</code></pre><p>1.每个文件都有对应的source-map,并且都在eval中</p><p>2.错误代码的准确信息以及源代码的错误位置(从f12中的soucer中看) 类似于上source-map</p><pre><code>nosources-source-map --&gt;外部</code></pre><p>提供错误代码的错误信息,没有任何源代码信息 —&gt;隐藏源代码hidden,nosources</p><pre><code>cheap-source-map --&gt;外部</code></pre><p> 错误代码的准确信息以及源代码的错误位置(从f12中的soucer中看),</p><p> 区别source-map   -=–仅能精确到行</p><pre><code>cheap-module-source-map --&gt;外部</code></pre><p>错误代码的准确信息以及源代码的错误位置</p><p>module会将loader的source,map加入</p><p>内联与外部区别:</p><p>1.外部生成的文件,内联没有</p><p>2.内联更快</p><h2 id="3、使用场景"><a href="#3、使用场景" class="headerlink" title="3、使用场景"></a>3、使用场景</h2><h3 id="（1）开发环境-速度快-调试友好"><a href="#（1）开发环境-速度快-调试友好" class="headerlink" title="（1）开发环境:速度快,调试友好"></a>（1）开发环境:速度快,调试友好</h3><p>速度快:eval –inline –cheap</p><p>eval-cheap-souce-map(1,3组合)  因为这时cheap仅仅精确到行,列忽略</p><p> 调试友好:</p><p>source-map</p><p>cheap-module-source-map</p><p>cheap-source-map</p><p>所以：<br>平衡感觉:eval-source-map(vue,react脚手架中使用)  /eval-cheap-module-source-map（就是没有列的信息）</p><h3 id="（2）生产环境下-源代码是否需要隐藏-调试是否需要友好"><a href="#（2）生产环境下-源代码是否需要隐藏-调试是否需要友好" class="headerlink" title="（2）生产环境下:源代码是否需要隐藏,调试是否需要友好"></a>（2）生产环境下:源代码是否需要隐藏,调试是否需要友好</h3><p>隐藏hidden,nosources</p><p>注意:内联导致代码非常,大,所有使用外部方式</p><pre><code>nosources-source-map-全部隐藏hidden-source-map之隐藏元源代码,会提示构建之后的错误信息</code></pre><p>推荐:source-map  / cheap-module-souce-map</p><h2 id="4、使用方法："><a href="#4、使用方法：" class="headerlink" title="4、使用方法："></a>4、使用方法：</h2><pre><code>devtool:'eval-source-map' //开发</code></pre><h1 id="3、优化打包速度"><a href="#3、优化打包速度" class="headerlink" title="3、优化打包速度"></a>3、优化打包速度</h1><h2 id="1-oneOf"><a href="#1-oneOf" class="headerlink" title="1.oneOf"></a>1.oneOf</h2><p>当在oneOf里面进行寻找loader时，但找到一个<strong>直接进行返回</strong>，注意如果有一种文件对应<strong>多种</strong>loader时，其余的放在oneof之外</p><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><pre><code>{oneOf：[        test:'/\.js$/'    ......    ]}</code></pre><p>把之前的loader放置在oneOf的大数组中，并用{}对数组进行包裹</p><h2 id="2-缓存"><a href="#2-缓存" class="headerlink" title="2.缓存"></a>2.缓存</h2><h3 id="（1）babel缓存"><a href="#（1）babel缓存" class="headerlink" title="（1）babel缓存"></a>（1）babel缓存</h3><pre><code>cacheDirectory:true ----&gt;第二次打包构建速度更快</code></pre><p>直接在presets数组后面的，加这一句话，表示开始babel缓存</p><h3 id="（2）文件资源缓存（优化代码运行）"><a href="#（2）文件资源缓存（优化代码运行）" class="headerlink" title="（2）文件资源缓存（优化代码运行）"></a>（2）文件资源缓存（优化代码运行）</h3><p>hash:每次webpack打包生成的唯一hash值</p><p>问题：由于js与css同时使用一个hash值，如果重新打包，会导致所有打包失效</p><p>但是可能只是改变了一个文件</p><p>chunkhash:根据chunk生成的hash值，如果打包同一个chunk，那么打包一样</p><p>问题：js与csshash值还是一样的</p><p>因为css是在js文件中被引入的，所有属于一个chunk（一个入口文件的所有依赖css，js文件，这些与入口形成一个代码块–chunk）</p><p>contenthash：根据文件的内容生成hash’值，不同的文件内容hash值一定不一样</p><p>—》让代码上线运行缓存更好用</p><pre><code>  output:{    filename:'js/built.[contenthash:10].js',    path:resolve(__dirname,'build')},</code></pre><h1 id="4、优化代码运行的性能"><a href="#4、优化代码运行的性能" class="headerlink" title="4、优化代码运行的性能"></a>4、优化代码运行的性能</h1><h2 id="1-缓存-hash-chunkhash-contenthash-见上"><a href="#1-缓存-hash-chunkhash-contenthash-见上" class="headerlink" title="1.缓存(hash-chunkhash-contenthash)  见上"></a>1.缓存(hash-chunkhash-contenthash)  见上</h2><h2 id="2-tree-shaking"><a href="#2-tree-shaking" class="headerlink" title="2.tree shaking"></a>2.tree shaking</h2><h3 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h3><p>1.必须使用ES6模块化</p><p>2.开启production环境</p><p>主要在于去除无用的代码，，减少代码打包的体积</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p> 在package.js”中配置sideEffects”:false，</p><p>—》这代表所有代码都是没有副作用的—都可以进行tree shaking</p><pre><code>问题：可能干掉css/@babel/polyfill被认为是副作用文件，被干掉</code></pre><ul><li><pre><code> 解决："sideEffects":["*.css","*.less"]</code></pre></li></ul><h2 id="3-code-split-–代码分割"><a href="#3-code-split-–代码分割" class="headerlink" title="3.code split –代码分割"></a>3.code split –代码分割</h2><h3 id="1、通过entry进行文件输出，输出多个文件-多入口"><a href="#1、通过entry进行文件输出，输出多个文件-多入口" class="headerlink" title="1、通过entry进行文件输出，输出多个文件(多入口)"></a>1、通过entry进行文件输出，输出多个文件(多入口)</h3><h3 id="2、optimization设置"><a href="#2、optimization设置" class="headerlink" title="2、optimization设置"></a>2、optimization设置</h3><p>1.可以自动将node_module中的代码打包为一个chunk进行输出</p><p>2.自动分析多入口chunk中，有没有公共文件，有的话单独打包为一个chunk<br>    optimization:{<br>        splitChunks:{<br>            chunks:”all”<br>        }<br>    },</p><h3 id="3、使用js使文件单独打包："><a href="#3、使用js使文件单独打包：" class="headerlink" title="3、使用js使文件单独打包："></a>3、使用js使文件单独打包：</h3><pre><code>// 使后面的test.js进行单独打包 import (/* webpackChunkName:'test'*/'./test.js') .then(({mul,count})=&gt;{     console.log(mul(2,5)) }).catch(()=&gt;{     console.log('文件加载失败') })</code></pre><p>这种使用js语法让<strong>某个</strong>文件打包为一个chunk</p><p>即使用import的动态打包</p><p>而webpackChunkName则是名字的固体规范否则是hash动态变化值</p><h2 id="4-懒加载与预加载"><a href="#4-懒加载与预加载" class="headerlink" title="4.懒加载与预加载"></a>4.懒加载与预加载</h2><p>一个是真的不点击不加载，一个是等着其他加载完了，会偷偷加载</p><p>在原js文件中设置、</p><p>预加载：</p><pre><code>import (/* webpackChunkName:'test',webpackPrefetch:true */'./test').then(({mul}) =&gt;{    console.log(mul(4,6))})</code></pre><p>懒加载：</p><pre><code>import (/* webpackChunkName:'test'*/'./test').then(({mul}) =&gt;{    console.log(mul(4,6))})</code></pre><p>合理使用prefetch可以防止出现点击延迟的问题，等着浏览器空闲时加载也是可以的</p><p>当然了延迟也是第一次延迟，只会内存中就有了，不延迟了</p><h1 id="5、其他设置"><a href="#5、其他设置" class="headerlink" title="5、其他设置"></a>5、其他设置</h1><h2 id="1-pwa-—-渐进式网路开发应用程序（保障离线也可以访问）"><a href="#1-pwa-—-渐进式网路开发应用程序（保障离线也可以访问）" class="headerlink" title="1.pwa — 渐进式网路开发应用程序（保障离线也可以访问）"></a>1.pwa — 渐进式网路开发应用程序（保障离线也可以访问）</h2><p>实现：</p><p>workbox实现—》webpack体现为workbox-webpack-plugin</p><p>代码：</p><pre><code>const WorkboxWebpackPlugin = require('workbox-webpack-plugin') new WorkboxWebpackPlugin.GenerateSW({            // 先设置配置,作用：            /*            1、帮助serviceworker快速启动            2、删除旧的serviceworker            最后生成一个serviceWorker配置文件，之后通过它在入口js文件注册            */          clientsClaim:true,          skipWaiting:true        })</code></pre><p>js入口:</p><pre><code>// 注意这里的servWorker的写法为小驼峰式，第一个小写，其余为大写 if('serviceWorker' in navigator){window.addEventListener('load',()=&gt;{    // 这个文件之后由webpack中的生成    navigator.serviceWorker.register('/service-worker.js').then(()=&gt;{        // 通过then与catch判断是否成功        console.log('sw注册成功')    })    .catch(()=&gt;{        console.log('注册sw失败')    })})}// 成功之后，会在f12中的application中生成一个service Workers//          且Cache中的Cache Storage中会有对应文件的缓存</code></pre><h3 id="配置问题"><a href="#配置问题" class="headerlink" title="配置问题"></a>配置问题</h3><p>1、eslint不认识window，navigator全局变量</p><p> 解决：修改package。json中的eslintConfig配置</p><pre><code>"env":{      "browser":true  //支持浏览器全局变量,browser表示浏览器}</code></pre><p>2.sw必须运行在服务器上  –nodejs</p><p> npm i serve -g   快速创建一个静态资源服务器</p><p> 多了一个指令：– serve -s build  –build表示运行代码的目录</p><p> 之后：会启动一个服务器，将build目录下的静态资源进行部署</p><h2 id="2-externals-–cdn引入文件，不会打包"><a href="#2-externals-–cdn引入文件，不会打包" class="headerlink" title="2.externals  –cdn引入文件，不会打包"></a>2.externals  –cdn引入文件，不会打包</h2><p>在webpack.congfig.js中设置：</p><pre><code>externals:{    // 忽略的库名  --npm包名    jquery:'jQuery'    //目的就是禁止，jquery被打包，但是注意：需要在src中的html中进行引入    // 加一个cdn链接引入，拒绝进行打包}</code></pre><p>表示对某文件的禁用</p><p>之后需要在使用的文件中，用cdn方式进行引入</p><h2 id="3-dll"><a href="#3-dll" class="headerlink" title="3.dll"></a>3.dll</h2><p>当第三方文件需要对文件进行打包引入时，使用dll对文件进行单独打包，注意开始先运行一下webpack.dll.js(webpack –config webpack.dll.js)</p><p>webpack.dll.js:</p><pre><code>const {resolve} = require('path')const webpack = require('webpack')module.exports = {entry:{    // 最终打包生成的[name]  --&gt;jquery    // ['jquery'] --&gt;要打包的库是jquery    jquery:['jquery']},output:{    filename:'[name].js',    //通过resolve进行绝对路径的拼接    path: resolve(__dirname,'dll'),    library:'[name]_[hash]',//打包的库向外暴露的内容叫啥名字},// 前面专门为了打报jqueryplugins:[    // 打包生成一个manifest.json  ----》提供一个jquery映射关系    new webpack.DllPlugin({        name:'[name]_[hash]',  //映射哭的暴露的内容是什么        path:resolve(__dirname,'dll/manifest.json')  //输出路径    })],mode:'production'}</code></pre><p>之后在webpack.config.js文件中进行声明（那些忽略,那些进行引入）</p><pre><code>    // 告诉webpack那些库不参与打包，同时使用时的库也需要修改    new webpack.DllReferencePlugin({        manifest: resolve(__dirname, 'dll/manifest.json')    //忽略jquery    }),    // 将某个文件打包输出出去，并在html中自动引入修改    new AddssetHtmlWebpackPlugin({        filepath:resolve(__dirname,'dll/jquery.js')        //将之前打包的引入    })</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、HMR：模块热替换&quot;&gt;&lt;a href=&quot;#1、HMR：模块热替换&quot; class=&quot;headerlink&quot; title=&quot;1、HMR：模块热替换&quot;&gt;&lt;/a&gt;1、HMR：模块热替换&lt;/h1&gt;&lt;p&gt;当一个模块发生改变时，需要全部进行重新打包，所以使用HMR模块，提高</summary>
      
    
    
    
    <category term="webpack学习" scheme="https://useritem.github.io/categories/webpack%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
</feed>
